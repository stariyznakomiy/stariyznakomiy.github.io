(() => {
    var __webpack_modules__ = {
        88: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.d(__webpack_exports__, {
                Z: () => lottie
            });
            const svgNS = "http://www.w3.org/2000/svg";
            let locationHref = "";
            let _useWebWorker = false;
            const initialDefaultFrame = -999999;
            const setWebWorker = flag => {
                _useWebWorker = !!flag;
            };
            const getWebWorker = () => _useWebWorker;
            const setLocationHref = value => {
                locationHref = value;
            };
            const getLocationHref = () => locationHref;
            function createTag(type) {
                return document.createElement(type);
            }
            function extendPrototype(sources, destination) {
                var i;
                var len = sources.length;
                var sourcePrototype;
                for (i = 0; i < len; i += 1) {
                    sourcePrototype = sources[i].prototype;
                    for (var attr in sourcePrototype) if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
                }
            }
            function getDescriptor(object, prop) {
                return Object.getOwnPropertyDescriptor(object, prop);
            }
            function createProxyFunction(prototype) {
                function ProxyFunction() {}
                ProxyFunction.prototype = prototype;
                return ProxyFunction;
            }
            const audioControllerFactory = function() {
                function AudioController(audioFactory) {
                    this.audios = [];
                    this.audioFactory = audioFactory;
                    this._volume = 1;
                    this._isMuted = false;
                }
                AudioController.prototype = {
                    addAudio: function(audio) {
                        this.audios.push(audio);
                    },
                    pause: function() {
                        var i;
                        var len = this.audios.length;
                        for (i = 0; i < len; i += 1) this.audios[i].pause();
                    },
                    resume: function() {
                        var i;
                        var len = this.audios.length;
                        for (i = 0; i < len; i += 1) this.audios[i].resume();
                    },
                    setRate: function(rateValue) {
                        var i;
                        var len = this.audios.length;
                        for (i = 0; i < len; i += 1) this.audios[i].setRate(rateValue);
                    },
                    createAudio: function(assetPath) {
                        if (this.audioFactory) return this.audioFactory(assetPath);
                        if (window.Howl) return new window.Howl({
                            src: [ assetPath ]
                        });
                        return {
                            isPlaying: false,
                            play: function() {
                                this.isPlaying = true;
                            },
                            seek: function() {
                                this.isPlaying = false;
                            },
                            playing: function() {},
                            rate: function() {},
                            setVolume: function() {}
                        };
                    },
                    setAudioFactory: function(audioFactory) {
                        this.audioFactory = audioFactory;
                    },
                    setVolume: function(value) {
                        this._volume = value;
                        this._updateVolume();
                    },
                    mute: function() {
                        this._isMuted = true;
                        this._updateVolume();
                    },
                    unmute: function() {
                        this._isMuted = false;
                        this._updateVolume();
                    },
                    getVolume: function() {
                        return this._volume;
                    },
                    _updateVolume: function() {
                        var i;
                        var len = this.audios.length;
                        for (i = 0; i < len; i += 1) this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
                    }
                };
                return function() {
                    return new AudioController;
                };
            }();
            const createTypedArray = function() {
                function createRegularArray(type, len) {
                    var i = 0;
                    var arr = [];
                    var value;
                    switch (type) {
                      case "int16":
                      case "uint8c":
                        value = 1;
                        break;

                      default:
                        value = 1.1;
                        break;
                    }
                    for (i = 0; i < len; i += 1) arr.push(value);
                    return arr;
                }
                function createTypedArrayFactory(type, len) {
                    if (type === "float32") return new Float32Array(len);
                    if (type === "int16") return new Int16Array(len);
                    if (type === "uint8c") return new Uint8ClampedArray(len);
                    return createRegularArray(type, len);
                }
                if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") return createTypedArrayFactory;
                return createRegularArray;
            }();
            function createSizedArray(len) {
                return Array.apply(null, {
                    length: len
                });
            }
            let subframeEnabled = true;
            let expressionsPlugin = null;
            let expressionsInterfaces = null;
            let idPrefix$1 = "";
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            let _shouldRoundValues = false;
            const bmPow = Math.pow;
            const bmSqrt = Math.sqrt;
            const bmFloor = Math.floor;
            const bmMax = Math.max;
            const bmMin = Math.min;
            const BMMath = {};
            (function() {
                var propertyNames = [ "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2" ];
                var i;
                var len = propertyNames.length;
                for (i = 0; i < len; i += 1) BMMath[propertyNames[i]] = Math[propertyNames[i]];
            })();
            function ProjectInterface$1() {
                return {};
            }
            BMMath.random = Math.random;
            BMMath.abs = function(val) {
                var tOfVal = typeof val;
                if (tOfVal === "object" && val.length) {
                    var absArr = createSizedArray(val.length);
                    var i;
                    var len = val.length;
                    for (i = 0; i < len; i += 1) absArr[i] = Math.abs(val[i]);
                    return absArr;
                }
                return Math.abs(val);
            };
            let defaultCurveSegments = 150;
            const degToRads = Math.PI / 180;
            const roundCorner = .5519;
            function roundValues(flag) {
                _shouldRoundValues = !!flag;
            }
            function bmRnd(value) {
                if (_shouldRoundValues) return Math.round(value);
                return value;
            }
            function styleDiv(element) {
                element.style.position = "absolute";
                element.style.top = 0;
                element.style.left = 0;
                element.style.display = "block";
                element.style.transformOrigin = "0 0";
                element.style.webkitTransformOrigin = "0 0";
                element.style.backfaceVisibility = "visible";
                element.style.webkitBackfaceVisibility = "visible";
                element.style.transformStyle = "preserve-3d";
                element.style.webkitTransformStyle = "preserve-3d";
                element.style.mozTransformStyle = "preserve-3d";
            }
            function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
                this.type = type;
                this.currentTime = currentTime;
                this.totalTime = totalTime;
                this.direction = frameMultiplier < 0 ? -1 : 1;
            }
            function BMCompleteEvent(type, frameMultiplier) {
                this.type = type;
                this.direction = frameMultiplier < 0 ? -1 : 1;
            }
            function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
                this.type = type;
                this.currentLoop = currentLoop;
                this.totalLoops = totalLoops;
                this.direction = frameMultiplier < 0 ? -1 : 1;
            }
            function BMSegmentStartEvent(type, firstFrame, totalFrames) {
                this.type = type;
                this.firstFrame = firstFrame;
                this.totalFrames = totalFrames;
            }
            function BMDestroyEvent(type, target) {
                this.type = type;
                this.target = target;
            }
            function BMRenderFrameErrorEvent(nativeError, currentTime) {
                this.type = "renderFrameError";
                this.nativeError = nativeError;
                this.currentTime = currentTime;
            }
            function BMConfigErrorEvent(nativeError) {
                this.type = "configError";
                this.nativeError = nativeError;
            }
            function BMAnimationConfigErrorEvent(type, nativeError) {
                this.type = type;
                this.nativeError = nativeError;
            }
            const createElementID = function() {
                var _count = 0;
                return function createID() {
                    _count += 1;
                    return idPrefix$1 + "__lottie_element_" + _count;
                };
            }();
            function HSVtoRGB(h, s, v) {
                var r;
                var g;
                var b;
                var i;
                var f;
                var p;
                var q;
                var t;
                i = Math.floor(h * 6);
                f = h * 6 - i;
                p = v * (1 - s);
                q = v * (1 - f * s);
                t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                  case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;

                  case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;

                  case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;

                  case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;

                  case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;

                  case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;

                  default:
                    break;
                }
                return [ r, g, b ];
            }
            function RGBtoHSV(r, g, b) {
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                var d = max - min;
                var h;
                var s = max === 0 ? 0 : d / max;
                var v = max / 255;
                switch (max) {
                  case min:
                    h = 0;
                    break;

                  case r:
                    h = g - b + d * (g < b ? 6 : 0);
                    h /= 6 * d;
                    break;

                  case g:
                    h = b - r + d * 2;
                    h /= 6 * d;
                    break;

                  case b:
                    h = r - g + d * 4;
                    h /= 6 * d;
                    break;

                  default:
                    break;
                }
                return [ h, s, v ];
            }
            function addSaturationToRGB(color, offset) {
                var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
                hsv[1] += offset;
                if (hsv[1] > 1) hsv[1] = 1; else if (hsv[1] <= 0) hsv[1] = 0;
                return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
            }
            function addBrightnessToRGB(color, offset) {
                var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
                hsv[2] += offset;
                if (hsv[2] > 1) hsv[2] = 1; else if (hsv[2] < 0) hsv[2] = 0;
                return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
            }
            function addHueToRGB(color, offset) {
                var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
                hsv[0] += offset / 360;
                if (hsv[0] > 1) hsv[0] -= 1; else if (hsv[0] < 0) hsv[0] += 1;
                return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
            }
            const rgbToHex = function() {
                var colorMap = [];
                var i;
                var hex;
                for (i = 0; i < 256; i += 1) {
                    hex = i.toString(16);
                    colorMap[i] = hex.length === 1 ? "0" + hex : hex;
                }
                return function(r, g, b) {
                    if (r < 0) r = 0;
                    if (g < 0) g = 0;
                    if (b < 0) b = 0;
                    return "#" + colorMap[r] + colorMap[g] + colorMap[b];
                };
            }();
            const setSubframeEnabled = flag => {
                subframeEnabled = !!flag;
            };
            const getSubframeEnabled = () => subframeEnabled;
            const setExpressionsPlugin = value => {
                expressionsPlugin = value;
            };
            const getExpressionsPlugin = () => expressionsPlugin;
            const setExpressionInterfaces = value => {
                expressionsInterfaces = value;
            };
            const getExpressionInterfaces = () => expressionsInterfaces;
            const setDefaultCurveSegments = value => {
                defaultCurveSegments = value;
            };
            const getDefaultCurveSegments = () => defaultCurveSegments;
            const setIdPrefix = value => {
                idPrefix$1 = value;
            };
            const getIdPrefix = () => idPrefix$1;
            function createNS(type) {
                return document.createElementNS(svgNS, type);
            }
            const dataManager = function() {
                var _counterId = 1;
                var processes = [];
                var workerFn;
                var workerInstance;
                var workerProxy = {
                    onmessage: function() {},
                    postMessage: function(path) {
                        workerFn({
                            data: path
                        });
                    }
                };
                var _workerSelf = {
                    postMessage: function(data) {
                        workerProxy.onmessage({
                            data
                        });
                    }
                };
                function createWorker(fn) {
                    if (window.Worker && window.Blob && getWebWorker()) {
                        var blob = new Blob([ "var _workerSelf = self; self.onmessage = ", fn.toString() ], {
                            type: "text/javascript"
                        });
                        var url = URL.createObjectURL(blob);
                        return new Worker(url);
                    }
                    workerFn = fn;
                    return workerProxy;
                }
                function setupWorker() {
                    if (!workerInstance) {
                        workerInstance = createWorker((function workerStart(e) {
                            function dataFunctionManager() {
                                function completeLayers(layers, comps) {
                                    var layerData;
                                    var i;
                                    var len = layers.length;
                                    var j;
                                    var jLen;
                                    var k;
                                    var kLen;
                                    for (i = 0; i < len; i += 1) {
                                        layerData = layers[i];
                                        if ("ks" in layerData && !layerData.completed) {
                                            layerData.completed = true;
                                            if (layerData.hasMask) {
                                                var maskProps = layerData.masksProperties;
                                                jLen = maskProps.length;
                                                for (j = 0; j < jLen; j += 1) if (maskProps[j].pt.k.i) convertPathsToAbsoluteValues(maskProps[j].pt.k); else {
                                                    kLen = maskProps[j].pt.k.length;
                                                    for (k = 0; k < kLen; k += 1) {
                                                        if (maskProps[j].pt.k[k].s) convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                                                        if (maskProps[j].pt.k[k].e) convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                                                    }
                                                }
                                            }
                                            if (layerData.ty === 0) {
                                                layerData.layers = findCompLayers(layerData.refId, comps);
                                                completeLayers(layerData.layers, comps);
                                            } else if (layerData.ty === 4) completeShapes(layerData.shapes); else if (layerData.ty === 5) completeText(layerData);
                                        }
                                    }
                                }
                                function completeChars(chars, assets) {
                                    if (chars) {
                                        var i = 0;
                                        var len = chars.length;
                                        for (i = 0; i < len; i += 1) if (chars[i].t === 1) {
                                            chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);
                                            completeLayers(chars[i].data.layers, assets);
                                        }
                                    }
                                }
                                function findComp(id, comps) {
                                    var i = 0;
                                    var len = comps.length;
                                    while (i < len) {
                                        if (comps[i].id === id) return comps[i];
                                        i += 1;
                                    }
                                    return null;
                                }
                                function findCompLayers(id, comps) {
                                    var comp = findComp(id, comps);
                                    if (comp) {
                                        if (!comp.layers.__used) {
                                            comp.layers.__used = true;
                                            return comp.layers;
                                        }
                                        return JSON.parse(JSON.stringify(comp.layers));
                                    }
                                    return null;
                                }
                                function completeShapes(arr) {
                                    var i;
                                    var len = arr.length;
                                    var j;
                                    var jLen;
                                    for (i = len - 1; i >= 0; i -= 1) if (arr[i].ty === "sh") if (arr[i].ks.k.i) convertPathsToAbsoluteValues(arr[i].ks.k); else {
                                        jLen = arr[i].ks.k.length;
                                        for (j = 0; j < jLen; j += 1) {
                                            if (arr[i].ks.k[j].s) convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                                            if (arr[i].ks.k[j].e) convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                                        }
                                    } else if (arr[i].ty === "gr") completeShapes(arr[i].it);
                                }
                                function convertPathsToAbsoluteValues(path) {
                                    var i;
                                    var len = path.i.length;
                                    for (i = 0; i < len; i += 1) {
                                        path.i[i][0] += path.v[i][0];
                                        path.i[i][1] += path.v[i][1];
                                        path.o[i][0] += path.v[i][0];
                                        path.o[i][1] += path.v[i][1];
                                    }
                                }
                                function checkVersion(minimum, animVersionString) {
                                    var animVersion = animVersionString ? animVersionString.split(".") : [ 100, 100, 100 ];
                                    if (minimum[0] > animVersion[0]) return true;
                                    if (animVersion[0] > minimum[0]) return false;
                                    if (minimum[1] > animVersion[1]) return true;
                                    if (animVersion[1] > minimum[1]) return false;
                                    if (minimum[2] > animVersion[2]) return true;
                                    if (animVersion[2] > minimum[2]) return false;
                                    return null;
                                }
                                var checkText = function() {
                                    var minimumVersion = [ 4, 4, 14 ];
                                    function updateTextLayer(textLayer) {
                                        var documentData = textLayer.t.d;
                                        textLayer.t.d = {
                                            k: [ {
                                                s: documentData,
                                                t: 0
                                            } ]
                                        };
                                    }
                                    function iterateLayers(layers) {
                                        var i;
                                        var len = layers.length;
                                        for (i = 0; i < len; i += 1) if (layers[i].ty === 5) updateTextLayer(layers[i]);
                                    }
                                    return function(animationData) {
                                        if (checkVersion(minimumVersion, animationData.v)) {
                                            iterateLayers(animationData.layers);
                                            if (animationData.assets) {
                                                var i;
                                                var len = animationData.assets.length;
                                                for (i = 0; i < len; i += 1) if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                            }
                                        }
                                    };
                                }();
                                var checkChars = function() {
                                    var minimumVersion = [ 4, 7, 99 ];
                                    return function(animationData) {
                                        if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                                            var i;
                                            var len = animationData.chars.length;
                                            for (i = 0; i < len; i += 1) {
                                                var charData = animationData.chars[i];
                                                if (charData.data && charData.data.shapes) {
                                                    completeShapes(charData.data.shapes);
                                                    charData.data.ip = 0;
                                                    charData.data.op = 99999;
                                                    charData.data.st = 0;
                                                    charData.data.sr = 1;
                                                    charData.data.ks = {
                                                        p: {
                                                            k: [ 0, 0 ],
                                                            a: 0
                                                        },
                                                        s: {
                                                            k: [ 100, 100 ],
                                                            a: 0
                                                        },
                                                        a: {
                                                            k: [ 0, 0 ],
                                                            a: 0
                                                        },
                                                        r: {
                                                            k: 0,
                                                            a: 0
                                                        },
                                                        o: {
                                                            k: 100,
                                                            a: 0
                                                        }
                                                    };
                                                    if (!animationData.chars[i].t) {
                                                        charData.data.shapes.push({
                                                            ty: "no"
                                                        });
                                                        charData.data.shapes[0].it.push({
                                                            p: {
                                                                k: [ 0, 0 ],
                                                                a: 0
                                                            },
                                                            s: {
                                                                k: [ 100, 100 ],
                                                                a: 0
                                                            },
                                                            a: {
                                                                k: [ 0, 0 ],
                                                                a: 0
                                                            },
                                                            r: {
                                                                k: 0,
                                                                a: 0
                                                            },
                                                            o: {
                                                                k: 100,
                                                                a: 0
                                                            },
                                                            sk: {
                                                                k: 0,
                                                                a: 0
                                                            },
                                                            sa: {
                                                                k: 0,
                                                                a: 0
                                                            },
                                                            ty: "tr"
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    };
                                }();
                                var checkPathProperties = function() {
                                    var minimumVersion = [ 5, 7, 15 ];
                                    function updateTextLayer(textLayer) {
                                        var pathData = textLayer.t.p;
                                        if (typeof pathData.a === "number") pathData.a = {
                                            a: 0,
                                            k: pathData.a
                                        };
                                        if (typeof pathData.p === "number") pathData.p = {
                                            a: 0,
                                            k: pathData.p
                                        };
                                        if (typeof pathData.r === "number") pathData.r = {
                                            a: 0,
                                            k: pathData.r
                                        };
                                    }
                                    function iterateLayers(layers) {
                                        var i;
                                        var len = layers.length;
                                        for (i = 0; i < len; i += 1) if (layers[i].ty === 5) updateTextLayer(layers[i]);
                                    }
                                    return function(animationData) {
                                        if (checkVersion(minimumVersion, animationData.v)) {
                                            iterateLayers(animationData.layers);
                                            if (animationData.assets) {
                                                var i;
                                                var len = animationData.assets.length;
                                                for (i = 0; i < len; i += 1) if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                            }
                                        }
                                    };
                                }();
                                var checkColors = function() {
                                    var minimumVersion = [ 4, 1, 9 ];
                                    function iterateShapes(shapes) {
                                        var i;
                                        var len = shapes.length;
                                        var j;
                                        var jLen;
                                        for (i = 0; i < len; i += 1) if (shapes[i].ty === "gr") iterateShapes(shapes[i].it); else if (shapes[i].ty === "fl" || shapes[i].ty === "st") if (shapes[i].c.k && shapes[i].c.k[0].i) {
                                            jLen = shapes[i].c.k.length;
                                            for (j = 0; j < jLen; j += 1) {
                                                if (shapes[i].c.k[j].s) {
                                                    shapes[i].c.k[j].s[0] /= 255;
                                                    shapes[i].c.k[j].s[1] /= 255;
                                                    shapes[i].c.k[j].s[2] /= 255;
                                                    shapes[i].c.k[j].s[3] /= 255;
                                                }
                                                if (shapes[i].c.k[j].e) {
                                                    shapes[i].c.k[j].e[0] /= 255;
                                                    shapes[i].c.k[j].e[1] /= 255;
                                                    shapes[i].c.k[j].e[2] /= 255;
                                                    shapes[i].c.k[j].e[3] /= 255;
                                                }
                                            }
                                        } else {
                                            shapes[i].c.k[0] /= 255;
                                            shapes[i].c.k[1] /= 255;
                                            shapes[i].c.k[2] /= 255;
                                            shapes[i].c.k[3] /= 255;
                                        }
                                    }
                                    function iterateLayers(layers) {
                                        var i;
                                        var len = layers.length;
                                        for (i = 0; i < len; i += 1) if (layers[i].ty === 4) iterateShapes(layers[i].shapes);
                                    }
                                    return function(animationData) {
                                        if (checkVersion(minimumVersion, animationData.v)) {
                                            iterateLayers(animationData.layers);
                                            if (animationData.assets) {
                                                var i;
                                                var len = animationData.assets.length;
                                                for (i = 0; i < len; i += 1) if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                            }
                                        }
                                    };
                                }();
                                var checkShapes = function() {
                                    var minimumVersion = [ 4, 4, 18 ];
                                    function completeClosingShapes(arr) {
                                        var i;
                                        var len = arr.length;
                                        var j;
                                        var jLen;
                                        for (i = len - 1; i >= 0; i -= 1) if (arr[i].ty === "sh") if (arr[i].ks.k.i) arr[i].ks.k.c = arr[i].closed; else {
                                            jLen = arr[i].ks.k.length;
                                            for (j = 0; j < jLen; j += 1) {
                                                if (arr[i].ks.k[j].s) arr[i].ks.k[j].s[0].c = arr[i].closed;
                                                if (arr[i].ks.k[j].e) arr[i].ks.k[j].e[0].c = arr[i].closed;
                                            }
                                        } else if (arr[i].ty === "gr") completeClosingShapes(arr[i].it);
                                    }
                                    function iterateLayers(layers) {
                                        var layerData;
                                        var i;
                                        var len = layers.length;
                                        var j;
                                        var jLen;
                                        var k;
                                        var kLen;
                                        for (i = 0; i < len; i += 1) {
                                            layerData = layers[i];
                                            if (layerData.hasMask) {
                                                var maskProps = layerData.masksProperties;
                                                jLen = maskProps.length;
                                                for (j = 0; j < jLen; j += 1) if (maskProps[j].pt.k.i) maskProps[j].pt.k.c = maskProps[j].cl; else {
                                                    kLen = maskProps[j].pt.k.length;
                                                    for (k = 0; k < kLen; k += 1) {
                                                        if (maskProps[j].pt.k[k].s) maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                                                        if (maskProps[j].pt.k[k].e) maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                                                    }
                                                }
                                            }
                                            if (layerData.ty === 4) completeClosingShapes(layerData.shapes);
                                        }
                                    }
                                    return function(animationData) {
                                        if (checkVersion(minimumVersion, animationData.v)) {
                                            iterateLayers(animationData.layers);
                                            if (animationData.assets) {
                                                var i;
                                                var len = animationData.assets.length;
                                                for (i = 0; i < len; i += 1) if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                            }
                                        }
                                    };
                                }();
                                function completeData(animationData) {
                                    if (animationData.__complete) return;
                                    checkColors(animationData);
                                    checkText(animationData);
                                    checkChars(animationData);
                                    checkPathProperties(animationData);
                                    checkShapes(animationData);
                                    completeLayers(animationData.layers, animationData.assets);
                                    completeChars(animationData.chars, animationData.assets);
                                    animationData.__complete = true;
                                }
                                function completeText(data) {
                                    if (data.t.a.length === 0 && !("m" in data.t.p)) ;
                                }
                                var moduleOb = {};
                                moduleOb.completeData = completeData;
                                moduleOb.checkColors = checkColors;
                                moduleOb.checkChars = checkChars;
                                moduleOb.checkPathProperties = checkPathProperties;
                                moduleOb.checkShapes = checkShapes;
                                moduleOb.completeLayers = completeLayers;
                                return moduleOb;
                            }
                            if (!_workerSelf.dataManager) _workerSelf.dataManager = dataFunctionManager();
                            if (!_workerSelf.assetLoader) _workerSelf.assetLoader = function() {
                                function formatResponse(xhr) {
                                    var contentTypeHeader = xhr.getResponseHeader("content-type");
                                    if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) return xhr.response;
                                    if (xhr.response && typeof xhr.response === "object") return xhr.response;
                                    if (xhr.response && typeof xhr.response === "string") return JSON.parse(xhr.response);
                                    if (xhr.responseText) return JSON.parse(xhr.responseText);
                                    return null;
                                }
                                function loadAsset(path, fullPath, callback, errorCallback) {
                                    var response;
                                    var xhr = new XMLHttpRequest;
                                    try {
                                        xhr.responseType = "json";
                                    } catch (err) {}
                                    xhr.onreadystatechange = function() {
                                        if (xhr.readyState === 4) if (xhr.status === 200) {
                                            response = formatResponse(xhr);
                                            callback(response);
                                        } else try {
                                            response = formatResponse(xhr);
                                            callback(response);
                                        } catch (err) {
                                            if (errorCallback) errorCallback(err);
                                        }
                                    };
                                    try {
                                        xhr.open([ "G", "E", "T" ].join(""), path, true);
                                    } catch (error) {
                                        xhr.open([ "G", "E", "T" ].join(""), fullPath + "/" + path, true);
                                    }
                                    xhr.send();
                                }
                                return {
                                    load: loadAsset
                                };
                            }();
                            if (e.data.type === "loadAnimation") _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, (function(data) {
                                _workerSelf.dataManager.completeData(data);
                                _workerSelf.postMessage({
                                    id: e.data.id,
                                    payload: data,
                                    status: "success"
                                });
                            }), (function() {
                                _workerSelf.postMessage({
                                    id: e.data.id,
                                    status: "error"
                                });
                            })); else if (e.data.type === "complete") {
                                var animation = e.data.animation;
                                _workerSelf.dataManager.completeData(animation);
                                _workerSelf.postMessage({
                                    id: e.data.id,
                                    payload: animation,
                                    status: "success"
                                });
                            } else if (e.data.type === "loadData") _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, (function(data) {
                                _workerSelf.postMessage({
                                    id: e.data.id,
                                    payload: data,
                                    status: "success"
                                });
                            }), (function() {
                                _workerSelf.postMessage({
                                    id: e.data.id,
                                    status: "error"
                                });
                            }));
                        }));
                        workerInstance.onmessage = function(event) {
                            var data = event.data;
                            var id = data.id;
                            var process = processes[id];
                            processes[id] = null;
                            if (data.status === "success") process.onComplete(data.payload); else if (process.onError) process.onError();
                        };
                    }
                }
                function createProcess(onComplete, onError) {
                    _counterId += 1;
                    var id = "processId_" + _counterId;
                    processes[id] = {
                        onComplete,
                        onError
                    };
                    return id;
                }
                function loadAnimation(path, onComplete, onError) {
                    setupWorker();
                    var processId = createProcess(onComplete, onError);
                    workerInstance.postMessage({
                        type: "loadAnimation",
                        path,
                        fullPath: window.location.origin + window.location.pathname,
                        id: processId
                    });
                }
                function loadData(path, onComplete, onError) {
                    setupWorker();
                    var processId = createProcess(onComplete, onError);
                    workerInstance.postMessage({
                        type: "loadData",
                        path,
                        fullPath: window.location.origin + window.location.pathname,
                        id: processId
                    });
                }
                function completeAnimation(anim, onComplete, onError) {
                    setupWorker();
                    var processId = createProcess(onComplete, onError);
                    workerInstance.postMessage({
                        type: "complete",
                        animation: anim,
                        id: processId
                    });
                }
                return {
                    loadAnimation,
                    loadData,
                    completeAnimation
                };
            }();
            const ImagePreloader = function() {
                var proxyImage = function() {
                    var canvas = createTag("canvas");
                    canvas.width = 1;
                    canvas.height = 1;
                    var ctx = canvas.getContext("2d");
                    ctx.fillStyle = "rgba(0,0,0,0)";
                    ctx.fillRect(0, 0, 1, 1);
                    return canvas;
                }();
                function imageLoaded() {
                    this.loadedAssets += 1;
                    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) if (this.imagesLoadedCb) this.imagesLoadedCb(null);
                }
                function footageLoaded() {
                    this.loadedFootagesCount += 1;
                    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) if (this.imagesLoadedCb) this.imagesLoadedCb(null);
                }
                function getAssetsPath(assetData, assetsPath, originalPath) {
                    var path = "";
                    if (assetData.e) path = assetData.p; else if (assetsPath) {
                        var imagePath = assetData.p;
                        if (imagePath.indexOf("images/") !== -1) imagePath = imagePath.split("/")[1];
                        path = assetsPath + imagePath;
                    } else {
                        path = originalPath;
                        path += assetData.u ? assetData.u : "";
                        path += assetData.p;
                    }
                    return path;
                }
                function testImageLoaded(img) {
                    var _count = 0;
                    var intervalId = setInterval(function() {
                        var box = img.getBBox();
                        if (box.width || _count > 500) {
                            this._imageLoaded();
                            clearInterval(intervalId);
                        }
                        _count += 1;
                    }.bind(this), 50);
                }
                function createImageData(assetData) {
                    var path = getAssetsPath(assetData, this.assetsPath, this.path);
                    var img = createNS("image");
                    if (isSafari) this.testImageLoaded(img); else img.addEventListener("load", this._imageLoaded, false);
                    img.addEventListener("error", function() {
                        ob.img = proxyImage;
                        this._imageLoaded();
                    }.bind(this), false);
                    img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
                    if (this._elementHelper.append) this._elementHelper.append(img); else this._elementHelper.appendChild(img);
                    var ob = {
                        img,
                        assetData
                    };
                    return ob;
                }
                function createImgData(assetData) {
                    var path = getAssetsPath(assetData, this.assetsPath, this.path);
                    var img = createTag("img");
                    img.crossOrigin = "anonymous";
                    img.addEventListener("load", this._imageLoaded, false);
                    img.addEventListener("error", function() {
                        ob.img = proxyImage;
                        this._imageLoaded();
                    }.bind(this), false);
                    img.src = path;
                    var ob = {
                        img,
                        assetData
                    };
                    return ob;
                }
                function createFootageData(data) {
                    var ob = {
                        assetData: data
                    };
                    var path = getAssetsPath(data, this.assetsPath, this.path);
                    dataManager.loadData(path, function(footageData) {
                        ob.img = footageData;
                        this._footageLoaded();
                    }.bind(this), function() {
                        ob.img = {};
                        this._footageLoaded();
                    }.bind(this));
                    return ob;
                }
                function loadAssets(assets, cb) {
                    this.imagesLoadedCb = cb;
                    var i;
                    var len = assets.length;
                    for (i = 0; i < len; i += 1) if (!assets[i].layers) if (!assets[i].t || assets[i].t === "seq") {
                        this.totalImages += 1;
                        this.images.push(this._createImageData(assets[i]));
                    } else if (assets[i].t === 3) {
                        this.totalFootages += 1;
                        this.images.push(this.createFootageData(assets[i]));
                    }
                }
                function setPath(path) {
                    this.path = path || "";
                }
                function setAssetsPath(path) {
                    this.assetsPath = path || "";
                }
                function getAsset(assetData) {
                    var i = 0;
                    var len = this.images.length;
                    while (i < len) {
                        if (this.images[i].assetData === assetData) return this.images[i].img;
                        i += 1;
                    }
                    return null;
                }
                function destroy() {
                    this.imagesLoadedCb = null;
                    this.images.length = 0;
                }
                function loadedImages() {
                    return this.totalImages === this.loadedAssets;
                }
                function loadedFootages() {
                    return this.totalFootages === this.loadedFootagesCount;
                }
                function setCacheType(type, elementHelper) {
                    if (type === "svg") {
                        this._elementHelper = elementHelper;
                        this._createImageData = this.createImageData.bind(this);
                    } else this._createImageData = this.createImgData.bind(this);
                }
                function ImagePreloaderFactory() {
                    this._imageLoaded = imageLoaded.bind(this);
                    this._footageLoaded = footageLoaded.bind(this);
                    this.testImageLoaded = testImageLoaded.bind(this);
                    this.createFootageData = createFootageData.bind(this);
                    this.assetsPath = "";
                    this.path = "";
                    this.totalImages = 0;
                    this.totalFootages = 0;
                    this.loadedAssets = 0;
                    this.loadedFootagesCount = 0;
                    this.imagesLoadedCb = null;
                    this.images = [];
                }
                ImagePreloaderFactory.prototype = {
                    loadAssets,
                    setAssetsPath,
                    setPath,
                    loadedImages,
                    loadedFootages,
                    destroy,
                    getAsset,
                    createImgData,
                    createImageData,
                    imageLoaded,
                    footageLoaded,
                    setCacheType
                };
                return ImagePreloaderFactory;
            }();
            function BaseEvent() {}
            BaseEvent.prototype = {
                triggerEvent: function(eventName, args) {
                    if (this._cbs[eventName]) {
                        var callbacks = this._cbs[eventName];
                        for (var i = 0; i < callbacks.length; i += 1) callbacks[i](args);
                    }
                },
                addEventListener: function(eventName, callback) {
                    if (!this._cbs[eventName]) this._cbs[eventName] = [];
                    this._cbs[eventName].push(callback);
                    return function() {
                        this.removeEventListener(eventName, callback);
                    }.bind(this);
                },
                removeEventListener: function(eventName, callback) {
                    if (!callback) this._cbs[eventName] = null; else if (this._cbs[eventName]) {
                        var i = 0;
                        var len = this._cbs[eventName].length;
                        while (i < len) {
                            if (this._cbs[eventName][i] === callback) {
                                this._cbs[eventName].splice(i, 1);
                                i -= 1;
                                len -= 1;
                            }
                            i += 1;
                        }
                        if (!this._cbs[eventName].length) this._cbs[eventName] = null;
                    }
                }
            };
            const markerParser = function() {
                function parsePayloadLines(payload) {
                    var lines = payload.split("\r\n");
                    var keys = {};
                    var line;
                    var keysCount = 0;
                    for (var i = 0; i < lines.length; i += 1) {
                        line = lines[i].split(":");
                        if (line.length === 2) {
                            keys[line[0]] = line[1].trim();
                            keysCount += 1;
                        }
                    }
                    if (keysCount === 0) throw new Error;
                    return keys;
                }
                return function(_markers) {
                    var markers = [];
                    for (var i = 0; i < _markers.length; i += 1) {
                        var _marker = _markers[i];
                        var markerData = {
                            time: _marker.tm,
                            duration: _marker.dr
                        };
                        try {
                            markerData.payload = JSON.parse(_markers[i].cm);
                        } catch (_) {
                            try {
                                markerData.payload = parsePayloadLines(_markers[i].cm);
                            } catch (__) {
                                markerData.payload = {
                                    name: _markers[i].cm
                                };
                            }
                        }
                        markers.push(markerData);
                    }
                    return markers;
                };
            }();
            const ProjectInterface = function() {
                function registerComposition(comp) {
                    this.compositions.push(comp);
                }
                return function() {
                    function _thisProjectFunction(name) {
                        var i = 0;
                        var len = this.compositions.length;
                        while (i < len) {
                            if (this.compositions[i].data && this.compositions[i].data.nm === name) {
                                if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) this.compositions[i].prepareFrame(this.currentFrame);
                                return this.compositions[i].compInterface;
                            }
                            i += 1;
                        }
                        return null;
                    }
                    _thisProjectFunction.compositions = [];
                    _thisProjectFunction.currentFrame = 0;
                    _thisProjectFunction.registerComposition = registerComposition;
                    return _thisProjectFunction;
                };
            }();
            const renderers = {};
            const registerRenderer = (key, value) => {
                renderers[key] = value;
            };
            function getRenderer(key) {
                return renderers[key];
            }
            function getRegisteredRenderer() {
                if (renderers.canvas) return "canvas";
                for (const key in renderers) if (renderers[key]) return key;
                return "";
            }
            const AnimationItem = function() {
                this._cbs = [];
                this.name = "";
                this.path = "";
                this.isLoaded = false;
                this.currentFrame = 0;
                this.currentRawFrame = 0;
                this.firstFrame = 0;
                this.totalFrames = 0;
                this.frameRate = 0;
                this.frameMult = 0;
                this.playSpeed = 1;
                this.playDirection = 1;
                this.playCount = 0;
                this.animationData = {};
                this.assets = [];
                this.isPaused = true;
                this.autoplay = false;
                this.loop = true;
                this.renderer = null;
                this.animationID = createElementID();
                this.assetsPath = "";
                this.timeCompleted = 0;
                this.segmentPos = 0;
                this.isSubframeEnabled = getSubframeEnabled();
                this.segments = [];
                this._idle = true;
                this._completedLoop = false;
                this.projectInterface = ProjectInterface();
                this.imagePreloader = new ImagePreloader;
                this.audioController = audioControllerFactory();
                this.markers = [];
                this.configAnimation = this.configAnimation.bind(this);
                this.onSetupError = this.onSetupError.bind(this);
                this.onSegmentComplete = this.onSegmentComplete.bind(this);
                this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
                this.expressionsPlugin = getExpressionsPlugin();
            };
            extendPrototype([ BaseEvent ], AnimationItem);
            AnimationItem.prototype.setParams = function(params) {
                if (params.wrapper || params.container) this.wrapper = params.wrapper || params.container;
                var animType = "svg";
                if (params.animType) animType = params.animType; else if (params.renderer) animType = params.renderer;
                const RendererClass = getRenderer(animType);
                this.renderer = new RendererClass(this, params.rendererSettings);
                this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
                this.renderer.setProjectInterface(this.projectInterface);
                this.animType = animType;
                if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) this.loop = true; else if (params.loop === false) this.loop = false; else this.loop = parseInt(params.loop, 10);
                this.autoplay = "autoplay" in params ? params.autoplay : true;
                this.name = params.name ? params.name : "";
                this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
                this.assetsPath = params.assetsPath;
                this.initialSegment = params.initialSegment;
                if (params.audioFactory) this.audioController.setAudioFactory(params.audioFactory);
                if (params.animationData) this.setupAnimation(params.animationData); else if (params.path) {
                    if (params.path.lastIndexOf("\\") !== -1) this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1); else this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
                    this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
                    this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
                    dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
                }
            };
            AnimationItem.prototype.onSetupError = function() {
                this.trigger("data_failed");
            };
            AnimationItem.prototype.setupAnimation = function(data) {
                dataManager.completeAnimation(data, this.configAnimation);
            };
            AnimationItem.prototype.setData = function(wrapper, animationData) {
                if (animationData) if (typeof animationData !== "object") animationData = JSON.parse(animationData);
                var params = {
                    wrapper,
                    animationData
                };
                var wrapperAttributes = wrapper.attributes;
                params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
                params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
                var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
                if (loop === "false") params.loop = false; else if (loop === "true") params.loop = true; else if (loop !== "") params.loop = parseInt(loop, 10);
                var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
                params.autoplay = autoplay !== "false";
                params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
                var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
                if (prerender === "false") params.prerender = false;
                if (!params.path) this.trigger("destroy"); else this.setParams(params);
            };
            AnimationItem.prototype.includeLayers = function(data) {
                if (data.op > this.animationData.op) {
                    this.animationData.op = data.op;
                    this.totalFrames = Math.floor(data.op - this.animationData.ip);
                }
                var layers = this.animationData.layers;
                var i;
                var len = layers.length;
                var newLayers = data.layers;
                var j;
                var jLen = newLayers.length;
                for (j = 0; j < jLen; j += 1) {
                    i = 0;
                    while (i < len) {
                        if (layers[i].id === newLayers[j].id) {
                            layers[i] = newLayers[j];
                            break;
                        }
                        i += 1;
                    }
                }
                if (data.chars || data.fonts) {
                    this.renderer.globalData.fontManager.addChars(data.chars);
                    this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
                }
                if (data.assets) {
                    len = data.assets.length;
                    for (i = 0; i < len; i += 1) this.animationData.assets.push(data.assets[i]);
                }
                this.animationData.__complete = false;
                dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
            };
            AnimationItem.prototype.onSegmentComplete = function(data) {
                this.animationData = data;
                var expressionsPlugin = getExpressionsPlugin();
                if (expressionsPlugin) expressionsPlugin.initExpressions(this);
                this.loadNextSegment();
            };
            AnimationItem.prototype.loadNextSegment = function() {
                var segments = this.animationData.segments;
                if (!segments || segments.length === 0 || !this.autoloadSegments) {
                    this.trigger("data_ready");
                    this.timeCompleted = this.totalFrames;
                    return;
                }
                var segment = segments.shift();
                this.timeCompleted = segment.time * this.frameRate;
                var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
                this.segmentPos += 1;
                dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
                    this.trigger("data_failed");
                }.bind(this));
            };
            AnimationItem.prototype.loadSegments = function() {
                var segments = this.animationData.segments;
                if (!segments) this.timeCompleted = this.totalFrames;
                this.loadNextSegment();
            };
            AnimationItem.prototype.imagesLoaded = function() {
                this.trigger("loaded_images");
                this.checkLoaded();
            };
            AnimationItem.prototype.preloadImages = function() {
                this.imagePreloader.setAssetsPath(this.assetsPath);
                this.imagePreloader.setPath(this.path);
                this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
            };
            AnimationItem.prototype.configAnimation = function(animData) {
                if (!this.renderer) return;
                try {
                    this.animationData = animData;
                    if (this.initialSegment) {
                        this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
                        this.firstFrame = Math.round(this.initialSegment[0]);
                    } else {
                        this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
                        this.firstFrame = Math.round(this.animationData.ip);
                    }
                    this.renderer.configAnimation(animData);
                    if (!animData.assets) animData.assets = [];
                    this.assets = this.animationData.assets;
                    this.frameRate = this.animationData.fr;
                    this.frameMult = this.animationData.fr / 1e3;
                    this.renderer.searchExtraCompositions(animData.assets);
                    this.markers = markerParser(animData.markers || []);
                    this.trigger("config_ready");
                    this.preloadImages();
                    this.loadSegments();
                    this.updaFrameModifier();
                    this.waitForFontsLoaded();
                    if (this.isPaused) this.audioController.pause();
                } catch (error) {
                    this.triggerConfigError(error);
                }
            };
            AnimationItem.prototype.waitForFontsLoaded = function() {
                if (!this.renderer) return;
                if (this.renderer.globalData.fontManager.isLoaded) this.checkLoaded(); else setTimeout(this.waitForFontsLoaded.bind(this), 20);
            };
            AnimationItem.prototype.checkLoaded = function() {
                if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
                    this.isLoaded = true;
                    var expressionsPlugin = getExpressionsPlugin();
                    if (expressionsPlugin) expressionsPlugin.initExpressions(this);
                    this.renderer.initItems();
                    setTimeout(function() {
                        this.trigger("DOMLoaded");
                    }.bind(this), 0);
                    this.gotoFrame();
                    if (this.autoplay) this.play();
                }
            };
            AnimationItem.prototype.resize = function(width, height) {
                var _width = typeof width === "number" ? width : void 0;
                var _height = typeof height === "number" ? height : void 0;
                this.renderer.updateContainerSize(_width, _height);
            };
            AnimationItem.prototype.setSubframe = function(flag) {
                this.isSubframeEnabled = !!flag;
            };
            AnimationItem.prototype.gotoFrame = function() {
                this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
                if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) this.currentFrame = this.timeCompleted;
                this.trigger("enterFrame");
                this.renderFrame();
                this.trigger("drawnFrame");
            };
            AnimationItem.prototype.renderFrame = function() {
                if (this.isLoaded === false || !this.renderer) return;
                try {
                    if (this.expressionsPlugin) this.expressionsPlugin.resetFrame();
                    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
                } catch (error) {
                    this.triggerRenderFrameError(error);
                }
            };
            AnimationItem.prototype.play = function(name) {
                if (name && this.name !== name) return;
                if (this.isPaused === true) {
                    this.isPaused = false;
                    this.trigger("_play");
                    this.audioController.resume();
                    if (this._idle) {
                        this._idle = false;
                        this.trigger("_active");
                    }
                }
            };
            AnimationItem.prototype.pause = function(name) {
                if (name && this.name !== name) return;
                if (this.isPaused === false) {
                    this.isPaused = true;
                    this.trigger("_pause");
                    this._idle = true;
                    this.trigger("_idle");
                    this.audioController.pause();
                }
            };
            AnimationItem.prototype.togglePause = function(name) {
                if (name && this.name !== name) return;
                if (this.isPaused === true) this.play(); else this.pause();
            };
            AnimationItem.prototype.stop = function(name) {
                if (name && this.name !== name) return;
                this.pause();
                this.playCount = 0;
                this._completedLoop = false;
                this.setCurrentRawFrameValue(0);
            };
            AnimationItem.prototype.getMarkerData = function(markerName) {
                var marker;
                for (var i = 0; i < this.markers.length; i += 1) {
                    marker = this.markers[i];
                    if (marker.payload && marker.payload.name === markerName) return marker;
                }
                return null;
            };
            AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {
                if (name && this.name !== name) return;
                var numValue = Number(value);
                if (isNaN(numValue)) {
                    var marker = this.getMarkerData(value);
                    if (marker) this.goToAndStop(marker.time, true);
                } else if (isFrame) this.setCurrentRawFrameValue(value); else this.setCurrentRawFrameValue(value * this.frameModifier);
                this.pause();
            };
            AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {
                if (name && this.name !== name) return;
                var numValue = Number(value);
                if (isNaN(numValue)) {
                    var marker = this.getMarkerData(value);
                    if (marker) if (!marker.duration) this.goToAndStop(marker.time, true); else this.playSegments([ marker.time, marker.time + marker.duration ], true);
                } else this.goToAndStop(numValue, isFrame, name);
                this.play();
            };
            AnimationItem.prototype.advanceTime = function(value) {
                if (this.isPaused === true || this.isLoaded === false) return;
                var nextValue = this.currentRawFrame + value * this.frameModifier;
                var _isComplete = false;
                if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) if (!this.loop || this.playCount === this.loop) {
                    if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                        _isComplete = true;
                        nextValue = this.totalFrames - 1;
                    }
                } else if (nextValue >= this.totalFrames) {
                    this.playCount += 1;
                    if (!this.checkSegments(nextValue % this.totalFrames)) {
                        this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                        this._completedLoop = true;
                        this.trigger("loopComplete");
                    }
                } else this.setCurrentRawFrameValue(nextValue); else if (nextValue < 0) {
                    if (!this.checkSegments(nextValue % this.totalFrames)) if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                        this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                        if (!this._completedLoop) this._completedLoop = true; else this.trigger("loopComplete");
                    } else {
                        _isComplete = true;
                        nextValue = 0;
                    }
                } else this.setCurrentRawFrameValue(nextValue);
                if (_isComplete) {
                    this.setCurrentRawFrameValue(nextValue);
                    this.pause();
                    this.trigger("complete");
                }
            };
            AnimationItem.prototype.adjustSegment = function(arr, offset) {
                this.playCount = 0;
                if (arr[1] < arr[0]) {
                    if (this.frameModifier > 0) if (this.playSpeed < 0) this.setSpeed(-this.playSpeed); else this.setDirection(-1);
                    this.totalFrames = arr[0] - arr[1];
                    this.timeCompleted = this.totalFrames;
                    this.firstFrame = arr[1];
                    this.setCurrentRawFrameValue(this.totalFrames - .001 - offset);
                } else if (arr[1] > arr[0]) {
                    if (this.frameModifier < 0) if (this.playSpeed < 0) this.setSpeed(-this.playSpeed); else this.setDirection(1);
                    this.totalFrames = arr[1] - arr[0];
                    this.timeCompleted = this.totalFrames;
                    this.firstFrame = arr[0];
                    this.setCurrentRawFrameValue(.001 + offset);
                }
                this.trigger("segmentStart");
            };
            AnimationItem.prototype.setSegment = function(init, end) {
                var pendingFrame = -1;
                if (this.isPaused) if (this.currentRawFrame + this.firstFrame < init) pendingFrame = init; else if (this.currentRawFrame + this.firstFrame > end) pendingFrame = end - init;
                this.firstFrame = init;
                this.totalFrames = end - init;
                this.timeCompleted = this.totalFrames;
                if (pendingFrame !== -1) this.goToAndStop(pendingFrame, true);
            };
            AnimationItem.prototype.playSegments = function(arr, forceFlag) {
                if (forceFlag) this.segments.length = 0;
                if (typeof arr[0] === "object") {
                    var i;
                    var len = arr.length;
                    for (i = 0; i < len; i += 1) this.segments.push(arr[i]);
                } else this.segments.push(arr);
                if (this.segments.length && forceFlag) this.adjustSegment(this.segments.shift(), 0);
                if (this.isPaused) this.play();
            };
            AnimationItem.prototype.resetSegments = function(forceFlag) {
                this.segments.length = 0;
                this.segments.push([ this.animationData.ip, this.animationData.op ]);
                if (forceFlag) this.checkSegments(0);
            };
            AnimationItem.prototype.checkSegments = function(offset) {
                if (this.segments.length) {
                    this.adjustSegment(this.segments.shift(), offset);
                    return true;
                }
                return false;
            };
            AnimationItem.prototype.destroy = function(name) {
                if (name && this.name !== name || !this.renderer) return;
                this.renderer.destroy();
                this.imagePreloader.destroy();
                this.trigger("destroy");
                this._cbs = null;
                this.onEnterFrame = null;
                this.onLoopComplete = null;
                this.onComplete = null;
                this.onSegmentStart = null;
                this.onDestroy = null;
                this.renderer = null;
                this.expressionsPlugin = null;
                this.imagePreloader = null;
                this.projectInterface = null;
            };
            AnimationItem.prototype.setCurrentRawFrameValue = function(value) {
                this.currentRawFrame = value;
                this.gotoFrame();
            };
            AnimationItem.prototype.setSpeed = function(val) {
                this.playSpeed = val;
                this.updaFrameModifier();
            };
            AnimationItem.prototype.setDirection = function(val) {
                this.playDirection = val < 0 ? -1 : 1;
                this.updaFrameModifier();
            };
            AnimationItem.prototype.setLoop = function(isLooping) {
                this.loop = isLooping;
            };
            AnimationItem.prototype.setVolume = function(val, name) {
                if (name && this.name !== name) return;
                this.audioController.setVolume(val);
            };
            AnimationItem.prototype.getVolume = function() {
                return this.audioController.getVolume();
            };
            AnimationItem.prototype.mute = function(name) {
                if (name && this.name !== name) return;
                this.audioController.mute();
            };
            AnimationItem.prototype.unmute = function(name) {
                if (name && this.name !== name) return;
                this.audioController.unmute();
            };
            AnimationItem.prototype.updaFrameModifier = function() {
                this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
                this.audioController.setRate(this.playSpeed * this.playDirection);
            };
            AnimationItem.prototype.getPath = function() {
                return this.path;
            };
            AnimationItem.prototype.getAssetsPath = function(assetData) {
                var path = "";
                if (assetData.e) path = assetData.p; else if (this.assetsPath) {
                    var imagePath = assetData.p;
                    if (imagePath.indexOf("images/") !== -1) imagePath = imagePath.split("/")[1];
                    path = this.assetsPath + imagePath;
                } else {
                    path = this.path;
                    path += assetData.u ? assetData.u : "";
                    path += assetData.p;
                }
                return path;
            };
            AnimationItem.prototype.getAssetData = function(id) {
                var i = 0;
                var len = this.assets.length;
                while (i < len) {
                    if (id === this.assets[i].id) return this.assets[i];
                    i += 1;
                }
                return null;
            };
            AnimationItem.prototype.hide = function() {
                this.renderer.hide();
            };
            AnimationItem.prototype.show = function() {
                this.renderer.show();
            };
            AnimationItem.prototype.getDuration = function(isFrame) {
                return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
            };
            AnimationItem.prototype.updateDocumentData = function(path, documentData, index) {
                try {
                    var element = this.renderer.getElementByPath(path);
                    element.updateDocumentData(documentData, index);
                } catch (error) {}
            };
            AnimationItem.prototype.trigger = function(name) {
                if (this._cbs && this._cbs[name]) switch (name) {
                  case "enterFrame":
                    this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
                    break;

                  case "drawnFrame":
                    this.drawnFrameEvent.currentTime = this.currentFrame;
                    this.drawnFrameEvent.totalTime = this.totalFrames;
                    this.drawnFrameEvent.direction = this.frameModifier;
                    this.triggerEvent(name, this.drawnFrameEvent);
                    break;

                  case "loopComplete":
                    this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                    break;

                  case "complete":
                    this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
                    break;

                  case "segmentStart":
                    this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                    break;

                  case "destroy":
                    this.triggerEvent(name, new BMDestroyEvent(name, this));
                    break;

                  default:
                    this.triggerEvent(name);
                }
                if (name === "enterFrame" && this.onEnterFrame) this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
                if (name === "loopComplete" && this.onLoopComplete) this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                if (name === "complete" && this.onComplete) this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
                if (name === "segmentStart" && this.onSegmentStart) this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                if (name === "destroy" && this.onDestroy) this.onDestroy.call(this, new BMDestroyEvent(name, this));
            };
            AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
                var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
                this.triggerEvent("error", error);
                if (this.onError) this.onError.call(this, error);
            };
            AnimationItem.prototype.triggerConfigError = function(nativeError) {
                var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
                this.triggerEvent("error", error);
                if (this.onError) this.onError.call(this, error);
            };
            const animationManager = function() {
                var moduleOb = {};
                var registeredAnimations = [];
                var initTime = 0;
                var len = 0;
                var playingAnimationsNum = 0;
                var _stopped = true;
                var _isFrozen = false;
                function removeElement(ev) {
                    var i = 0;
                    var animItem = ev.target;
                    while (i < len) {
                        if (registeredAnimations[i].animation === animItem) {
                            registeredAnimations.splice(i, 1);
                            i -= 1;
                            len -= 1;
                            if (!animItem.isPaused) subtractPlayingCount();
                        }
                        i += 1;
                    }
                }
                function registerAnimation(element, animationData) {
                    if (!element) return null;
                    var i = 0;
                    while (i < len) {
                        if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) return registeredAnimations[i].animation;
                        i += 1;
                    }
                    var animItem = new AnimationItem;
                    setupAnimation(animItem, element);
                    animItem.setData(element, animationData);
                    return animItem;
                }
                function getRegisteredAnimations() {
                    var i;
                    var lenAnims = registeredAnimations.length;
                    var animations = [];
                    for (i = 0; i < lenAnims; i += 1) animations.push(registeredAnimations[i].animation);
                    return animations;
                }
                function addPlayingCount() {
                    playingAnimationsNum += 1;
                    activate();
                }
                function subtractPlayingCount() {
                    playingAnimationsNum -= 1;
                }
                function setupAnimation(animItem, element) {
                    animItem.addEventListener("destroy", removeElement);
                    animItem.addEventListener("_active", addPlayingCount);
                    animItem.addEventListener("_idle", subtractPlayingCount);
                    registeredAnimations.push({
                        elem: element,
                        animation: animItem
                    });
                    len += 1;
                }
                function loadAnimation(params) {
                    var animItem = new AnimationItem;
                    setupAnimation(animItem, null);
                    animItem.setParams(params);
                    return animItem;
                }
                function setSpeed(val, animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.setSpeed(val, animation);
                }
                function setDirection(val, animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.setDirection(val, animation);
                }
                function play(animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.play(animation);
                }
                function resume(nowTime) {
                    var elapsedTime = nowTime - initTime;
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.advanceTime(elapsedTime);
                    initTime = nowTime;
                    if (playingAnimationsNum && !_isFrozen) window.requestAnimationFrame(resume); else _stopped = true;
                }
                function first(nowTime) {
                    initTime = nowTime;
                    window.requestAnimationFrame(resume);
                }
                function pause(animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.pause(animation);
                }
                function goToAndStop(value, isFrame, animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
                }
                function stop(animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.stop(animation);
                }
                function togglePause(animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.togglePause(animation);
                }
                function destroy(animation) {
                    var i;
                    for (i = len - 1; i >= 0; i -= 1) registeredAnimations[i].animation.destroy(animation);
                }
                function searchAnimations(animationData, standalone, renderer) {
                    var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
                    var i;
                    var lenAnims = animElements.length;
                    for (i = 0; i < lenAnims; i += 1) {
                        if (renderer) animElements[i].setAttribute("data-bm-type", renderer);
                        registerAnimation(animElements[i], animationData);
                    }
                    if (standalone && lenAnims === 0) {
                        if (!renderer) renderer = "svg";
                        var body = document.getElementsByTagName("body")[0];
                        body.innerText = "";
                        var div = createTag("div");
                        div.style.width = "100%";
                        div.style.height = "100%";
                        div.setAttribute("data-bm-type", renderer);
                        body.appendChild(div);
                        registerAnimation(div, animationData);
                    }
                }
                function resize() {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.resize();
                }
                function activate() {
                    if (!_isFrozen && playingAnimationsNum) if (_stopped) {
                        window.requestAnimationFrame(first);
                        _stopped = false;
                    }
                }
                function freeze() {
                    _isFrozen = true;
                }
                function unfreeze() {
                    _isFrozen = false;
                    activate();
                }
                function setVolume(val, animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.setVolume(val, animation);
                }
                function mute(animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.mute(animation);
                }
                function unmute(animation) {
                    var i;
                    for (i = 0; i < len; i += 1) registeredAnimations[i].animation.unmute(animation);
                }
                moduleOb.registerAnimation = registerAnimation;
                moduleOb.loadAnimation = loadAnimation;
                moduleOb.setSpeed = setSpeed;
                moduleOb.setDirection = setDirection;
                moduleOb.play = play;
                moduleOb.pause = pause;
                moduleOb.stop = stop;
                moduleOb.togglePause = togglePause;
                moduleOb.searchAnimations = searchAnimations;
                moduleOb.resize = resize;
                moduleOb.goToAndStop = goToAndStop;
                moduleOb.destroy = destroy;
                moduleOb.freeze = freeze;
                moduleOb.unfreeze = unfreeze;
                moduleOb.setVolume = setVolume;
                moduleOb.mute = mute;
                moduleOb.unmute = unmute;
                moduleOb.getRegisteredAnimations = getRegisteredAnimations;
                return moduleOb;
            }();
            const BezierFactory = function() {
                var ob = {};
                ob.getBezierEasing = getBezierEasing;
                var beziers = {};
                function getBezierEasing(a, b, c, d, nm) {
                    var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
                    if (beziers[str]) return beziers[str];
                    var bezEasing = new BezierEasing([ a, b, c, d ]);
                    beziers[str] = bezEasing;
                    return bezEasing;
                }
                var NEWTON_ITERATIONS = 4;
                var NEWTON_MIN_SLOPE = .001;
                var SUBDIVISION_PRECISION = 1e-7;
                var SUBDIVISION_MAX_ITERATIONS = 10;
                var kSplineTableSize = 11;
                var kSampleStepSize = 1 / (kSplineTableSize - 1);
                var float32ArraySupported = typeof Float32Array === "function";
                function A(aA1, aA2) {
                    return 1 - 3 * aA2 + 3 * aA1;
                }
                function B(aA1, aA2) {
                    return 3 * aA2 - 6 * aA1;
                }
                function C(aA1) {
                    return 3 * aA1;
                }
                function calcBezier(aT, aA1, aA2) {
                    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
                }
                function getSlope(aT, aA1, aA2) {
                    return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
                }
                function binarySubdivide(aX, aA, aB, mX1, mX2) {
                    var currentX, currentT, i = 0;
                    do {
                        currentT = aA + (aB - aA) / 2;
                        currentX = calcBezier(currentT, mX1, mX2) - aX;
                        if (currentX > 0) aB = currentT; else aA = currentT;
                    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
                    return currentT;
                }
                function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
                    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                        var currentSlope = getSlope(aGuessT, mX1, mX2);
                        if (currentSlope === 0) return aGuessT;
                        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                        aGuessT -= currentX / currentSlope;
                    }
                    return aGuessT;
                }
                function BezierEasing(points) {
                    this._p = points;
                    this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
                    this._precomputed = false;
                    this.get = this.get.bind(this);
                }
                BezierEasing.prototype = {
                    get: function(x) {
                        var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
                        if (!this._precomputed) this._precompute();
                        if (mX1 === mY1 && mX2 === mY2) return x;
                        if (x === 0) return 0;
                        if (x === 1) return 1;
                        return calcBezier(this._getTForX(x), mY1, mY2);
                    },
                    _precompute: function() {
                        var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
                        this._precomputed = true;
                        if (mX1 !== mY1 || mX2 !== mY2) this._calcSampleValues();
                    },
                    _calcSampleValues: function() {
                        var mX1 = this._p[0], mX2 = this._p[2];
                        for (var i = 0; i < kSplineTableSize; ++i) this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                    },
                    _getTForX: function(aX) {
                        var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
                        var intervalStart = 0;
                        var currentSample = 1;
                        var lastSample = kSplineTableSize - 1;
                        for (;currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
                        --currentSample;
                        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
                        var guessForT = intervalStart + dist * kSampleStepSize;
                        var initialSlope = getSlope(guessForT, mX1, mX2);
                        if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                        if (initialSlope === 0) return guessForT;
                        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
                    }
                };
                return ob;
            }();
            const pooling = function() {
                function double(arr) {
                    return arr.concat(createSizedArray(arr.length));
                }
                return {
                    double
                };
            }();
            const poolFactory = function() {
                return function(initialLength, _create, _release) {
                    var _length = 0;
                    var _maxLength = initialLength;
                    var pool = createSizedArray(_maxLength);
                    var ob = {
                        newElement,
                        release
                    };
                    function newElement() {
                        var element;
                        if (_length) {
                            _length -= 1;
                            element = pool[_length];
                        } else element = _create();
                        return element;
                    }
                    function release(element) {
                        if (_length === _maxLength) {
                            pool = pooling.double(pool);
                            _maxLength *= 2;
                        }
                        if (_release) _release(element);
                        pool[_length] = element;
                        _length += 1;
                    }
                    return ob;
                };
            }();
            const bezierLengthPool = function() {
                function create() {
                    return {
                        addedLength: 0,
                        percents: createTypedArray("float32", getDefaultCurveSegments()),
                        lengths: createTypedArray("float32", getDefaultCurveSegments())
                    };
                }
                return poolFactory(8, create);
            }();
            const segmentsLengthPool = function() {
                function create() {
                    return {
                        lengths: [],
                        totalLength: 0
                    };
                }
                function release(element) {
                    var i;
                    var len = element.lengths.length;
                    for (i = 0; i < len; i += 1) bezierLengthPool.release(element.lengths[i]);
                    element.lengths.length = 0;
                }
                return poolFactory(8, create, release);
            }();
            function bezFunction() {
                var math = Math;
                function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
                    var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
                    return det1 > -.001 && det1 < .001;
                }
                function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
                    if (z1 === 0 && z2 === 0 && z3 === 0) return pointOnLine2D(x1, y1, x2, y2, x3, y3);
                    var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
                    var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
                    var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
                    var diffDist;
                    if (dist1 > dist2) if (dist1 > dist3) diffDist = dist1 - dist2 - dist3; else diffDist = dist3 - dist2 - dist1; else if (dist3 > dist2) diffDist = dist3 - dist2 - dist1; else diffDist = dist2 - dist1 - dist3;
                    return diffDist > -1e-4 && diffDist < 1e-4;
                }
                var getBezierLength = function() {
                    return function(pt1, pt2, pt3, pt4) {
                        var curveSegments = getDefaultCurveSegments();
                        var k;
                        var i;
                        var len;
                        var ptCoord;
                        var perc;
                        var addedLength = 0;
                        var ptDistance;
                        var point = [];
                        var lastPoint = [];
                        var lengthData = bezierLengthPool.newElement();
                        len = pt3.length;
                        for (k = 0; k < curveSegments; k += 1) {
                            perc = k / (curveSegments - 1);
                            ptDistance = 0;
                            for (i = 0; i < len; i += 1) {
                                ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
                                point[i] = ptCoord;
                                if (lastPoint[i] !== null) ptDistance += bmPow(point[i] - lastPoint[i], 2);
                                lastPoint[i] = point[i];
                            }
                            if (ptDistance) {
                                ptDistance = bmSqrt(ptDistance);
                                addedLength += ptDistance;
                            }
                            lengthData.percents[k] = perc;
                            lengthData.lengths[k] = addedLength;
                        }
                        lengthData.addedLength = addedLength;
                        return lengthData;
                    };
                }();
                function getSegmentsLength(shapeData) {
                    var segmentsLength = segmentsLengthPool.newElement();
                    var closed = shapeData.c;
                    var pathV = shapeData.v;
                    var pathO = shapeData.o;
                    var pathI = shapeData.i;
                    var i;
                    var len = shapeData._length;
                    var lengths = segmentsLength.lengths;
                    var totalLength = 0;
                    for (i = 0; i < len - 1; i += 1) {
                        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
                        totalLength += lengths[i].addedLength;
                    }
                    if (closed && len) {
                        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
                        totalLength += lengths[i].addedLength;
                    }
                    segmentsLength.totalLength = totalLength;
                    return segmentsLength;
                }
                function BezierData(length) {
                    this.segmentLength = 0;
                    this.points = new Array(length);
                }
                function PointData(partial, point) {
                    this.partialLength = partial;
                    this.point = point;
                }
                var buildBezierData = function() {
                    var storedData = {};
                    return function(pt1, pt2, pt3, pt4) {
                        var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
                        if (!storedData[bezierName]) {
                            var curveSegments = getDefaultCurveSegments();
                            var k;
                            var i;
                            var len;
                            var ptCoord;
                            var perc;
                            var addedLength = 0;
                            var ptDistance;
                            var point;
                            var lastPoint = null;
                            if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) curveSegments = 2;
                            var bezierData = new BezierData(curveSegments);
                            len = pt3.length;
                            for (k = 0; k < curveSegments; k += 1) {
                                point = createSizedArray(len);
                                perc = k / (curveSegments - 1);
                                ptDistance = 0;
                                for (i = 0; i < len; i += 1) {
                                    ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                                    point[i] = ptCoord;
                                    if (lastPoint !== null) ptDistance += bmPow(point[i] - lastPoint[i], 2);
                                }
                                ptDistance = bmSqrt(ptDistance);
                                addedLength += ptDistance;
                                bezierData.points[k] = new PointData(ptDistance, point);
                                lastPoint = point;
                            }
                            bezierData.segmentLength = addedLength;
                            storedData[bezierName] = bezierData;
                        }
                        return storedData[bezierName];
                    };
                }();
                function getDistancePerc(perc, bezierData) {
                    var percents = bezierData.percents;
                    var lengths = bezierData.lengths;
                    var len = percents.length;
                    var initPos = bmFloor((len - 1) * perc);
                    var lengthPos = perc * bezierData.addedLength;
                    var lPerc = 0;
                    if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) return percents[initPos];
                    var dir = lengths[initPos] > lengthPos ? -1 : 1;
                    var flag = true;
                    while (flag) {
                        if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                            lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                            flag = false;
                        } else initPos += dir;
                        if (initPos < 0 || initPos >= len - 1) {
                            if (initPos === len - 1) return percents[initPos];
                            flag = false;
                        }
                    }
                    return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
                }
                function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
                    var t1 = getDistancePerc(percent, bezierData);
                    var u1 = 1 - t1;
                    var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
                    var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
                    return [ ptX, ptY ];
                }
                var bezierSegmentPoints = createTypedArray("float32", 8);
                function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
                    if (startPerc < 0) startPerc = 0; else if (startPerc > 1) startPerc = 1;
                    var t0 = getDistancePerc(startPerc, bezierData);
                    endPerc = endPerc > 1 ? 1 : endPerc;
                    var t1 = getDistancePerc(endPerc, bezierData);
                    var i;
                    var len = pt1.length;
                    var u0 = 1 - t0;
                    var u1 = 1 - t1;
                    var u0u0u0 = u0 * u0 * u0;
                    var t0u0u0_3 = t0 * u0 * u0 * 3;
                    var t0t0u0_3 = t0 * t0 * u0 * 3;
                    var t0t0t0 = t0 * t0 * t0;
                    var u0u0u1 = u0 * u0 * u1;
                    var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
                    var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
                    var t0t0t1 = t0 * t0 * t1;
                    var u0u1u1 = u0 * u1 * u1;
                    var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
                    var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
                    var t0t1t1 = t0 * t1 * t1;
                    var u1u1u1 = u1 * u1 * u1;
                    var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
                    var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
                    var t1t1t1 = t1 * t1 * t1;
                    for (i = 0; i < len; i += 1) {
                        bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1e3) / 1e3;
                        bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1e3) / 1e3;
                        bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1e3) / 1e3;
                        bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1e3) / 1e3;
                    }
                    return bezierSegmentPoints;
                }
                return {
                    getSegmentsLength,
                    getNewSegment,
                    getPointInSegment,
                    buildBezierData,
                    pointOnLine2D,
                    pointOnLine3D
                };
            }
            const bez = bezFunction();
            var initFrame = initialDefaultFrame;
            var mathAbs = Math.abs;
            function interpolateValue(frameNum, caching) {
                var offsetTime = this.offsetTime;
                var newValue;
                if (this.propType === "multidimensional") newValue = createTypedArray("float32", this.pv.length);
                var iterationIndex = caching.lastIndex;
                var i = iterationIndex;
                var len = this.keyframes.length - 1;
                var flag = true;
                var keyData;
                var nextKeyData;
                var keyframeMetadata;
                while (flag) {
                    keyData = this.keyframes[i];
                    nextKeyData = this.keyframes[i + 1];
                    if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                        if (keyData.h) keyData = nextKeyData;
                        iterationIndex = 0;
                        break;
                    }
                    if (nextKeyData.t - offsetTime > frameNum) {
                        iterationIndex = i;
                        break;
                    }
                    if (i < len - 1) i += 1; else {
                        iterationIndex = 0;
                        flag = false;
                    }
                }
                keyframeMetadata = this.keyframesMetadata[i] || {};
                var k;
                var kLen;
                var perc;
                var jLen;
                var j;
                var fnc;
                var nextKeyTime = nextKeyData.t - offsetTime;
                var keyTime = keyData.t - offsetTime;
                var endValue;
                if (keyData.to) {
                    if (!keyframeMetadata.bezierData) keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
                    var bezierData = keyframeMetadata.bezierData;
                    if (frameNum >= nextKeyTime || frameNum < keyTime) {
                        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                        kLen = bezierData.points[ind].point.length;
                        for (k = 0; k < kLen; k += 1) newValue[k] = bezierData.points[ind].point[k];
                    } else {
                        if (keyframeMetadata.__fnct) fnc = keyframeMetadata.__fnct; else {
                            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                            keyframeMetadata.__fnct = fnc;
                        }
                        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                        var distanceInLine = bezierData.segmentLength * perc;
                        var segmentPerc;
                        var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
                        j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
                        flag = true;
                        jLen = bezierData.points.length;
                        while (flag) {
                            addedLength += bezierData.points[j].partialLength;
                            if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                                kLen = bezierData.points[j].point.length;
                                for (k = 0; k < kLen; k += 1) newValue[k] = bezierData.points[j].point[k];
                                break;
                            } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                                segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                                kLen = bezierData.points[j].point.length;
                                for (k = 0; k < kLen; k += 1) newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                                break;
                            }
                            if (j < jLen - 1) j += 1; else flag = false;
                        }
                        caching._lastPoint = j;
                        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
                        caching._lastKeyframeIndex = i;
                    }
                } else {
                    var outX;
                    var outY;
                    var inX;
                    var inY;
                    var keyValue;
                    len = keyData.s.length;
                    endValue = nextKeyData.s || keyData.e;
                    if (this.sh && keyData.h !== 1) if (frameNum >= nextKeyTime) {
                        newValue[0] = endValue[0];
                        newValue[1] = endValue[1];
                        newValue[2] = endValue[2];
                    } else if (frameNum <= keyTime) {
                        newValue[0] = keyData.s[0];
                        newValue[1] = keyData.s[1];
                        newValue[2] = keyData.s[2];
                    } else {
                        var quatStart = createQuaternion(keyData.s);
                        var quatEnd = createQuaternion(endValue);
                        var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                        quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
                    } else for (i = 0; i < len; i += 1) {
                        if (keyData.h !== 1) if (frameNum >= nextKeyTime) perc = 1; else if (frameNum < keyTime) perc = 0; else {
                            if (keyData.o.x.constructor === Array) {
                                if (!keyframeMetadata.__fnct) keyframeMetadata.__fnct = [];
                                if (!keyframeMetadata.__fnct[i]) {
                                    outX = keyData.o.x[i] === void 0 ? keyData.o.x[0] : keyData.o.x[i];
                                    outY = keyData.o.y[i] === void 0 ? keyData.o.y[0] : keyData.o.y[i];
                                    inX = keyData.i.x[i] === void 0 ? keyData.i.x[0] : keyData.i.x[i];
                                    inY = keyData.i.y[i] === void 0 ? keyData.i.y[0] : keyData.i.y[i];
                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                                    keyframeMetadata.__fnct[i] = fnc;
                                } else fnc = keyframeMetadata.__fnct[i];
                            } else if (!keyframeMetadata.__fnct) {
                                outX = keyData.o.x;
                                outY = keyData.o.y;
                                inX = keyData.i.x;
                                inY = keyData.i.y;
                                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                                keyData.keyframeMetadata = fnc;
                            } else fnc = keyframeMetadata.__fnct;
                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                        }
                        endValue = nextKeyData.s || keyData.e;
                        keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
                        if (this.propType === "multidimensional") newValue[i] = keyValue; else newValue = keyValue;
                    }
                }
                caching.lastIndex = iterationIndex;
                return newValue;
            }
            function slerp(a, b, t) {
                var out = [];
                var ax = a[0];
                var ay = a[1];
                var az = a[2];
                var aw = a[3];
                var bx = b[0];
                var by = b[1];
                var bz = b[2];
                var bw = b[3];
                var omega;
                var cosom;
                var sinom;
                var scale0;
                var scale1;
                cosom = ax * bx + ay * by + az * bz + aw * bw;
                if (cosom < 0) {
                    cosom = -cosom;
                    bx = -bx;
                    by = -by;
                    bz = -bz;
                    bw = -bw;
                }
                if (1 - cosom > 1e-6) {
                    omega = Math.acos(cosom);
                    sinom = Math.sin(omega);
                    scale0 = Math.sin((1 - t) * omega) / sinom;
                    scale1 = Math.sin(t * omega) / sinom;
                } else {
                    scale0 = 1 - t;
                    scale1 = t;
                }
                out[0] = scale0 * ax + scale1 * bx;
                out[1] = scale0 * ay + scale1 * by;
                out[2] = scale0 * az + scale1 * bz;
                out[3] = scale0 * aw + scale1 * bw;
                return out;
            }
            function quaternionToEuler(out, quat) {
                var qx = quat[0];
                var qy = quat[1];
                var qz = quat[2];
                var qw = quat[3];
                var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
                var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
                var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
                out[0] = heading / degToRads;
                out[1] = attitude / degToRads;
                out[2] = bank / degToRads;
            }
            function createQuaternion(values) {
                var heading = values[0] * degToRads;
                var attitude = values[1] * degToRads;
                var bank = values[2] * degToRads;
                var c1 = Math.cos(heading / 2);
                var c2 = Math.cos(attitude / 2);
                var c3 = Math.cos(bank / 2);
                var s1 = Math.sin(heading / 2);
                var s2 = Math.sin(attitude / 2);
                var s3 = Math.sin(bank / 2);
                var w = c1 * c2 * c3 - s1 * s2 * s3;
                var x = s1 * s2 * c3 + c1 * c2 * s3;
                var y = s1 * c2 * c3 + c1 * s2 * s3;
                var z = c1 * s2 * c3 - s1 * c2 * s3;
                return [ x, y, z, w ];
            }
            function getValueAtCurrentTime() {
                var frameNum = this.comp.renderedFrame - this.offsetTime;
                var initTime = this.keyframes[0].t - this.offsetTime;
                var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
                    if (this._caching.lastFrame >= frameNum) {
                        this._caching._lastKeyframeIndex = -1;
                        this._caching.lastIndex = 0;
                    }
                    var renderResult = this.interpolateValue(frameNum, this._caching);
                    this.pv = renderResult;
                }
                this._caching.lastFrame = frameNum;
                return this.pv;
            }
            function setVValue(val) {
                var multipliedValue;
                if (this.propType === "unidimensional") {
                    multipliedValue = val * this.mult;
                    if (mathAbs(this.v - multipliedValue) > 1e-5) {
                        this.v = multipliedValue;
                        this._mdf = true;
                    }
                } else {
                    var i = 0;
                    var len = this.v.length;
                    while (i < len) {
                        multipliedValue = val[i] * this.mult;
                        if (mathAbs(this.v[i] - multipliedValue) > 1e-5) {
                            this.v[i] = multipliedValue;
                            this._mdf = true;
                        }
                        i += 1;
                    }
                }
            }
            function processEffectsSequence() {
                if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) return;
                if (this.lock) {
                    this.setVValue(this.pv);
                    return;
                }
                this.lock = true;
                this._mdf = this._isFirstFrame;
                var i;
                var len = this.effectsSequence.length;
                var finalValue = this.kf ? this.pv : this.data.k;
                for (i = 0; i < len; i += 1) finalValue = this.effectsSequence[i](finalValue);
                this.setVValue(finalValue);
                this._isFirstFrame = false;
                this.lock = false;
                this.frameId = this.elem.globalData.frameId;
            }
            function addEffect(effectFunction) {
                this.effectsSequence.push(effectFunction);
                this.container.addDynamicProperty(this);
            }
            function ValueProperty(elem, data, mult, container) {
                this.propType = "unidimensional";
                this.mult = mult || 1;
                this.data = data;
                this.v = mult ? data.k * mult : data.k;
                this.pv = data.k;
                this._mdf = false;
                this.elem = elem;
                this.container = container;
                this.comp = elem.comp;
                this.k = false;
                this.kf = false;
                this.vel = 0;
                this.effectsSequence = [];
                this._isFirstFrame = true;
                this.getValue = processEffectsSequence;
                this.setVValue = setVValue;
                this.addEffect = addEffect;
            }
            function MultiDimensionalProperty(elem, data, mult, container) {
                this.propType = "multidimensional";
                this.mult = mult || 1;
                this.data = data;
                this._mdf = false;
                this.elem = elem;
                this.container = container;
                this.comp = elem.comp;
                this.k = false;
                this.kf = false;
                this.frameId = -1;
                var i;
                var len = data.k.length;
                this.v = createTypedArray("float32", len);
                this.pv = createTypedArray("float32", len);
                this.vel = createTypedArray("float32", len);
                for (i = 0; i < len; i += 1) {
                    this.v[i] = data.k[i] * this.mult;
                    this.pv[i] = data.k[i];
                }
                this._isFirstFrame = true;
                this.effectsSequence = [];
                this.getValue = processEffectsSequence;
                this.setVValue = setVValue;
                this.addEffect = addEffect;
            }
            function KeyframedValueProperty(elem, data, mult, container) {
                this.propType = "unidimensional";
                this.keyframes = data.k;
                this.keyframesMetadata = [];
                this.offsetTime = elem.data.st;
                this.frameId = -1;
                this._caching = {
                    lastFrame: initFrame,
                    lastIndex: 0,
                    value: 0,
                    _lastKeyframeIndex: -1
                };
                this.k = true;
                this.kf = true;
                this.data = data;
                this.mult = mult || 1;
                this.elem = elem;
                this.container = container;
                this.comp = elem.comp;
                this.v = initFrame;
                this.pv = initFrame;
                this._isFirstFrame = true;
                this.getValue = processEffectsSequence;
                this.setVValue = setVValue;
                this.interpolateValue = interpolateValue;
                this.effectsSequence = [ getValueAtCurrentTime.bind(this) ];
                this.addEffect = addEffect;
            }
            function KeyframedMultidimensionalProperty(elem, data, mult, container) {
                this.propType = "multidimensional";
                var i;
                var len = data.k.length;
                var s;
                var e;
                var to;
                var ti;
                for (i = 0; i < len - 1; i += 1) if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
                    s = data.k[i].s;
                    e = data.k[i + 1].s;
                    to = data.k[i].to;
                    ti = data.k[i].ti;
                    if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
                        data.k[i].to = null;
                        data.k[i].ti = null;
                    }
                    if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
                        data.k[i].to = null;
                        data.k[i].ti = null;
                    }
                }
                this.effectsSequence = [ getValueAtCurrentTime.bind(this) ];
                this.data = data;
                this.keyframes = data.k;
                this.keyframesMetadata = [];
                this.offsetTime = elem.data.st;
                this.k = true;
                this.kf = true;
                this._isFirstFrame = true;
                this.mult = mult || 1;
                this.elem = elem;
                this.container = container;
                this.comp = elem.comp;
                this.getValue = processEffectsSequence;
                this.setVValue = setVValue;
                this.interpolateValue = interpolateValue;
                this.frameId = -1;
                var arrLen = data.k[0].s.length;
                this.v = createTypedArray("float32", arrLen);
                this.pv = createTypedArray("float32", arrLen);
                for (i = 0; i < arrLen; i += 1) {
                    this.v[i] = initFrame;
                    this.pv[i] = initFrame;
                }
                this._caching = {
                    lastFrame: initFrame,
                    lastIndex: 0,
                    value: createTypedArray("float32", arrLen)
                };
                this.addEffect = addEffect;
            }
            const PropertyFactory = function() {
                function getProp(elem, data, type, mult, container) {
                    if (data.sid) data = elem.globalData.slotManager.getProp(data);
                    var p;
                    if (!data.k.length) p = new ValueProperty(elem, data, mult, container); else if (typeof data.k[0] === "number") p = new MultiDimensionalProperty(elem, data, mult, container); else switch (type) {
                      case 0:
                        p = new KeyframedValueProperty(elem, data, mult, container);
                        break;

                      case 1:
                        p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
                        break;

                      default:
                        break;
                    }
                    if (p.effectsSequence.length) container.addDynamicProperty(p);
                    return p;
                }
                var ob = {
                    getProp
                };
                return ob;
            }();
            function DynamicPropertyContainer() {}
            DynamicPropertyContainer.prototype = {
                addDynamicProperty: function(prop) {
                    if (this.dynamicProperties.indexOf(prop) === -1) {
                        this.dynamicProperties.push(prop);
                        this.container.addDynamicProperty(this);
                        this._isAnimated = true;
                    }
                },
                iterateDynamicProperties: function() {
                    this._mdf = false;
                    var i;
                    var len = this.dynamicProperties.length;
                    for (i = 0; i < len; i += 1) {
                        this.dynamicProperties[i].getValue();
                        if (this.dynamicProperties[i]._mdf) this._mdf = true;
                    }
                },
                initDynamicPropertyContainer: function(container) {
                    this.container = container;
                    this.dynamicProperties = [];
                    this._mdf = false;
                    this._isAnimated = false;
                }
            };
            const pointPool = function() {
                function create() {
                    return createTypedArray("float32", 2);
                }
                return poolFactory(8, create);
            }();
            function ShapePath() {
                this.c = false;
                this._length = 0;
                this._maxLength = 8;
                this.v = createSizedArray(this._maxLength);
                this.o = createSizedArray(this._maxLength);
                this.i = createSizedArray(this._maxLength);
            }
            ShapePath.prototype.setPathData = function(closed, len) {
                this.c = closed;
                this.setLength(len);
                var i = 0;
                while (i < len) {
                    this.v[i] = pointPool.newElement();
                    this.o[i] = pointPool.newElement();
                    this.i[i] = pointPool.newElement();
                    i += 1;
                }
            };
            ShapePath.prototype.setLength = function(len) {
                while (this._maxLength < len) this.doubleArrayLength();
                this._length = len;
            };
            ShapePath.prototype.doubleArrayLength = function() {
                this.v = this.v.concat(createSizedArray(this._maxLength));
                this.i = this.i.concat(createSizedArray(this._maxLength));
                this.o = this.o.concat(createSizedArray(this._maxLength));
                this._maxLength *= 2;
            };
            ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
                var arr;
                this._length = Math.max(this._length, pos + 1);
                if (this._length >= this._maxLength) this.doubleArrayLength();
                switch (type) {
                  case "v":
                    arr = this.v;
                    break;

                  case "i":
                    arr = this.i;
                    break;

                  case "o":
                    arr = this.o;
                    break;

                  default:
                    arr = [];
                    break;
                }
                if (!arr[pos] || arr[pos] && !replace) arr[pos] = pointPool.newElement();
                arr[pos][0] = x;
                arr[pos][1] = y;
            };
            ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
                this.setXYAt(vX, vY, "v", pos, replace);
                this.setXYAt(oX, oY, "o", pos, replace);
                this.setXYAt(iX, iY, "i", pos, replace);
            };
            ShapePath.prototype.reverse = function() {
                var newPath = new ShapePath;
                newPath.setPathData(this.c, this._length);
                var vertices = this.v;
                var outPoints = this.o;
                var inPoints = this.i;
                var init = 0;
                if (this.c) {
                    newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
                    init = 1;
                }
                var cnt = this._length - 1;
                var len = this._length;
                var i;
                for (i = init; i < len; i += 1) {
                    newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
                    cnt -= 1;
                }
                return newPath;
            };
            ShapePath.prototype.length = function() {
                return this._length;
            };
            const shapePool = function() {
                function create() {
                    return new ShapePath;
                }
                function release(shapePath) {
                    var len = shapePath._length;
                    var i;
                    for (i = 0; i < len; i += 1) {
                        pointPool.release(shapePath.v[i]);
                        pointPool.release(shapePath.i[i]);
                        pointPool.release(shapePath.o[i]);
                        shapePath.v[i] = null;
                        shapePath.i[i] = null;
                        shapePath.o[i] = null;
                    }
                    shapePath._length = 0;
                    shapePath.c = false;
                }
                function clone(shape) {
                    var cloned = factory.newElement();
                    var i;
                    var len = shape._length === void 0 ? shape.v.length : shape._length;
                    cloned.setLength(len);
                    cloned.c = shape.c;
                    for (i = 0; i < len; i += 1) cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
                    return cloned;
                }
                var factory = poolFactory(4, create, release);
                factory.clone = clone;
                return factory;
            }();
            function ShapeCollection() {
                this._length = 0;
                this._maxLength = 4;
                this.shapes = createSizedArray(this._maxLength);
            }
            ShapeCollection.prototype.addShape = function(shapeData) {
                if (this._length === this._maxLength) {
                    this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
                    this._maxLength *= 2;
                }
                this.shapes[this._length] = shapeData;
                this._length += 1;
            };
            ShapeCollection.prototype.releaseShapes = function() {
                var i;
                for (i = 0; i < this._length; i += 1) shapePool.release(this.shapes[i]);
                this._length = 0;
            };
            const shapeCollectionPool = function() {
                var ob = {
                    newShapeCollection,
                    release
                };
                var _length = 0;
                var _maxLength = 4;
                var pool = createSizedArray(_maxLength);
                function newShapeCollection() {
                    var shapeCollection;
                    if (_length) {
                        _length -= 1;
                        shapeCollection = pool[_length];
                    } else shapeCollection = new ShapeCollection;
                    return shapeCollection;
                }
                function release(shapeCollection) {
                    var i;
                    var len = shapeCollection._length;
                    for (i = 0; i < len; i += 1) shapePool.release(shapeCollection.shapes[i]);
                    shapeCollection._length = 0;
                    if (_length === _maxLength) {
                        pool = pooling.double(pool);
                        _maxLength *= 2;
                    }
                    pool[_length] = shapeCollection;
                    _length += 1;
                }
                return ob;
            }();
            const ShapePropertyFactory = function() {
                var initFrame = -999999;
                function interpolateShape(frameNum, previousValue, caching) {
                    var iterationIndex = caching.lastIndex;
                    var keyPropS;
                    var keyPropE;
                    var isHold;
                    var j;
                    var k;
                    var jLen;
                    var kLen;
                    var perc;
                    var vertexValue;
                    var kf = this.keyframes;
                    if (frameNum < kf[0].t - this.offsetTime) {
                        keyPropS = kf[0].s[0];
                        isHold = true;
                        iterationIndex = 0;
                    } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
                        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
                        isHold = true;
                    } else {
                        var i = iterationIndex;
                        var len = kf.length - 1;
                        var flag = true;
                        var keyData;
                        var nextKeyData;
                        var keyframeMetadata;
                        while (flag) {
                            keyData = kf[i];
                            nextKeyData = kf[i + 1];
                            if (nextKeyData.t - this.offsetTime > frameNum) break;
                            if (i < len - 1) i += 1; else flag = false;
                        }
                        keyframeMetadata = this.keyframesMetadata[i] || {};
                        isHold = keyData.h === 1;
                        iterationIndex = i;
                        if (!isHold) {
                            if (frameNum >= nextKeyData.t - this.offsetTime) perc = 1; else if (frameNum < keyData.t - this.offsetTime) perc = 0; else {
                                var fnc;
                                if (keyframeMetadata.__fnct) fnc = keyframeMetadata.__fnct; else {
                                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                                    keyframeMetadata.__fnct = fnc;
                                }
                                perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                            }
                            keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
                        }
                        keyPropS = keyData.s[0];
                    }
                    jLen = previousValue._length;
                    kLen = keyPropS.i[0].length;
                    caching.lastIndex = iterationIndex;
                    for (j = 0; j < jLen; j += 1) for (k = 0; k < kLen; k += 1) {
                        vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
                        previousValue.i[j][k] = vertexValue;
                        vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
                        previousValue.o[j][k] = vertexValue;
                        vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
                        previousValue.v[j][k] = vertexValue;
                    }
                }
                function interpolateShapeCurrentTime() {
                    var frameNum = this.comp.renderedFrame - this.offsetTime;
                    var initTime = this.keyframes[0].t - this.offsetTime;
                    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                    var lastFrame = this._caching.lastFrame;
                    if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
                        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
                        this.interpolateShape(frameNum, this.pv, this._caching);
                    }
                    this._caching.lastFrame = frameNum;
                    return this.pv;
                }
                function resetShape() {
                    this.paths = this.localShapeCollection;
                }
                function shapesEqual(shape1, shape2) {
                    if (shape1._length !== shape2._length || shape1.c !== shape2.c) return false;
                    var i;
                    var len = shape1._length;
                    for (i = 0; i < len; i += 1) if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) return false;
                    return true;
                }
                function setVValue(newPath) {
                    if (!shapesEqual(this.v, newPath)) {
                        this.v = shapePool.clone(newPath);
                        this.localShapeCollection.releaseShapes();
                        this.localShapeCollection.addShape(this.v);
                        this._mdf = true;
                        this.paths = this.localShapeCollection;
                    }
                }
                function processEffectsSequence() {
                    if (this.elem.globalData.frameId === this.frameId) return;
                    if (!this.effectsSequence.length) {
                        this._mdf = false;
                        return;
                    }
                    if (this.lock) {
                        this.setVValue(this.pv);
                        return;
                    }
                    this.lock = true;
                    this._mdf = false;
                    var finalValue;
                    if (this.kf) finalValue = this.pv; else if (this.data.ks) finalValue = this.data.ks.k; else finalValue = this.data.pt.k;
                    var i;
                    var len = this.effectsSequence.length;
                    for (i = 0; i < len; i += 1) finalValue = this.effectsSequence[i](finalValue);
                    this.setVValue(finalValue);
                    this.lock = false;
                    this.frameId = this.elem.globalData.frameId;
                }
                function ShapeProperty(elem, data, type) {
                    this.propType = "shape";
                    this.comp = elem.comp;
                    this.container = elem;
                    this.elem = elem;
                    this.data = data;
                    this.k = false;
                    this.kf = false;
                    this._mdf = false;
                    var pathData = type === 3 ? data.pt.k : data.ks.k;
                    this.v = shapePool.clone(pathData);
                    this.pv = shapePool.clone(this.v);
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                    this.paths = this.localShapeCollection;
                    this.paths.addShape(this.v);
                    this.reset = resetShape;
                    this.effectsSequence = [];
                }
                function addEffect(effectFunction) {
                    this.effectsSequence.push(effectFunction);
                    this.container.addDynamicProperty(this);
                }
                ShapeProperty.prototype.interpolateShape = interpolateShape;
                ShapeProperty.prototype.getValue = processEffectsSequence;
                ShapeProperty.prototype.setVValue = setVValue;
                ShapeProperty.prototype.addEffect = addEffect;
                function KeyframedShapeProperty(elem, data, type) {
                    this.propType = "shape";
                    this.comp = elem.comp;
                    this.elem = elem;
                    this.container = elem;
                    this.offsetTime = elem.data.st;
                    this.keyframes = type === 3 ? data.pt.k : data.ks.k;
                    this.keyframesMetadata = [];
                    this.k = true;
                    this.kf = true;
                    var len = this.keyframes[0].s[0].i.length;
                    this.v = shapePool.newElement();
                    this.v.setPathData(this.keyframes[0].s[0].c, len);
                    this.pv = shapePool.clone(this.v);
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                    this.paths = this.localShapeCollection;
                    this.paths.addShape(this.v);
                    this.lastFrame = initFrame;
                    this.reset = resetShape;
                    this._caching = {
                        lastFrame: initFrame,
                        lastIndex: 0
                    };
                    this.effectsSequence = [ interpolateShapeCurrentTime.bind(this) ];
                }
                KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
                KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
                KeyframedShapeProperty.prototype.setVValue = setVValue;
                KeyframedShapeProperty.prototype.addEffect = addEffect;
                var EllShapeProperty = function() {
                    var cPoint = roundCorner;
                    function EllShapePropertyFactory(elem, data) {
                        this.v = shapePool.newElement();
                        this.v.setPathData(true, 4);
                        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                        this.paths = this.localShapeCollection;
                        this.localShapeCollection.addShape(this.v);
                        this.d = data.d;
                        this.elem = elem;
                        this.comp = elem.comp;
                        this.frameId = -1;
                        this.initDynamicPropertyContainer(elem);
                        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                        if (this.dynamicProperties.length) this.k = true; else {
                            this.k = false;
                            this.convertEllToPath();
                        }
                    }
                    EllShapePropertyFactory.prototype = {
                        reset: resetShape,
                        getValue: function() {
                            if (this.elem.globalData.frameId === this.frameId) return;
                            this.frameId = this.elem.globalData.frameId;
                            this.iterateDynamicProperties();
                            if (this._mdf) this.convertEllToPath();
                        },
                        convertEllToPath: function() {
                            var p0 = this.p.v[0];
                            var p1 = this.p.v[1];
                            var s0 = this.s.v[0] / 2;
                            var s1 = this.s.v[1] / 2;
                            var _cw = this.d !== 3;
                            var _v = this.v;
                            _v.v[0][0] = p0;
                            _v.v[0][1] = p1 - s1;
                            _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                            _v.v[1][1] = p1;
                            _v.v[2][0] = p0;
                            _v.v[2][1] = p1 + s1;
                            _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                            _v.v[3][1] = p1;
                            _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                            _v.i[0][1] = p1 - s1;
                            _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                            _v.i[1][1] = p1 - s1 * cPoint;
                            _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                            _v.i[2][1] = p1 + s1;
                            _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                            _v.i[3][1] = p1 + s1 * cPoint;
                            _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                            _v.o[0][1] = p1 - s1;
                            _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                            _v.o[1][1] = p1 + s1 * cPoint;
                            _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                            _v.o[2][1] = p1 + s1;
                            _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                            _v.o[3][1] = p1 - s1 * cPoint;
                        }
                    };
                    extendPrototype([ DynamicPropertyContainer ], EllShapePropertyFactory);
                    return EllShapePropertyFactory;
                }();
                var StarShapeProperty = function() {
                    function StarShapePropertyFactory(elem, data) {
                        this.v = shapePool.newElement();
                        this.v.setPathData(true, 0);
                        this.elem = elem;
                        this.comp = elem.comp;
                        this.data = data;
                        this.frameId = -1;
                        this.d = data.d;
                        this.initDynamicPropertyContainer(elem);
                        if (data.sy === 1) {
                            this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
                            this.is = PropertyFactory.getProp(elem, data.is, 0, .01, this);
                            this.convertToPath = this.convertStarToPath;
                        } else this.convertToPath = this.convertPolygonToPath;
                        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
                        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
                        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
                        this.os = PropertyFactory.getProp(elem, data.os, 0, .01, this);
                        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                        this.localShapeCollection.addShape(this.v);
                        this.paths = this.localShapeCollection;
                        if (this.dynamicProperties.length) this.k = true; else {
                            this.k = false;
                            this.convertToPath();
                        }
                    }
                    StarShapePropertyFactory.prototype = {
                        reset: resetShape,
                        getValue: function() {
                            if (this.elem.globalData.frameId === this.frameId) return;
                            this.frameId = this.elem.globalData.frameId;
                            this.iterateDynamicProperties();
                            if (this._mdf) this.convertToPath();
                        },
                        convertStarToPath: function() {
                            var numPts = Math.floor(this.pt.v) * 2;
                            var angle = Math.PI * 2 / numPts;
                            var longFlag = true;
                            var longRad = this.or.v;
                            var shortRad = this.ir.v;
                            var longRound = this.os.v;
                            var shortRound = this.is.v;
                            var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                            var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                            var i;
                            var rad;
                            var roundness;
                            var perimSegment;
                            var currentAng = -Math.PI / 2;
                            currentAng += this.r.v;
                            var dir = this.data.d === 3 ? -1 : 1;
                            this.v._length = 0;
                            for (i = 0; i < numPts; i += 1) {
                                rad = longFlag ? longRad : shortRad;
                                roundness = longFlag ? longRound : shortRound;
                                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                                var x = rad * Math.cos(currentAng);
                                var y = rad * Math.sin(currentAng);
                                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                                x += +this.p.v[0];
                                y += +this.p.v[1];
                                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                                longFlag = !longFlag;
                                currentAng += angle * dir;
                            }
                        },
                        convertPolygonToPath: function() {
                            var numPts = Math.floor(this.pt.v);
                            var angle = Math.PI * 2 / numPts;
                            var rad = this.or.v;
                            var roundness = this.os.v;
                            var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                            var i;
                            var currentAng = -Math.PI * .5;
                            var dir = this.data.d === 3 ? -1 : 1;
                            currentAng += this.r.v;
                            this.v._length = 0;
                            for (i = 0; i < numPts; i += 1) {
                                var x = rad * Math.cos(currentAng);
                                var y = rad * Math.sin(currentAng);
                                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                                x += +this.p.v[0];
                                y += +this.p.v[1];
                                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                                currentAng += angle * dir;
                            }
                            this.paths.length = 0;
                            this.paths[0] = this.v;
                        }
                    };
                    extendPrototype([ DynamicPropertyContainer ], StarShapePropertyFactory);
                    return StarShapePropertyFactory;
                }();
                var RectShapeProperty = function() {
                    function RectShapePropertyFactory(elem, data) {
                        this.v = shapePool.newElement();
                        this.v.c = true;
                        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                        this.localShapeCollection.addShape(this.v);
                        this.paths = this.localShapeCollection;
                        this.elem = elem;
                        this.comp = elem.comp;
                        this.frameId = -1;
                        this.d = data.d;
                        this.initDynamicPropertyContainer(elem);
                        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
                        if (this.dynamicProperties.length) this.k = true; else {
                            this.k = false;
                            this.convertRectToPath();
                        }
                    }
                    RectShapePropertyFactory.prototype = {
                        convertRectToPath: function() {
                            var p0 = this.p.v[0];
                            var p1 = this.p.v[1];
                            var v0 = this.s.v[0] / 2;
                            var v1 = this.s.v[1] / 2;
                            var round = bmMin(v0, v1, this.r.v);
                            var cPoint = round * (1 - roundCorner);
                            this.v._length = 0;
                            if (this.d === 2 || this.d === 1) {
                                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                                if (round !== 0) {
                                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                                } else {
                                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                                }
                            } else {
                                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                                if (round !== 0) {
                                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                                    this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                                } else {
                                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                                    this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                                }
                            }
                        },
                        getValue: function() {
                            if (this.elem.globalData.frameId === this.frameId) return;
                            this.frameId = this.elem.globalData.frameId;
                            this.iterateDynamicProperties();
                            if (this._mdf) this.convertRectToPath();
                        },
                        reset: resetShape
                    };
                    extendPrototype([ DynamicPropertyContainer ], RectShapePropertyFactory);
                    return RectShapePropertyFactory;
                }();
                function getShapeProp(elem, data, type) {
                    var prop;
                    if (type === 3 || type === 4) {
                        var dataProp = type === 3 ? data.pt : data.ks;
                        var keys = dataProp.k;
                        if (keys.length) prop = new KeyframedShapeProperty(elem, data, type); else prop = new ShapeProperty(elem, data, type);
                    } else if (type === 5) prop = new RectShapeProperty(elem, data); else if (type === 6) prop = new EllShapeProperty(elem, data); else if (type === 7) prop = new StarShapeProperty(elem, data);
                    if (prop.k) elem.addDynamicProperty(prop);
                    return prop;
                }
                function getConstructorFunction() {
                    return ShapeProperty;
                }
                function getKeyframedConstructorFunction() {
                    return KeyframedShapeProperty;
                }
                var ob = {};
                ob.getShapeProp = getShapeProp;
                ob.getConstructorFunction = getConstructorFunction;
                ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
                return ob;
            }();
            /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */            const Matrix = function() {
                var _cos = Math.cos;
                var _sin = Math.sin;
                var _tan = Math.tan;
                var _rnd = Math.round;
                function reset() {
                    this.props[0] = 1;
                    this.props[1] = 0;
                    this.props[2] = 0;
                    this.props[3] = 0;
                    this.props[4] = 0;
                    this.props[5] = 1;
                    this.props[6] = 0;
                    this.props[7] = 0;
                    this.props[8] = 0;
                    this.props[9] = 0;
                    this.props[10] = 1;
                    this.props[11] = 0;
                    this.props[12] = 0;
                    this.props[13] = 0;
                    this.props[14] = 0;
                    this.props[15] = 1;
                    return this;
                }
                function rotate(angle) {
                    if (angle === 0) return this;
                    var mCos = _cos(angle);
                    var mSin = _sin(angle);
                    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                }
                function rotateX(angle) {
                    if (angle === 0) return this;
                    var mCos = _cos(angle);
                    var mSin = _sin(angle);
                    return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
                }
                function rotateY(angle) {
                    if (angle === 0) return this;
                    var mCos = _cos(angle);
                    var mSin = _sin(angle);
                    return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
                }
                function rotateZ(angle) {
                    if (angle === 0) return this;
                    var mCos = _cos(angle);
                    var mSin = _sin(angle);
                    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                }
                function shear(sx, sy) {
                    return this._t(1, sy, sx, 1, 0, 0);
                }
                function skew(ax, ay) {
                    return this.shear(_tan(ax), _tan(ay));
                }
                function skewFromAxis(ax, angle) {
                    var mCos = _cos(angle);
                    var mSin = _sin(angle);
                    return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                }
                function scale(sx, sy, sz) {
                    if (!sz && sz !== 0) sz = 1;
                    if (sx === 1 && sy === 1 && sz === 1) return this;
                    return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
                }
                function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                    this.props[0] = a;
                    this.props[1] = b;
                    this.props[2] = c;
                    this.props[3] = d;
                    this.props[4] = e;
                    this.props[5] = f;
                    this.props[6] = g;
                    this.props[7] = h;
                    this.props[8] = i;
                    this.props[9] = j;
                    this.props[10] = k;
                    this.props[11] = l;
                    this.props[12] = m;
                    this.props[13] = n;
                    this.props[14] = o;
                    this.props[15] = p;
                    return this;
                }
                function translate(tx, ty, tz) {
                    tz = tz || 0;
                    if (tx !== 0 || ty !== 0 || tz !== 0) return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
                    return this;
                }
                function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
                    var _p = this.props;
                    if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
                        _p[12] = _p[12] * a2 + _p[15] * m2;
                        _p[13] = _p[13] * f2 + _p[15] * n2;
                        _p[14] = _p[14] * k2 + _p[15] * o2;
                        _p[15] *= p2;
                        this._identityCalculated = false;
                        return this;
                    }
                    var a1 = _p[0];
                    var b1 = _p[1];
                    var c1 = _p[2];
                    var d1 = _p[3];
                    var e1 = _p[4];
                    var f1 = _p[5];
                    var g1 = _p[6];
                    var h1 = _p[7];
                    var i1 = _p[8];
                    var j1 = _p[9];
                    var k1 = _p[10];
                    var l1 = _p[11];
                    var m1 = _p[12];
                    var n1 = _p[13];
                    var o1 = _p[14];
                    var p1 = _p[15];
                    _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
                    _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
                    _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
                    _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
                    _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
                    _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
                    _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
                    _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
                    _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
                    _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
                    _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
                    _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
                    _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
                    _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
                    _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
                    _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
                    this._identityCalculated = false;
                    return this;
                }
                function multiply(matrix) {
                    var matrixProps = matrix.props;
                    return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
                }
                function isIdentity() {
                    if (!this._identityCalculated) {
                        this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
                        this._identityCalculated = true;
                    }
                    return this._identity;
                }
                function equals(matr) {
                    var i = 0;
                    while (i < 16) {
                        if (matr.props[i] !== this.props[i]) return false;
                        i += 1;
                    }
                    return true;
                }
                function clone(matr) {
                    var i;
                    for (i = 0; i < 16; i += 1) matr.props[i] = this.props[i];
                    return matr;
                }
                function cloneFromProps(props) {
                    var i;
                    for (i = 0; i < 16; i += 1) this.props[i] = props[i];
                }
                function applyToPoint(x, y, z) {
                    return {
                        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
                    };
                }
                function applyToX(x, y, z) {
                    return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
                }
                function applyToY(x, y, z) {
                    return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
                }
                function applyToZ(x, y, z) {
                    return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
                }
                function getInverseMatrix() {
                    var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
                    var a = this.props[5] / determinant;
                    var b = -this.props[1] / determinant;
                    var c = -this.props[4] / determinant;
                    var d = this.props[0] / determinant;
                    var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
                    var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
                    var inverseMatrix = new Matrix;
                    inverseMatrix.props[0] = a;
                    inverseMatrix.props[1] = b;
                    inverseMatrix.props[4] = c;
                    inverseMatrix.props[5] = d;
                    inverseMatrix.props[12] = e;
                    inverseMatrix.props[13] = f;
                    return inverseMatrix;
                }
                function inversePoint(pt) {
                    var inverseMatrix = this.getInverseMatrix();
                    return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
                }
                function inversePoints(pts) {
                    var i;
                    var len = pts.length;
                    var retPts = [];
                    for (i = 0; i < len; i += 1) retPts[i] = inversePoint(pts[i]);
                    return retPts;
                }
                function applyToTriplePoints(pt1, pt2, pt3) {
                    var arr = createTypedArray("float32", 6);
                    if (this.isIdentity()) {
                        arr[0] = pt1[0];
                        arr[1] = pt1[1];
                        arr[2] = pt2[0];
                        arr[3] = pt2[1];
                        arr[4] = pt3[0];
                        arr[5] = pt3[1];
                    } else {
                        var p0 = this.props[0];
                        var p1 = this.props[1];
                        var p4 = this.props[4];
                        var p5 = this.props[5];
                        var p12 = this.props[12];
                        var p13 = this.props[13];
                        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
                        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
                        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
                        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
                        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
                        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
                    }
                    return arr;
                }
                function applyToPointArray(x, y, z) {
                    var arr;
                    if (this.isIdentity()) arr = [ x, y, z ]; else arr = [ x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14] ];
                    return arr;
                }
                function applyToPointStringified(x, y) {
                    if (this.isIdentity()) return x + "," + y;
                    var _p = this.props;
                    return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
                }
                function toCSS() {
                    var i = 0;
                    var props = this.props;
                    var cssValue = "matrix3d(";
                    var v = 1e4;
                    while (i < 16) {
                        cssValue += _rnd(props[i] * v) / v;
                        cssValue += i === 15 ? ")" : ",";
                        i += 1;
                    }
                    return cssValue;
                }
                function roundMatrixProperty(val) {
                    var v = 1e4;
                    if (val < 1e-6 && val > 0 || val > -1e-6 && val < 0) return _rnd(val * v) / v;
                    return val;
                }
                function to2dCSS() {
                    var props = this.props;
                    var _a = roundMatrixProperty(props[0]);
                    var _b = roundMatrixProperty(props[1]);
                    var _c = roundMatrixProperty(props[4]);
                    var _d = roundMatrixProperty(props[5]);
                    var _e = roundMatrixProperty(props[12]);
                    var _f = roundMatrixProperty(props[13]);
                    return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
                }
                return function() {
                    this.reset = reset;
                    this.rotate = rotate;
                    this.rotateX = rotateX;
                    this.rotateY = rotateY;
                    this.rotateZ = rotateZ;
                    this.skew = skew;
                    this.skewFromAxis = skewFromAxis;
                    this.shear = shear;
                    this.scale = scale;
                    this.setTransform = setTransform;
                    this.translate = translate;
                    this.transform = transform;
                    this.multiply = multiply;
                    this.applyToPoint = applyToPoint;
                    this.applyToX = applyToX;
                    this.applyToY = applyToY;
                    this.applyToZ = applyToZ;
                    this.applyToPointArray = applyToPointArray;
                    this.applyToTriplePoints = applyToTriplePoints;
                    this.applyToPointStringified = applyToPointStringified;
                    this.toCSS = toCSS;
                    this.to2dCSS = to2dCSS;
                    this.clone = clone;
                    this.cloneFromProps = cloneFromProps;
                    this.equals = equals;
                    this.inversePoints = inversePoints;
                    this.inversePoint = inversePoint;
                    this.getInverseMatrix = getInverseMatrix;
                    this._t = this.transform;
                    this.isIdentity = isIdentity;
                    this._identity = true;
                    this._identityCalculated = false;
                    this.props = createTypedArray("float32", 16);
                    this.reset();
                };
            }();
            const lottie = {};
            var standalone = "__[STANDALONE]__";
            var animationData = "__[ANIMATIONDATA]__";
            var renderer = "";
            function setLocation(href) {
                setLocationHref(href);
            }
            function searchAnimations() {
                if (standalone === true) animationManager.searchAnimations(animationData, standalone, renderer); else animationManager.searchAnimations();
            }
            function setSubframeRendering(flag) {
                setSubframeEnabled(flag);
            }
            function setPrefix(prefix) {
                setIdPrefix(prefix);
            }
            function loadAnimation(params) {
                if (standalone === true) params.animationData = JSON.parse(animationData);
                return animationManager.loadAnimation(params);
            }
            function setQuality(value) {
                if (typeof value === "string") switch (value) {
                  case "high":
                    setDefaultCurveSegments(200);
                    break;

                  default:
                  case "medium":
                    setDefaultCurveSegments(50);
                    break;

                  case "low":
                    setDefaultCurveSegments(10);
                    break;
                } else if (!isNaN(value) && value > 1) setDefaultCurveSegments(value);
                if (getDefaultCurveSegments() >= 50) roundValues(false); else roundValues(true);
            }
            function inBrowser() {
                return typeof navigator !== "undefined";
            }
            function installPlugin(type, plugin) {
                if (type === "expressions") setExpressionsPlugin(plugin);
            }
            function getFactory(name) {
                switch (name) {
                  case "propertyFactory":
                    return PropertyFactory;

                  case "shapePropertyFactory":
                    return ShapePropertyFactory;

                  case "matrix":
                    return Matrix;

                  default:
                    return null;
                }
            }
            lottie.play = animationManager.play;
            lottie.pause = animationManager.pause;
            lottie.setLocationHref = setLocation;
            lottie.togglePause = animationManager.togglePause;
            lottie.setSpeed = animationManager.setSpeed;
            lottie.setDirection = animationManager.setDirection;
            lottie.stop = animationManager.stop;
            lottie.searchAnimations = searchAnimations;
            lottie.registerAnimation = animationManager.registerAnimation;
            lottie.loadAnimation = loadAnimation;
            lottie.setSubframeRendering = setSubframeRendering;
            lottie.resize = animationManager.resize;
            lottie.goToAndStop = animationManager.goToAndStop;
            lottie.destroy = animationManager.destroy;
            lottie.setQuality = setQuality;
            lottie.inBrowser = inBrowser;
            lottie.installPlugin = installPlugin;
            lottie.freeze = animationManager.freeze;
            lottie.unfreeze = animationManager.unfreeze;
            lottie.setVolume = animationManager.setVolume;
            lottie.mute = animationManager.mute;
            lottie.unmute = animationManager.unmute;
            lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
            lottie.useWebWorker = setWebWorker;
            lottie.setIDPrefix = setPrefix;
            lottie.__getFactory = getFactory;
            lottie.version = "[[BM_VERSION]]";
            function checkReady() {
                if (document.readyState === "complete") {
                    clearInterval(readyStateCheckInterval);
                    searchAnimations();
                }
            }
            function getQueryVariable(variable) {
                var vars = queryString.split("&");
                for (var i = 0; i < vars.length; i += 1) {
                    var pair = vars[i].split("=");
                    if (decodeURIComponent(pair[0]) == variable) return decodeURIComponent(pair[1]);
                }
                return null;
            }
            var queryString = "";
            if (standalone) {
                var scripts = document.getElementsByTagName("script");
                var index = scripts.length - 1;
                var myScript = scripts[index] || {
                    src: ""
                };
                queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
                renderer = getQueryVariable("renderer");
            }
            var readyStateCheckInterval = setInterval(checkReady, 100);
            try {
                if (!(typeof exports === "object" && "object" !== "undefined") && !(typeof define === "function" && __webpack_require__.amdO)) window.bodymovin = lottie;
            } catch (err) {}
            const ShapeModifiers = function() {
                var ob = {};
                var modifiers = {};
                ob.registerModifier = registerModifier;
                ob.getModifier = getModifier;
                function registerModifier(nm, factory) {
                    if (!modifiers[nm]) modifiers[nm] = factory;
                }
                function getModifier(nm, elem, data) {
                    return new modifiers[nm](elem, data);
                }
                return ob;
            }();
            function ShapeModifier() {}
            ShapeModifier.prototype.initModifierProperties = function() {};
            ShapeModifier.prototype.addShapeToModifier = function() {};
            ShapeModifier.prototype.addShape = function(data) {
                if (!this.closed) {
                    data.sh.container.addDynamicProperty(data.sh);
                    var shapeData = {
                        shape: data.sh,
                        data,
                        localShapeCollection: shapeCollectionPool.newShapeCollection()
                    };
                    this.shapes.push(shapeData);
                    this.addShapeToModifier(shapeData);
                    if (this._isAnimated) data.setAsAnimated();
                }
            };
            ShapeModifier.prototype.init = function(elem, data) {
                this.shapes = [];
                this.elem = elem;
                this.initDynamicPropertyContainer(elem);
                this.initModifierProperties(elem, data);
                this.frameId = initialDefaultFrame;
                this.closed = false;
                this.k = false;
                if (this.dynamicProperties.length) this.k = true; else this.getValue(true);
            };
            ShapeModifier.prototype.processKeys = function() {
                if (this.elem.globalData.frameId === this.frameId) return;
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
            };
            extendPrototype([ DynamicPropertyContainer ], ShapeModifier);
            function TrimModifier() {}
            extendPrototype([ ShapeModifier ], TrimModifier);
            TrimModifier.prototype.initModifierProperties = function(elem, data) {
                this.s = PropertyFactory.getProp(elem, data.s, 0, .01, this);
                this.e = PropertyFactory.getProp(elem, data.e, 0, .01, this);
                this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
                this.sValue = 0;
                this.eValue = 0;
                this.getValue = this.processKeys;
                this.m = data.m;
                this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
            };
            TrimModifier.prototype.addShapeToModifier = function(shapeData) {
                shapeData.pathsData = [];
            };
            TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
                var segments = [];
                if (e <= 1) segments.push({
                    s,
                    e
                }); else if (s >= 1) segments.push({
                    s: s - 1,
                    e: e - 1
                }); else {
                    segments.push({
                        s,
                        e: 1
                    });
                    segments.push({
                        s: 0,
                        e: e - 1
                    });
                }
                var shapeSegments = [];
                var i;
                var len = segments.length;
                var segmentOb;
                for (i = 0; i < len; i += 1) {
                    segmentOb = segments[i];
                    if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
                        var shapeS;
                        var shapeE;
                        if (segmentOb.s * totalModifierLength <= addedLength) shapeS = 0; else shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
                        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) shapeE = 1; else shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
                        shapeSegments.push([ shapeS, shapeE ]);
                    }
                }
                if (!shapeSegments.length) shapeSegments.push([ 0, 0 ]);
                return shapeSegments;
            };
            TrimModifier.prototype.releasePathsData = function(pathsData) {
                var i;
                var len = pathsData.length;
                for (i = 0; i < len; i += 1) segmentsLengthPool.release(pathsData[i]);
                pathsData.length = 0;
                return pathsData;
            };
            TrimModifier.prototype.processShapes = function(_isFirstFrame) {
                var s;
                var e;
                if (this._mdf || _isFirstFrame) {
                    var o = this.o.v % 360 / 360;
                    if (o < 0) o += 1;
                    if (this.s.v > 1) s = 1 + o; else if (this.s.v < 0) s = 0 + o; else s = this.s.v + o;
                    if (this.e.v > 1) e = 1 + o; else if (this.e.v < 0) e = 0 + o; else e = this.e.v + o;
                    if (s > e) {
                        var _s = s;
                        s = e;
                        e = _s;
                    }
                    s = Math.round(s * 1e4) * 1e-4;
                    e = Math.round(e * 1e4) * 1e-4;
                    this.sValue = s;
                    this.eValue = e;
                } else {
                    s = this.sValue;
                    e = this.eValue;
                }
                var shapePaths;
                var i;
                var len = this.shapes.length;
                var j;
                var jLen;
                var pathsData;
                var pathData;
                var totalShapeLength;
                var totalModifierLength = 0;
                if (e === s) for (i = 0; i < len; i += 1) {
                    this.shapes[i].localShapeCollection.releaseShapes();
                    this.shapes[i].shape._mdf = true;
                    this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
                    if (this._mdf) this.shapes[i].pathsData.length = 0;
                } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
                    var segments = [];
                    var shapeData;
                    var localShapeCollection;
                    for (i = 0; i < len; i += 1) {
                        shapeData = this.shapes[i];
                        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) shapeData.shape.paths = shapeData.localShapeCollection; else {
                            shapePaths = shapeData.shape.paths;
                            jLen = shapePaths._length;
                            totalShapeLength = 0;
                            if (!shapeData.shape._mdf && shapeData.pathsData.length) totalShapeLength = shapeData.totalShapeLength; else {
                                pathsData = this.releasePathsData(shapeData.pathsData);
                                for (j = 0; j < jLen; j += 1) {
                                    pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                                    pathsData.push(pathData);
                                    totalShapeLength += pathData.totalLength;
                                }
                                shapeData.totalShapeLength = totalShapeLength;
                                shapeData.pathsData = pathsData;
                            }
                            totalModifierLength += totalShapeLength;
                            shapeData.shape._mdf = true;
                        }
                    }
                    var shapeS = s;
                    var shapeE = e;
                    var addedLength = 0;
                    var edges;
                    for (i = len - 1; i >= 0; i -= 1) {
                        shapeData = this.shapes[i];
                        if (shapeData.shape._mdf) {
                            localShapeCollection = shapeData.localShapeCollection;
                            localShapeCollection.releaseShapes();
                            if (this.m === 2 && len > 1) {
                                edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                                addedLength += shapeData.totalShapeLength;
                            } else edges = [ [ shapeS, shapeE ] ];
                            jLen = edges.length;
                            for (j = 0; j < jLen; j += 1) {
                                shapeS = edges[j][0];
                                shapeE = edges[j][1];
                                segments.length = 0;
                                if (shapeE <= 1) segments.push({
                                    s: shapeData.totalShapeLength * shapeS,
                                    e: shapeData.totalShapeLength * shapeE
                                }); else if (shapeS >= 1) segments.push({
                                    s: shapeData.totalShapeLength * (shapeS - 1),
                                    e: shapeData.totalShapeLength * (shapeE - 1)
                                }); else {
                                    segments.push({
                                        s: shapeData.totalShapeLength * shapeS,
                                        e: shapeData.totalShapeLength
                                    });
                                    segments.push({
                                        s: 0,
                                        e: shapeData.totalShapeLength * (shapeE - 1)
                                    });
                                }
                                var newShapesData = this.addShapes(shapeData, segments[0]);
                                if (segments[0].s !== segments[0].e) {
                                    if (segments.length > 1) {
                                        var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                                        if (lastShapeInCollection.c) {
                                            var lastShape = newShapesData.pop();
                                            this.addPaths(newShapesData, localShapeCollection);
                                            newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                                        } else {
                                            this.addPaths(newShapesData, localShapeCollection);
                                            newShapesData = this.addShapes(shapeData, segments[1]);
                                        }
                                    }
                                    this.addPaths(newShapesData, localShapeCollection);
                                }
                            }
                            shapeData.shape.paths = localShapeCollection;
                        }
                    }
                } else if (this._mdf) for (i = 0; i < len; i += 1) {
                    this.shapes[i].pathsData.length = 0;
                    this.shapes[i].shape._mdf = true;
                }
            };
            TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
                var i;
                var len = newPaths.length;
                for (i = 0; i < len; i += 1) localShapeCollection.addShape(newPaths[i]);
            };
            TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
                shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
                shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
                if (newShape) shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
                shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
            };
            TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
                shapePath.setXYAt(points[1], points[5], "o", pos);
                shapePath.setXYAt(points[2], points[6], "i", pos + 1);
                if (newShape) shapePath.setXYAt(points[0], points[4], "v", pos);
                shapePath.setXYAt(points[3], points[7], "v", pos + 1);
            };
            TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
                var pathsData = shapeData.pathsData;
                var shapePaths = shapeData.shape.paths.shapes;
                var i;
                var len = shapeData.shape.paths._length;
                var j;
                var jLen;
                var addedLength = 0;
                var currentLengthData;
                var segmentCount;
                var lengths;
                var segment;
                var shapes = [];
                var initPos;
                var newShape = true;
                if (!shapePath) {
                    shapePath = shapePool.newElement();
                    segmentCount = 0;
                    initPos = 0;
                } else {
                    segmentCount = shapePath._length;
                    initPos = shapePath._length;
                }
                shapes.push(shapePath);
                for (i = 0; i < len; i += 1) {
                    lengths = pathsData[i].lengths;
                    shapePath.c = shapePaths[i].c;
                    jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
                    for (j = 1; j < jLen; j += 1) {
                        currentLengthData = lengths[j - 1];
                        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                            addedLength += currentLengthData.addedLength;
                            shapePath.c = false;
                        } else if (addedLength > shapeSegment.e) {
                            shapePath.c = false;
                            break;
                        } else {
                            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                                this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
                                newShape = false;
                            } else {
                                segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                                newShape = false;
                                shapePath.c = false;
                            }
                            addedLength += currentLengthData.addedLength;
                            segmentCount += 1;
                        }
                    }
                    if (shapePaths[i].c && lengths.length) {
                        currentLengthData = lengths[j - 1];
                        if (addedLength <= shapeSegment.e) {
                            var segmentLength = lengths[j - 1].addedLength;
                            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                                this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
                                newShape = false;
                            } else {
                                segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                                newShape = false;
                                shapePath.c = false;
                            }
                        } else shapePath.c = false;
                        addedLength += currentLengthData.addedLength;
                        segmentCount += 1;
                    }
                    if (shapePath._length) {
                        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
                        shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
                    }
                    if (addedLength > shapeSegment.e) break;
                    if (i < len - 1) {
                        shapePath = shapePool.newElement();
                        newShape = true;
                        shapes.push(shapePath);
                        segmentCount = 0;
                    }
                }
                return shapes;
            };
            function PuckerAndBloatModifier() {}
            extendPrototype([ ShapeModifier ], PuckerAndBloatModifier);
            PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {
                this.getValue = this.processKeys;
                this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
                this._isAnimated = !!this.amount.effectsSequence.length;
            };
            PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
                var percent = amount / 100;
                var centerPoint = [ 0, 0 ];
                var pathLength = path._length;
                var i = 0;
                for (i = 0; i < pathLength; i += 1) {
                    centerPoint[0] += path.v[i][0];
                    centerPoint[1] += path.v[i][1];
                }
                centerPoint[0] /= pathLength;
                centerPoint[1] /= pathLength;
                var clonedPath = shapePool.newElement();
                clonedPath.c = path.c;
                var vX;
                var vY;
                var oX;
                var oY;
                var iX;
                var iY;
                for (i = 0; i < pathLength; i += 1) {
                    vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
                    vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
                    oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
                    oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
                    iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
                    iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
                }
                return clonedPath;
            };
            PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
                var shapePaths;
                var i;
                var len = this.shapes.length;
                var j;
                var jLen;
                var amount = this.amount.v;
                if (amount !== 0) {
                    var shapeData;
                    var localShapeCollection;
                    for (i = 0; i < len; i += 1) {
                        shapeData = this.shapes[i];
                        localShapeCollection = shapeData.localShapeCollection;
                        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                            localShapeCollection.releaseShapes();
                            shapeData.shape._mdf = true;
                            shapePaths = shapeData.shape.paths.shapes;
                            jLen = shapeData.shape.paths._length;
                            for (j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                        }
                        shapeData.shape.paths = shapeData.localShapeCollection;
                    }
                }
                if (!this.dynamicProperties.length) this._mdf = false;
            };
            const TransformPropertyFactory = function() {
                var defaultVector = [ 0, 0 ];
                function applyToMatrix(mat) {
                    var _mdf = this._mdf;
                    this.iterateDynamicProperties();
                    this._mdf = this._mdf || _mdf;
                    if (this.a) mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                    if (this.s) mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                    if (this.sk) mat.skewFromAxis(-this.sk.v, this.sa.v);
                    if (this.r) mat.rotate(-this.r.v); else mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                    if (this.data.p.s) if (this.data.p.z) mat.translate(this.px.v, this.py.v, -this.pz.v); else mat.translate(this.px.v, this.py.v, 0); else mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
                }
                function processKeys(forceRender) {
                    if (this.elem.globalData.frameId === this.frameId) return;
                    if (this._isDirty) {
                        this.precalculateMatrix();
                        this._isDirty = false;
                    }
                    this.iterateDynamicProperties();
                    if (this._mdf || forceRender) {
                        var frameRate;
                        this.v.cloneFromProps(this.pre.props);
                        if (this.appliedTransformations < 1) this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                        if (this.appliedTransformations < 2) this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                        if (this.sk && this.appliedTransformations < 3) this.v.skewFromAxis(-this.sk.v, this.sa.v);
                        if (this.r && this.appliedTransformations < 4) this.v.rotate(-this.r.v); else if (!this.r && this.appliedTransformations < 4) this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                        if (this.autoOriented) {
                            var v1;
                            var v2;
                            frameRate = this.elem.globalData.frameRate;
                            if (this.p && this.p.keyframes && this.p.getValueAtTime) if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                                v1 = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / frameRate, 0);
                                v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                            } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                                v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                                v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / frameRate, 0);
                            } else {
                                v1 = this.p.pv;
                                v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / frameRate, this.p.offsetTime);
                            } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                v1 = [];
                                v2 = [];
                                var px = this.px;
                                var py = this.py;
                                if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                                    v1[0] = px.getValueAtTime((px.keyframes[0].t + .01) / frameRate, 0);
                                    v1[1] = py.getValueAtTime((py.keyframes[0].t + .01) / frameRate, 0);
                                    v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                                    v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                                } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                                    v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                                    v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                                    v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - .01) / frameRate, 0);
                                    v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - .01) / frameRate, 0);
                                } else {
                                    v1 = [ px.pv, py.pv ];
                                    v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - .01) / frameRate, px.offsetTime);
                                    v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - .01) / frameRate, py.offsetTime);
                                }
                            } else {
                                v2 = defaultVector;
                                v1 = v2;
                            }
                            this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
                        }
                        if (this.data.p && this.data.p.s) if (this.data.p.z) this.v.translate(this.px.v, this.py.v, -this.pz.v); else this.v.translate(this.px.v, this.py.v, 0); else this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
                    }
                    this.frameId = this.elem.globalData.frameId;
                }
                function precalculateMatrix() {
                    this.appliedTransformations = 0;
                    this.pre.reset();
                    if (!this.a.effectsSequence.length) {
                        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                        this.appliedTransformations = 1;
                    } else return;
                    if (!this.s.effectsSequence.length) {
                        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                        this.appliedTransformations = 2;
                    } else return;
                    if (this.sk) if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                        this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                        this.appliedTransformations = 3;
                    } else return;
                    if (this.r) {
                        if (!this.r.effectsSequence.length) {
                            this.pre.rotate(-this.r.v);
                            this.appliedTransformations = 4;
                        }
                    } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
                        this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                        this.appliedTransformations = 4;
                    }
                }
                function autoOrient() {}
                function addDynamicProperty(prop) {
                    this._addDynamicProperty(prop);
                    this.elem.addDynamicProperty(prop);
                    this._isDirty = true;
                }
                function TransformProperty(elem, data, container) {
                    this.elem = elem;
                    this.frameId = -1;
                    this.propType = "transform";
                    this.data = data;
                    this.v = new Matrix;
                    this.pre = new Matrix;
                    this.appliedTransformations = 0;
                    this.initDynamicPropertyContainer(container || elem);
                    if (data.p && data.p.s) {
                        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
                        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
                        if (data.p.z) this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
                    } else this.p = PropertyFactory.getProp(elem, data.p || {
                        k: [ 0, 0, 0 ]
                    }, 1, 0, this);
                    if (data.rx) {
                        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
                        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
                        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
                        if (data.or.k[0].ti) {
                            var i;
                            var len = data.or.k.length;
                            for (i = 0; i < len; i += 1) {
                                data.or.k[i].to = null;
                                data.or.k[i].ti = null;
                            }
                        }
                        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
                        this.or.sh = true;
                    } else this.r = PropertyFactory.getProp(elem, data.r || {
                        k: 0
                    }, 0, degToRads, this);
                    if (data.sk) {
                        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
                        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
                    }
                    this.a = PropertyFactory.getProp(elem, data.a || {
                        k: [ 0, 0, 0 ]
                    }, 1, 0, this);
                    this.s = PropertyFactory.getProp(elem, data.s || {
                        k: [ 100, 100, 100 ]
                    }, 1, .01, this);
                    if (data.o) this.o = PropertyFactory.getProp(elem, data.o, 0, .01, elem); else this.o = {
                        _mdf: false,
                        v: 1
                    };
                    this._isDirty = true;
                    if (!this.dynamicProperties.length) this.getValue(true);
                }
                TransformProperty.prototype = {
                    applyToMatrix,
                    getValue: processKeys,
                    precalculateMatrix,
                    autoOrient
                };
                extendPrototype([ DynamicPropertyContainer ], TransformProperty);
                TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
                TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
                function getTransformProperty(elem, data, container) {
                    return new TransformProperty(elem, data, container);
                }
                return {
                    getTransformProperty
                };
            }();
            function RepeaterModifier() {}
            extendPrototype([ ShapeModifier ], RepeaterModifier);
            RepeaterModifier.prototype.initModifierProperties = function(elem, data) {
                this.getValue = this.processKeys;
                this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
                this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
                this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
                this.so = PropertyFactory.getProp(elem, data.tr.so, 0, .01, this);
                this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, .01, this);
                this.data = data;
                if (!this.dynamicProperties.length) this.getValue(true);
                this._isAnimated = !!this.dynamicProperties.length;
                this.pMatrix = new Matrix;
                this.rMatrix = new Matrix;
                this.sMatrix = new Matrix;
                this.tMatrix = new Matrix;
                this.matrix = new Matrix;
            };
            RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {
                var dir = inv ? -1 : 1;
                var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
                var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
                pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
                rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
                rMatrix.rotate(-transform.r.v * dir * perc);
                rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
                sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
                sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
                sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
            };
            RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
                this.elem = elem;
                this.arr = arr;
                this.pos = pos;
                this.elemsData = elemsData;
                this._currentCopies = 0;
                this._elements = [];
                this._groups = [];
                this.frameId = -1;
                this.initDynamicPropertyContainer(elem);
                this.initModifierProperties(elem, arr[pos]);
                while (pos > 0) {
                    pos -= 1;
                    this._elements.unshift(arr[pos]);
                }
                if (this.dynamicProperties.length) this.k = true; else this.getValue(true);
            };
            RepeaterModifier.prototype.resetElements = function(elements) {
                var i;
                var len = elements.length;
                for (i = 0; i < len; i += 1) {
                    elements[i]._processed = false;
                    if (elements[i].ty === "gr") this.resetElements(elements[i].it);
                }
            };
            RepeaterModifier.prototype.cloneElements = function(elements) {
                var newElements = JSON.parse(JSON.stringify(elements));
                this.resetElements(newElements);
                return newElements;
            };
            RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
                var i;
                var len = elements.length;
                for (i = 0; i < len; i += 1) {
                    elements[i]._render = renderFlag;
                    if (elements[i].ty === "gr") this.changeGroupRender(elements[i].it, renderFlag);
                }
            };
            RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
                var items;
                var itemsTransform;
                var i;
                var dir;
                var cont;
                var hasReloaded = false;
                if (this._mdf || _isFirstFrame) {
                    var copies = Math.ceil(this.c.v);
                    if (this._groups.length < copies) {
                        while (this._groups.length < copies) {
                            var group = {
                                it: this.cloneElements(this._elements),
                                ty: "gr"
                            };
                            group.it.push({
                                a: {
                                    a: 0,
                                    ix: 1,
                                    k: [ 0, 0 ]
                                },
                                nm: "Transform",
                                o: {
                                    a: 0,
                                    ix: 7,
                                    k: 100
                                },
                                p: {
                                    a: 0,
                                    ix: 2,
                                    k: [ 0, 0 ]
                                },
                                r: {
                                    a: 1,
                                    ix: 6,
                                    k: [ {
                                        s: 0,
                                        e: 0,
                                        t: 0
                                    }, {
                                        s: 0,
                                        e: 0,
                                        t: 1
                                    } ]
                                },
                                s: {
                                    a: 0,
                                    ix: 3,
                                    k: [ 100, 100 ]
                                },
                                sa: {
                                    a: 0,
                                    ix: 5,
                                    k: 0
                                },
                                sk: {
                                    a: 0,
                                    ix: 4,
                                    k: 0
                                },
                                ty: "tr"
                            });
                            this.arr.splice(0, 0, group);
                            this._groups.splice(0, 0, group);
                            this._currentCopies += 1;
                        }
                        this.elem.reloadShapes();
                        hasReloaded = true;
                    }
                    cont = 0;
                    var renderFlag;
                    for (i = 0; i <= this._groups.length - 1; i += 1) {
                        renderFlag = cont < copies;
                        this._groups[i]._render = renderFlag;
                        this.changeGroupRender(this._groups[i].it, renderFlag);
                        if (!renderFlag) {
                            var elems = this.elemsData[i].it;
                            var transformData = elems[elems.length - 1];
                            if (transformData.transform.op.v !== 0) {
                                transformData.transform.op._mdf = true;
                                transformData.transform.op.v = 0;
                            } else transformData.transform.op._mdf = false;
                        }
                        cont += 1;
                    }
                    this._currentCopies = copies;
                    var offset = this.o.v;
                    var offsetModulo = offset % 1;
                    var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
                    var pProps = this.pMatrix.props;
                    var rProps = this.rMatrix.props;
                    var sProps = this.sMatrix.props;
                    this.pMatrix.reset();
                    this.rMatrix.reset();
                    this.sMatrix.reset();
                    this.tMatrix.reset();
                    this.matrix.reset();
                    var iteration = 0;
                    if (offset > 0) {
                        while (iteration < roundOffset) {
                            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                            iteration += 1;
                        }
                        if (offsetModulo) {
                            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                            iteration += offsetModulo;
                        }
                    } else if (offset < 0) {
                        while (iteration > roundOffset) {
                            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                            iteration -= 1;
                        }
                        if (offsetModulo) {
                            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                            iteration -= offsetModulo;
                        }
                    }
                    i = this.data.m === 1 ? 0 : this._currentCopies - 1;
                    dir = this.data.m === 1 ? 1 : -1;
                    cont = this._currentCopies;
                    var j;
                    var jLen;
                    while (cont) {
                        items = this.elemsData[i].it;
                        itemsTransform = items[items.length - 1].transform.mProps.v.props;
                        jLen = itemsTransform.length;
                        items[items.length - 1].transform.mProps._mdf = true;
                        items[items.length - 1].transform.op._mdf = true;
                        items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
                        if (iteration !== 0) {
                            if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                            this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                            this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                            this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                            for (j = 0; j < jLen; j += 1) itemsTransform[j] = this.matrix.props[j];
                            this.matrix.reset();
                        } else {
                            this.matrix.reset();
                            for (j = 0; j < jLen; j += 1) itemsTransform[j] = this.matrix.props[j];
                        }
                        iteration += 1;
                        cont -= 1;
                        i += dir;
                    }
                } else {
                    cont = this._currentCopies;
                    i = 0;
                    dir = 1;
                    while (cont) {
                        items = this.elemsData[i].it;
                        itemsTransform = items[items.length - 1].transform.mProps.v.props;
                        items[items.length - 1].transform.mProps._mdf = false;
                        items[items.length - 1].transform.op._mdf = false;
                        cont -= 1;
                        i += dir;
                    }
                }
                return hasReloaded;
            };
            RepeaterModifier.prototype.addShape = function() {};
            function RoundCornersModifier() {}
            extendPrototype([ ShapeModifier ], RoundCornersModifier);
            RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {
                this.getValue = this.processKeys;
                this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
                this._isAnimated = !!this.rd.effectsSequence.length;
            };
            RoundCornersModifier.prototype.processPath = function(path, round) {
                var clonedPath = shapePool.newElement();
                clonedPath.c = path.c;
                var i;
                var len = path._length;
                var currentV;
                var currentI;
                var currentO;
                var closerV;
                var distance;
                var newPosPerc;
                var index = 0;
                var vX;
                var vY;
                var oX;
                var oY;
                var iX;
                var iY;
                for (i = 0; i < len; i += 1) {
                    currentV = path.v[i];
                    currentO = path.o[i];
                    currentI = path.i[i];
                    if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) if ((i === 0 || i === len - 1) && !path.c) {
                        clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
                        index += 1;
                    } else {
                        if (i === 0) closerV = path.v[len - 1]; else closerV = path.v[i - 1];
                        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                        iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                        vX = iX;
                        iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                        vY = iY;
                        oX = vX - (vX - currentV[0]) * roundCorner;
                        oY = vY - (vY - currentV[1]) * roundCorner;
                        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                        index += 1;
                        if (i === len - 1) closerV = path.v[0]; else closerV = path.v[i + 1];
                        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                        oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                        vX = oX;
                        oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                        vY = oY;
                        iX = vX - (vX - currentV[0]) * roundCorner;
                        iY = vY - (vY - currentV[1]) * roundCorner;
                        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                        index += 1;
                    } else {
                        clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
                        index += 1;
                    }
                }
                return clonedPath;
            };
            RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
                var shapePaths;
                var i;
                var len = this.shapes.length;
                var j;
                var jLen;
                var rd = this.rd.v;
                if (rd !== 0) {
                    var shapeData;
                    var localShapeCollection;
                    for (i = 0; i < len; i += 1) {
                        shapeData = this.shapes[i];
                        localShapeCollection = shapeData.localShapeCollection;
                        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                            localShapeCollection.releaseShapes();
                            shapeData.shape._mdf = true;
                            shapePaths = shapeData.shape.paths.shapes;
                            jLen = shapeData.shape.paths._length;
                            for (j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
                        }
                        shapeData.shape.paths = shapeData.localShapeCollection;
                    }
                }
                if (!this.dynamicProperties.length) this._mdf = false;
            };
            function floatEqual(a, b) {
                return Math.abs(a - b) * 1e5 <= Math.min(Math.abs(a), Math.abs(b));
            }
            function floatZero(f) {
                return Math.abs(f) <= 1e-5;
            }
            function lerp(p0, p1, amount) {
                return p0 * (1 - amount) + p1 * amount;
            }
            function lerpPoint(p0, p1, amount) {
                return [ lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount) ];
            }
            function quadRoots(a, b, c) {
                if (a === 0) return [];
                var s = b * b - 4 * a * c;
                if (s < 0) return [];
                var singleRoot = -b / (2 * a);
                if (s === 0) return [ singleRoot ];
                var delta = Math.sqrt(s) / (2 * a);
                return [ singleRoot - delta, singleRoot + delta ];
            }
            function polynomialCoefficients(p0, p1, p2, p3) {
                return [ -p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0 ];
            }
            function singlePoint(p) {
                return new PolynomialBezier(p, p, p, p, false);
            }
            function PolynomialBezier(p0, p1, p2, p3, linearize) {
                if (linearize && pointEqual(p0, p1)) p1 = lerpPoint(p0, p3, 1 / 3);
                if (linearize && pointEqual(p2, p3)) p2 = lerpPoint(p0, p3, 2 / 3);
                var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
                var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
                this.a = [ coeffx[0], coeffy[0] ];
                this.b = [ coeffx[1], coeffy[1] ];
                this.c = [ coeffx[2], coeffy[2] ];
                this.d = [ coeffx[3], coeffy[3] ];
                this.points = [ p0, p1, p2, p3 ];
            }
            PolynomialBezier.prototype.point = function(t) {
                return [ ((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1] ];
            };
            PolynomialBezier.prototype.derivative = function(t) {
                return [ (3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1] ];
            };
            PolynomialBezier.prototype.tangentAngle = function(t) {
                var p = this.derivative(t);
                return Math.atan2(p[1], p[0]);
            };
            PolynomialBezier.prototype.normalAngle = function(t) {
                var p = this.derivative(t);
                return Math.atan2(p[0], p[1]);
            };
            PolynomialBezier.prototype.inflectionPoints = function() {
                var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
                if (floatZero(denom)) return [];
                var tcusp = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
                var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
                if (square < 0) return [];
                var root = Math.sqrt(square);
                if (floatZero(root)) {
                    if (root > 0 && root < 1) return [ tcusp ];
                    return [];
                }
                return [ tcusp - root, tcusp + root ].filter((function(r) {
                    return r > 0 && r < 1;
                }));
            };
            PolynomialBezier.prototype.split = function(t) {
                if (t <= 0) return [ singlePoint(this.points[0]), this ];
                if (t >= 1) return [ this, singlePoint(this.points[this.points.length - 1]) ];
                var p10 = lerpPoint(this.points[0], this.points[1], t);
                var p11 = lerpPoint(this.points[1], this.points[2], t);
                var p12 = lerpPoint(this.points[2], this.points[3], t);
                var p20 = lerpPoint(p10, p11, t);
                var p21 = lerpPoint(p11, p12, t);
                var p3 = lerpPoint(p20, p21, t);
                return [ new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true) ];
            };
            function extrema(bez, comp) {
                var min = bez.points[0][comp];
                var max = bez.points[bez.points.length - 1][comp];
                if (min > max) {
                    var e = max;
                    max = min;
                    min = e;
                }
                var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);
                for (var i = 0; i < f.length; i += 1) if (f[i] > 0 && f[i] < 1) {
                    var val = bez.point(f[i])[comp];
                    if (val < min) min = val; else if (val > max) max = val;
                }
                return {
                    min,
                    max
                };
            }
            PolynomialBezier.prototype.bounds = function() {
                return {
                    x: extrema(this, 0),
                    y: extrema(this, 1)
                };
            };
            PolynomialBezier.prototype.boundingBox = function() {
                var bounds = this.bounds();
                return {
                    left: bounds.x.min,
                    right: bounds.x.max,
                    top: bounds.y.min,
                    bottom: bounds.y.max,
                    width: bounds.x.max - bounds.x.min,
                    height: bounds.y.max - bounds.y.min,
                    cx: (bounds.x.max + bounds.x.min) / 2,
                    cy: (bounds.y.max + bounds.y.min) / 2
                };
            };
            function intersectData(bez, t1, t2) {
                var box = bez.boundingBox();
                return {
                    cx: box.cx,
                    cy: box.cy,
                    width: box.width,
                    height: box.height,
                    bez,
                    t: (t1 + t2) / 2,
                    t1,
                    t2
                };
            }
            function splitData(data) {
                var split = data.bez.split(.5);
                return [ intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2) ];
            }
            function boxIntersect(b1, b2) {
                return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
            }
            function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
                if (!boxIntersect(d1, d2)) return;
                if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
                    intersections.push([ d1.t, d2.t ]);
                    return;
                }
                var d1s = splitData(d1);
                var d2s = splitData(d2);
                intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
                intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
                intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
                intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
            }
            PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
                if (tolerance === void 0) tolerance = 2;
                if (maxRecursion === void 0) maxRecursion = 7;
                var intersections = [];
                intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
                return intersections;
            };
            PolynomialBezier.shapeSegment = function(shapePath, index) {
                var nextIndex = (index + 1) % shapePath.length();
                return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
            };
            PolynomialBezier.shapeSegmentInverted = function(shapePath, index) {
                var nextIndex = (index + 1) % shapePath.length();
                return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);
            };
            function crossProduct(a, b) {
                return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
            }
            function lineIntersection(start1, end1, start2, end2) {
                var v1 = [ start1[0], start1[1], 1 ];
                var v2 = [ end1[0], end1[1], 1 ];
                var v3 = [ start2[0], start2[1], 1 ];
                var v4 = [ end2[0], end2[1], 1 ];
                var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
                if (floatZero(r[2])) return null;
                return [ r[0] / r[2], r[1] / r[2] ];
            }
            function polarOffset(p, angle, length) {
                return [ p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length ];
            }
            function pointDistance(p1, p2) {
                return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
            }
            function pointEqual(p1, p2) {
                return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
            }
            function ZigZagModifier() {}
            extendPrototype([ ShapeModifier ], ZigZagModifier);
            ZigZagModifier.prototype.initModifierProperties = function(elem, data) {
                this.getValue = this.processKeys;
                this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);
                this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);
                this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);
                this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
            };
            function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
                var angO = angle - Math.PI / 2;
                var angI = angle + Math.PI / 2;
                var px = point[0] + Math.cos(angle) * direction * amplitude;
                var py = point[1] - Math.sin(angle) * direction * amplitude;
                outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
            }
            function getPerpendicularVector(pt1, pt2) {
                var vector = [ pt2[0] - pt1[0], pt2[1] - pt1[1] ];
                var rot = -Math.PI * .5;
                var rotatedVector = [ Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1] ];
                return rotatedVector;
            }
            function getProjectingAngle(path, cur) {
                var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
                var nextIndex = (cur + 1) % path.length();
                var prevPoint = path.v[prevIndex];
                var nextPoint = path.v[nextIndex];
                var pVector = getPerpendicularVector(prevPoint, nextPoint);
                return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
            }
            function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
                var angle = getProjectingAngle(path, cur);
                var point = path.v[cur % path._length];
                var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
                var nextPoint = path.v[(cur + 1) % path._length];
                var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
                var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
                setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);
            }
            function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
                for (var i = 0; i < frequency; i += 1) {
                    var t = (i + 1) / (frequency + 1);
                    var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
                    var angle = segment.normalAngle(t);
                    var point = segment.point(t);
                    setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);
                    direction = -direction;
                }
                return direction;
            }
            ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
                var count = path._length;
                var clonedPath = shapePool.newElement();
                clonedPath.c = path.c;
                if (!path.c) count -= 1;
                if (count === 0) return clonedPath;
                var direction = -1;
                var segment = PolynomialBezier.shapeSegment(path, 0);
                zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
                for (var i = 0; i < count; i += 1) {
                    direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
                    if (i === count - 1 && !path.c) segment = null; else segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
                    zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
                }
                return clonedPath;
            };
            ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
                var shapePaths;
                var i;
                var len = this.shapes.length;
                var j;
                var jLen;
                var amplitude = this.amplitude.v;
                var frequency = Math.max(0, Math.round(this.frequency.v));
                var pointType = this.pointsType.v;
                if (amplitude !== 0) {
                    var shapeData;
                    var localShapeCollection;
                    for (i = 0; i < len; i += 1) {
                        shapeData = this.shapes[i];
                        localShapeCollection = shapeData.localShapeCollection;
                        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                            localShapeCollection.releaseShapes();
                            shapeData.shape._mdf = true;
                            shapePaths = shapeData.shape.paths.shapes;
                            jLen = shapeData.shape.paths._length;
                            for (j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
                        }
                        shapeData.shape.paths = shapeData.localShapeCollection;
                    }
                }
                if (!this.dynamicProperties.length) this._mdf = false;
            };
            function linearOffset(p1, p2, amount) {
                var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
                return [ polarOffset(p1, angle, amount), polarOffset(p2, angle, amount) ];
            }
            function offsetSegment(segment, amount) {
                var p0;
                var p1a;
                var p1b;
                var p2b;
                var p2a;
                var p3;
                var e;
                e = linearOffset(segment.points[0], segment.points[1], amount);
                p0 = e[0];
                p1a = e[1];
                e = linearOffset(segment.points[1], segment.points[2], amount);
                p1b = e[0];
                p2b = e[1];
                e = linearOffset(segment.points[2], segment.points[3], amount);
                p2a = e[0];
                p3 = e[1];
                var p1 = lineIntersection(p0, p1a, p1b, p2b);
                if (p1 === null) p1 = p1a;
                var p2 = lineIntersection(p2a, p3, p1b, p2b);
                if (p2 === null) p2 = p2a;
                return new PolynomialBezier(p0, p1, p2, p3);
            }
            function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
                var p0 = seg1.points[3];
                var p1 = seg2.points[0];
                if (lineJoin === 3) return p0;
                if (pointEqual(p0, p1)) return p0;
                if (lineJoin === 2) {
                    var angleOut = -seg1.tangentAngle(1);
                    var angleIn = -seg2.tangentAngle(0) + Math.PI;
                    var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
                    var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
                    var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
                    outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
                    tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
                    outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
                    return p1;
                }
                var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
                var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
                var intersection = lineIntersection(t0, p0, p1, t1);
                if (intersection && pointDistance(intersection, p0) < miterLimit) {
                    outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
                    return intersection;
                }
                return p0;
            }
            function getIntersection(a, b) {
                const intersect = a.intersections(b);
                if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
                if (intersect.length) return intersect[0];
                return null;
            }
            function pruneSegmentIntersection(a, b) {
                var outa = a.slice();
                var outb = b.slice();
                var intersect = getIntersection(a[a.length - 1], b[0]);
                if (intersect) {
                    outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
                    outb[0] = b[0].split(intersect[1])[1];
                }
                if (a.length > 1 && b.length > 1) {
                    intersect = getIntersection(a[0], b[b.length - 1]);
                    if (intersect) return [ [ a[0].split(intersect[0])[0] ], [ b[b.length - 1].split(intersect[1])[1] ] ];
                }
                return [ outa, outb ];
            }
            function pruneIntersections(segments) {
                var e;
                for (var i = 1; i < segments.length; i += 1) {
                    e = pruneSegmentIntersection(segments[i - 1], segments[i]);
                    segments[i - 1] = e[0];
                    segments[i] = e[1];
                }
                if (segments.length > 1) {
                    e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
                    segments[segments.length - 1] = e[0];
                    segments[0] = e[1];
                }
                return segments;
            }
            function offsetSegmentSplit(segment, amount) {
                var flex = segment.inflectionPoints();
                var left;
                var right;
                var split;
                var mid;
                if (flex.length === 0) return [ offsetSegment(segment, amount) ];
                if (flex.length === 1 || floatEqual(flex[1], 1)) {
                    split = segment.split(flex[0]);
                    left = split[0];
                    right = split[1];
                    return [ offsetSegment(left, amount), offsetSegment(right, amount) ];
                }
                split = segment.split(flex[0]);
                left = split[0];
                var t = (flex[1] - flex[0]) / (1 - flex[0]);
                split = split[1].split(t);
                mid = split[0];
                right = split[1];
                return [ offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount) ];
            }
            function OffsetPathModifier() {}
            extendPrototype([ ShapeModifier ], OffsetPathModifier);
            OffsetPathModifier.prototype.initModifierProperties = function(elem, data) {
                this.getValue = this.processKeys;
                this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
                this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);
                this.lineJoin = data.lj;
                this._isAnimated = this.amount.effectsSequence.length !== 0;
            };
            OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
                var outputBezier = shapePool.newElement();
                outputBezier.c = inputBezier.c;
                var count = inputBezier.length();
                if (!inputBezier.c) count -= 1;
                var i;
                var j;
                var segment;
                var multiSegments = [];
                for (i = 0; i < count; i += 1) {
                    segment = PolynomialBezier.shapeSegment(inputBezier, i);
                    multiSegments.push(offsetSegmentSplit(segment, amount));
                }
                if (!inputBezier.c) for (i = count - 1; i >= 0; i -= 1) {
                    segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
                    multiSegments.push(offsetSegmentSplit(segment, amount));
                }
                multiSegments = pruneIntersections(multiSegments);
                var lastPoint = null;
                var lastSeg = null;
                for (i = 0; i < multiSegments.length; i += 1) {
                    var multiSegment = multiSegments[i];
                    if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
                    lastSeg = multiSegment[multiSegment.length - 1];
                    for (j = 0; j < multiSegment.length; j += 1) {
                        segment = multiSegment[j];
                        if (lastPoint && pointEqual(segment.points[0], lastPoint)) outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1); else outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
                        outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
                        lastPoint = segment.points[3];
                    }
                }
                if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
                return outputBezier;
            };
            OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
                var shapePaths;
                var i;
                var len = this.shapes.length;
                var j;
                var jLen;
                var amount = this.amount.v;
                var miterLimit = this.miterLimit.v;
                var lineJoin = this.lineJoin;
                if (amount !== 0) {
                    var shapeData;
                    var localShapeCollection;
                    for (i = 0; i < len; i += 1) {
                        shapeData = this.shapes[i];
                        localShapeCollection = shapeData.localShapeCollection;
                        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                            localShapeCollection.releaseShapes();
                            shapeData.shape._mdf = true;
                            shapePaths = shapeData.shape.paths.shapes;
                            jLen = shapeData.shape.paths._length;
                            for (j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
                        }
                        shapeData.shape.paths = shapeData.localShapeCollection;
                    }
                }
                if (!this.dynamicProperties.length) this._mdf = false;
            };
            function getFontProperties(fontData) {
                var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
                var fWeight = "normal";
                var fStyle = "normal";
                var len = styles.length;
                var styleName;
                for (var i = 0; i < len; i += 1) {
                    styleName = styles[i].toLowerCase();
                    switch (styleName) {
                      case "italic":
                        fStyle = "italic";
                        break;

                      case "bold":
                        fWeight = "700";
                        break;

                      case "black":
                        fWeight = "900";
                        break;

                      case "medium":
                        fWeight = "500";
                        break;

                      case "regular":
                      case "normal":
                        fWeight = "400";
                        break;

                      case "light":
                      case "thin":
                        fWeight = "200";
                        break;

                      default:
                        break;
                    }
                }
                return {
                    style: fStyle,
                    weight: fontData.fWeight || fWeight
                };
            }
            const FontManager = function() {
                var maxWaitingTime = 5e3;
                var emptyChar = {
                    w: 0,
                    size: 0,
                    shapes: [],
                    data: {
                        shapes: []
                    }
                };
                var combinedCharacters = [];
                combinedCharacters = combinedCharacters.concat([ 2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403 ]);
                var BLACK_FLAG_CODE_POINT = 127988;
                var CANCEL_TAG_CODE_POINT = 917631;
                var A_TAG_CODE_POINT = 917601;
                var Z_TAG_CODE_POINT = 917626;
                var VARIATION_SELECTOR_16_CODE_POINT = 65039;
                var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
                var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
                var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
                var surrogateModifiers = [ "d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff" ];
                function trimFontOptions(font) {
                    var familyArray = font.split(",");
                    var i;
                    var len = familyArray.length;
                    var enabledFamilies = [];
                    for (i = 0; i < len; i += 1) if (familyArray[i] !== "sans-serif" && familyArray[i] !== "monospace") enabledFamilies.push(familyArray[i]);
                    return enabledFamilies.join(",");
                }
                function setUpNode(font, family) {
                    var parentNode = createTag("span");
                    parentNode.setAttribute("aria-hidden", true);
                    parentNode.style.fontFamily = family;
                    var node = createTag("span");
                    node.innerText = "giItT1WQy@!-/#";
                    parentNode.style.position = "absolute";
                    parentNode.style.left = "-10000px";
                    parentNode.style.top = "-10000px";
                    parentNode.style.fontSize = "300px";
                    parentNode.style.fontVariant = "normal";
                    parentNode.style.fontStyle = "normal";
                    parentNode.style.fontWeight = "normal";
                    parentNode.style.letterSpacing = "0";
                    parentNode.appendChild(node);
                    document.body.appendChild(parentNode);
                    var width = node.offsetWidth;
                    node.style.fontFamily = trimFontOptions(font) + ", " + family;
                    return {
                        node,
                        w: width,
                        parent: parentNode
                    };
                }
                function checkLoadedFonts() {
                    var i;
                    var len = this.fonts.length;
                    var node;
                    var w;
                    var loadedCount = len;
                    for (i = 0; i < len; i += 1) if (this.fonts[i].loaded) loadedCount -= 1; else if (this.fonts[i].fOrigin === "n" || this.fonts[i].origin === 0) this.fonts[i].loaded = true; else {
                        node = this.fonts[i].monoCase.node;
                        w = this.fonts[i].monoCase.w;
                        if (node.offsetWidth !== w) {
                            loadedCount -= 1;
                            this.fonts[i].loaded = true;
                        } else {
                            node = this.fonts[i].sansCase.node;
                            w = this.fonts[i].sansCase.w;
                            if (node.offsetWidth !== w) {
                                loadedCount -= 1;
                                this.fonts[i].loaded = true;
                            }
                        }
                        if (this.fonts[i].loaded) {
                            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
                            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
                        }
                    }
                    if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) setTimeout(this.checkLoadedFontsBinded, 20); else setTimeout(this.setIsLoadedBinded, 10);
                }
                function createHelper(fontData, def) {
                    var engine = document.body && def ? "svg" : "canvas";
                    var helper;
                    var fontProps = getFontProperties(fontData);
                    if (engine === "svg") {
                        var tHelper = createNS("text");
                        tHelper.style.fontSize = "100px";
                        tHelper.setAttribute("font-family", fontData.fFamily);
                        tHelper.setAttribute("font-style", fontProps.style);
                        tHelper.setAttribute("font-weight", fontProps.weight);
                        tHelper.textContent = "1";
                        if (fontData.fClass) {
                            tHelper.style.fontFamily = "inherit";
                            tHelper.setAttribute("class", fontData.fClass);
                        } else tHelper.style.fontFamily = fontData.fFamily;
                        def.appendChild(tHelper);
                        helper = tHelper;
                    } else {
                        var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
                        tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
                        helper = tCanvasHelper;
                    }
                    function measure(text) {
                        if (engine === "svg") {
                            helper.textContent = text;
                            return helper.getComputedTextLength();
                        }
                        return helper.measureText(text).width;
                    }
                    return {
                        measureText: measure
                    };
                }
                function addFonts(fontData, defs) {
                    if (!fontData) {
                        this.isLoaded = true;
                        return;
                    }
                    if (this.chars) {
                        this.isLoaded = true;
                        this.fonts = fontData.list;
                        return;
                    }
                    if (!document.body) {
                        this.isLoaded = true;
                        fontData.list.forEach((data => {
                            data.helper = createHelper(data);
                            data.cache = {};
                        }));
                        this.fonts = fontData.list;
                        return;
                    }
                    var fontArr = fontData.list;
                    var i;
                    var len = fontArr.length;
                    var _pendingFonts = len;
                    for (i = 0; i < len; i += 1) {
                        var shouldLoadFont = true;
                        var loadedSelector;
                        var j;
                        fontArr[i].loaded = false;
                        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, "monospace");
                        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, "sans-serif");
                        if (!fontArr[i].fPath) {
                            fontArr[i].loaded = true;
                            _pendingFonts -= 1;
                        } else if (fontArr[i].fOrigin === "p" || fontArr[i].origin === 3) {
                            loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
                            if (loadedSelector.length > 0) shouldLoadFont = false;
                            if (shouldLoadFont) {
                                var s = createTag("style");
                                s.setAttribute("f-forigin", fontArr[i].fOrigin);
                                s.setAttribute("f-origin", fontArr[i].origin);
                                s.setAttribute("f-family", fontArr[i].fFamily);
                                s.type = "text/css";
                                s.innerText = "@font-face {font-family: " + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
                                defs.appendChild(s);
                            }
                        } else if (fontArr[i].fOrigin === "g" || fontArr[i].origin === 1) {
                            loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                            for (j = 0; j < loadedSelector.length; j += 1) if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) shouldLoadFont = false;
                            if (shouldLoadFont) {
                                var l = createTag("link");
                                l.setAttribute("f-forigin", fontArr[i].fOrigin);
                                l.setAttribute("f-origin", fontArr[i].origin);
                                l.type = "text/css";
                                l.rel = "stylesheet";
                                l.href = fontArr[i].fPath;
                                document.body.appendChild(l);
                            }
                        } else if (fontArr[i].fOrigin === "t" || fontArr[i].origin === 2) {
                            loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                            for (j = 0; j < loadedSelector.length; j += 1) if (fontArr[i].fPath === loadedSelector[j].src) shouldLoadFont = false;
                            if (shouldLoadFont) {
                                var sc = createTag("link");
                                sc.setAttribute("f-forigin", fontArr[i].fOrigin);
                                sc.setAttribute("f-origin", fontArr[i].origin);
                                sc.setAttribute("rel", "stylesheet");
                                sc.setAttribute("href", fontArr[i].fPath);
                                defs.appendChild(sc);
                            }
                        }
                        fontArr[i].helper = createHelper(fontArr[i], defs);
                        fontArr[i].cache = {};
                        this.fonts.push(fontArr[i]);
                    }
                    if (_pendingFonts === 0) this.isLoaded = true; else setTimeout(this.checkLoadedFonts.bind(this), 100);
                }
                function addChars(chars) {
                    if (!chars) return;
                    if (!this.chars) this.chars = [];
                    var i;
                    var len = chars.length;
                    var j;
                    var jLen = this.chars.length;
                    var found;
                    for (i = 0; i < len; i += 1) {
                        j = 0;
                        found = false;
                        while (j < jLen) {
                            if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) found = true;
                            j += 1;
                        }
                        if (!found) {
                            this.chars.push(chars[i]);
                            jLen += 1;
                        }
                    }
                }
                function getCharData(char, style, font) {
                    var i = 0;
                    var len = this.chars.length;
                    while (i < len) {
                        if (this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font) return this.chars[i];
                        i += 1;
                    }
                    if ((typeof char === "string" && char.charCodeAt(0) !== 13 || !char) && console && console.warn && !this._warned) {
                        this._warned = true;
                        console.warn("Missing character from exported characters list: ", char, style, font);
                    }
                    return emptyChar;
                }
                function measureText(char, fontName, size) {
                    var fontData = this.getFontByName(fontName);
                    var index = char;
                    if (!fontData.cache[index]) {
                        var tHelper = fontData.helper;
                        if (char === " ") {
                            var doubleSize = tHelper.measureText("|" + char + "|");
                            var singleSize = tHelper.measureText("||");
                            fontData.cache[index] = (doubleSize - singleSize) / 100;
                        } else fontData.cache[index] = tHelper.measureText(char) / 100;
                    }
                    return fontData.cache[index] * size;
                }
                function getFontByName(name) {
                    var i = 0;
                    var len = this.fonts.length;
                    while (i < len) {
                        if (this.fonts[i].fName === name) return this.fonts[i];
                        i += 1;
                    }
                    return this.fonts[0];
                }
                function getCodePoint(string) {
                    var codePoint = 0;
                    var first = string.charCodeAt(0);
                    if (first >= 55296 && first <= 56319) {
                        var second = string.charCodeAt(1);
                        if (second >= 56320 && second <= 57343) codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
                    }
                    return codePoint;
                }
                function isModifier(firstCharCode, secondCharCode) {
                    var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
                    return surrogateModifiers.indexOf(sum) !== -1;
                }
                function isZeroWidthJoiner(charCode) {
                    return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
                }
                function isVariationSelector(charCode) {
                    return charCode === VARIATION_SELECTOR_16_CODE_POINT;
                }
                function isRegionalCode(string) {
                    var codePoint = getCodePoint(string);
                    if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) return true;
                    return false;
                }
                function isFlagEmoji(string) {
                    return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
                }
                function isCombinedCharacter(char) {
                    return combinedCharacters.indexOf(char) !== -1;
                }
                function isRegionalFlag(text, index) {
                    var codePoint = getCodePoint(text.substr(index, 2));
                    if (codePoint !== BLACK_FLAG_CODE_POINT) return false;
                    var count = 0;
                    index += 2;
                    while (count < 5) {
                        codePoint = getCodePoint(text.substr(index, 2));
                        if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) return false;
                        count += 1;
                        index += 2;
                    }
                    return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;
                }
                function setIsLoaded() {
                    this.isLoaded = true;
                }
                var Font = function() {
                    this.fonts = [];
                    this.chars = null;
                    this.typekitLoaded = 0;
                    this.isLoaded = false;
                    this._warned = false;
                    this.initTime = Date.now();
                    this.setIsLoadedBinded = this.setIsLoaded.bind(this);
                    this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
                };
                Font.isModifier = isModifier;
                Font.isZeroWidthJoiner = isZeroWidthJoiner;
                Font.isFlagEmoji = isFlagEmoji;
                Font.isRegionalCode = isRegionalCode;
                Font.isCombinedCharacter = isCombinedCharacter;
                Font.isRegionalFlag = isRegionalFlag;
                Font.isVariationSelector = isVariationSelector;
                Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
                var fontPrototype = {
                    addChars,
                    addFonts,
                    getCharData,
                    getFontByName,
                    measureText,
                    checkLoadedFonts,
                    setIsLoaded
                };
                Font.prototype = fontPrototype;
                return Font;
            }();
            function SlotManager(animationData) {
                this.animationData = animationData;
            }
            SlotManager.prototype.getProp = function(data) {
                if (this.animationData.slots && this.animationData.slots[data.sid]) return Object.assign(data, this.animationData.slots[data.sid].p);
                return data;
            };
            function slotFactory(animationData) {
                return new SlotManager(animationData);
            }
            function RenderableElement() {}
            RenderableElement.prototype = {
                initRenderable: function() {
                    this.isInRange = false;
                    this.hidden = false;
                    this.isTransparent = false;
                    this.renderableComponents = [];
                },
                addRenderableComponent: function(component) {
                    if (this.renderableComponents.indexOf(component) === -1) this.renderableComponents.push(component);
                },
                removeRenderableComponent: function(component) {
                    if (this.renderableComponents.indexOf(component) !== -1) this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
                },
                prepareRenderableFrame: function(num) {
                    this.checkLayerLimits(num);
                },
                checkTransparency: function() {
                    if (this.finalTransform.mProp.o.v <= 0) {
                        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                            this.isTransparent = true;
                            this.hide();
                        }
                    } else if (this.isTransparent) {
                        this.isTransparent = false;
                        this.show();
                    }
                },
                checkLayerLimits: function(num) {
                    if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
                        if (this.isInRange !== true) {
                            this.globalData._mdf = true;
                            this._mdf = true;
                            this.isInRange = true;
                            this.show();
                        }
                    } else if (this.isInRange !== false) {
                        this.globalData._mdf = true;
                        this.isInRange = false;
                        this.hide();
                    }
                },
                renderRenderable: function() {
                    var i;
                    var len = this.renderableComponents.length;
                    for (i = 0; i < len; i += 1) this.renderableComponents[i].renderFrame(this._isFirstFrame);
                },
                sourceRectAtTime: function() {
                    return {
                        top: 0,
                        left: 0,
                        width: 100,
                        height: 100
                    };
                },
                getLayerSize: function() {
                    if (this.data.ty === 5) return {
                        w: this.data.textData.width,
                        h: this.data.textData.height
                    };
                    return {
                        w: this.data.width,
                        h: this.data.height
                    };
                }
            };
            const getBlendMode = function() {
                var blendModeEnums = {
                    0: "source-over",
                    1: "multiply",
                    2: "screen",
                    3: "overlay",
                    4: "darken",
                    5: "lighten",
                    6: "color-dodge",
                    7: "color-burn",
                    8: "hard-light",
                    9: "soft-light",
                    10: "difference",
                    11: "exclusion",
                    12: "hue",
                    13: "saturation",
                    14: "color",
                    15: "luminosity"
                };
                return function(mode) {
                    return blendModeEnums[mode] || "";
                };
            }();
            function SliderEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function AngleEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function ColorEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
            }
            function PointEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
            }
            function LayerIndexEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function MaskIndexEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function CheckboxEffect(data, elem, container) {
                this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
            }
            function NoValueEffect() {
                this.p = {};
            }
            function EffectsManager(data, element) {
                var effects = data.ef || [];
                this.effectElements = [];
                var i;
                var len = effects.length;
                var effectItem;
                for (i = 0; i < len; i += 1) {
                    effectItem = new GroupEffect(effects[i], element);
                    this.effectElements.push(effectItem);
                }
            }
            function GroupEffect(data, element) {
                this.init(data, element);
            }
            extendPrototype([ DynamicPropertyContainer ], GroupEffect);
            GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
            GroupEffect.prototype.init = function(data, element) {
                this.data = data;
                this.effectElements = [];
                this.initDynamicPropertyContainer(element);
                var i;
                var len = this.data.ef.length;
                var eff;
                var effects = this.data.ef;
                for (i = 0; i < len; i += 1) {
                    eff = null;
                    switch (effects[i].ty) {
                      case 0:
                        eff = new SliderEffect(effects[i], element, this);
                        break;

                      case 1:
                        eff = new AngleEffect(effects[i], element, this);
                        break;

                      case 2:
                        eff = new ColorEffect(effects[i], element, this);
                        break;

                      case 3:
                        eff = new PointEffect(effects[i], element, this);
                        break;

                      case 4:
                      case 7:
                        eff = new CheckboxEffect(effects[i], element, this);
                        break;

                      case 10:
                        eff = new LayerIndexEffect(effects[i], element, this);
                        break;

                      case 11:
                        eff = new MaskIndexEffect(effects[i], element, this);
                        break;

                      case 5:
                        eff = new EffectsManager(effects[i], element, this);
                        break;

                      default:
                        eff = new NoValueEffect(effects[i], element, this);
                        break;
                    }
                    if (eff) this.effectElements.push(eff);
                }
            };
            function BaseElement() {}
            BaseElement.prototype = {
                checkMasks: function() {
                    if (!this.data.hasMask) return false;
                    var i = 0;
                    var len = this.data.masksProperties.length;
                    while (i < len) {
                        if (this.data.masksProperties[i].mode !== "n" && this.data.masksProperties[i].cl !== false) return true;
                        i += 1;
                    }
                    return false;
                },
                initExpressions: function() {
                    const expressionsInterfaces = getExpressionInterfaces();
                    if (!expressionsInterfaces) return;
                    const LayerExpressionInterface = expressionsInterfaces("layer");
                    const EffectsExpressionInterface = expressionsInterfaces("effects");
                    const ShapeExpressionInterface = expressionsInterfaces("shape");
                    const TextExpressionInterface = expressionsInterfaces("text");
                    const CompExpressionInterface = expressionsInterfaces("comp");
                    this.layerInterface = LayerExpressionInterface(this);
                    if (this.data.hasMask && this.maskManager) this.layerInterface.registerMaskInterface(this.maskManager);
                    var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                    this.layerInterface.registerEffectsInterface(effectsInterface);
                    if (this.data.ty === 0 || this.data.xt) this.compInterface = CompExpressionInterface(this); else if (this.data.ty === 4) {
                        this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
                        this.layerInterface.content = this.layerInterface.shapeInterface;
                    } else if (this.data.ty === 5) {
                        this.layerInterface.textInterface = TextExpressionInterface(this);
                        this.layerInterface.text = this.layerInterface.textInterface;
                    }
                },
                setBlendMode: function() {
                    var blendModeValue = getBlendMode(this.data.bm);
                    var elem = this.baseElement || this.layerElement;
                    elem.style["mix-blend-mode"] = blendModeValue;
                },
                initBaseData: function(data, globalData, comp) {
                    this.globalData = globalData;
                    this.comp = comp;
                    this.data = data;
                    this.layerId = createElementID();
                    if (!this.data.sr) this.data.sr = 1;
                    this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
                },
                getType: function() {
                    return this.type;
                },
                sourceRectAtTime: function() {}
            };
            function FrameElement() {}
            FrameElement.prototype = {
                initFrame: function() {
                    this._isFirstFrame = false;
                    this.dynamicProperties = [];
                    this._mdf = false;
                },
                prepareProperties: function(num, isVisible) {
                    var i;
                    var len = this.dynamicProperties.length;
                    for (i = 0; i < len; i += 1) if (isVisible || this._isParent && this.dynamicProperties[i].propType === "transform") {
                        this.dynamicProperties[i].getValue();
                        if (this.dynamicProperties[i]._mdf) {
                            this.globalData._mdf = true;
                            this._mdf = true;
                        }
                    }
                },
                addDynamicProperty: function(prop) {
                    if (this.dynamicProperties.indexOf(prop) === -1) this.dynamicProperties.push(prop);
                }
            };
            function FootageElement(data, globalData, comp) {
                this.initFrame();
                this.initRenderable();
                this.assetData = globalData.getAssetData(data.refId);
                this.footageData = globalData.imageLoader.getAsset(this.assetData);
                this.initBaseData(data, globalData, comp);
            }
            FootageElement.prototype.prepareFrame = function() {};
            extendPrototype([ RenderableElement, BaseElement, FrameElement ], FootageElement);
            FootageElement.prototype.getBaseElement = function() {
                return null;
            };
            FootageElement.prototype.renderFrame = function() {};
            FootageElement.prototype.destroy = function() {};
            FootageElement.prototype.initExpressions = function() {
                const expressionsInterfaces = getExpressionInterfaces();
                if (!expressionsInterfaces) return;
                const FootageInterface = expressionsInterfaces("footage");
                this.layerInterface = FootageInterface(this);
            };
            FootageElement.prototype.getFootageData = function() {
                return this.footageData;
            };
            function AudioElement(data, globalData, comp) {
                this.initFrame();
                this.initRenderable();
                this.assetData = globalData.getAssetData(data.refId);
                this.initBaseData(data, globalData, comp);
                this._isPlaying = false;
                this._canPlay = false;
                var assetPath = this.globalData.getAssetsPath(this.assetData);
                this.audio = this.globalData.audioController.createAudio(assetPath);
                this._currentTime = 0;
                this.globalData.audioController.addAudio(this);
                this._volumeMultiplier = 1;
                this._volume = 1;
                this._previousVolume = null;
                this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                    _placeholder: true
                };
                this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
                    k: [ 100 ]
                }, 1, .01, this);
            }
            AudioElement.prototype.prepareFrame = function(num) {
                this.prepareRenderableFrame(num, true);
                this.prepareProperties(num, true);
                if (!this.tm._placeholder) {
                    var timeRemapped = this.tm.v;
                    this._currentTime = timeRemapped;
                } else this._currentTime = num / this.data.sr;
                this._volume = this.lv.v[0];
                var totalVolume = this._volume * this._volumeMultiplier;
                if (this._previousVolume !== totalVolume) {
                    this._previousVolume = totalVolume;
                    this.audio.volume(totalVolume);
                }
            };
            extendPrototype([ RenderableElement, BaseElement, FrameElement ], AudioElement);
            AudioElement.prototype.renderFrame = function() {
                if (this.isInRange && this._canPlay) if (!this._isPlaying) {
                    this.audio.play();
                    this.audio.seek(this._currentTime / this.globalData.frameRate);
                    this._isPlaying = true;
                } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) this.audio.seek(this._currentTime / this.globalData.frameRate);
            };
            AudioElement.prototype.show = function() {};
            AudioElement.prototype.hide = function() {
                this.audio.pause();
                this._isPlaying = false;
            };
            AudioElement.prototype.pause = function() {
                this.audio.pause();
                this._isPlaying = false;
                this._canPlay = false;
            };
            AudioElement.prototype.resume = function() {
                this._canPlay = true;
            };
            AudioElement.prototype.setRate = function(rateValue) {
                this.audio.rate(rateValue);
            };
            AudioElement.prototype.volume = function(volumeValue) {
                this._volumeMultiplier = volumeValue;
                this._previousVolume = volumeValue * this._volume;
                this.audio.volume(this._previousVolume);
            };
            AudioElement.prototype.getBaseElement = function() {
                return null;
            };
            AudioElement.prototype.destroy = function() {};
            AudioElement.prototype.sourceRectAtTime = function() {};
            AudioElement.prototype.initExpressions = function() {};
            function BaseRenderer() {}
            BaseRenderer.prototype.checkLayers = function(num) {
                var i;
                var len = this.layers.length;
                var data;
                this.completeLayers = true;
                for (i = len - 1; i >= 0; i -= 1) {
                    if (!this.elements[i]) {
                        data = this.layers[i];
                        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) this.buildItem(i);
                    }
                    this.completeLayers = this.elements[i] ? this.completeLayers : false;
                }
                this.checkPendingElements();
            };
            BaseRenderer.prototype.createItem = function(layer) {
                switch (layer.ty) {
                  case 2:
                    return this.createImage(layer);

                  case 0:
                    return this.createComp(layer);

                  case 1:
                    return this.createSolid(layer);

                  case 3:
                    return this.createNull(layer);

                  case 4:
                    return this.createShape(layer);

                  case 5:
                    return this.createText(layer);

                  case 6:
                    return this.createAudio(layer);

                  case 13:
                    return this.createCamera(layer);

                  case 15:
                    return this.createFootage(layer);

                  default:
                    return this.createNull(layer);
                }
            };
            BaseRenderer.prototype.createCamera = function() {
                throw new Error("You're using a 3d camera. Try the html renderer.");
            };
            BaseRenderer.prototype.createAudio = function(data) {
                return new AudioElement(data, this.globalData, this);
            };
            BaseRenderer.prototype.createFootage = function(data) {
                return new FootageElement(data, this.globalData, this);
            };
            BaseRenderer.prototype.buildAllItems = function() {
                var i;
                var len = this.layers.length;
                for (i = 0; i < len; i += 1) this.buildItem(i);
                this.checkPendingElements();
            };
            BaseRenderer.prototype.includeLayers = function(newLayers) {
                this.completeLayers = false;
                var i;
                var len = newLayers.length;
                var j;
                var jLen = this.layers.length;
                for (i = 0; i < len; i += 1) {
                    j = 0;
                    while (j < jLen) {
                        if (this.layers[j].id === newLayers[i].id) {
                            this.layers[j] = newLayers[i];
                            break;
                        }
                        j += 1;
                    }
                }
            };
            BaseRenderer.prototype.setProjectInterface = function(pInterface) {
                this.globalData.projectInterface = pInterface;
            };
            BaseRenderer.prototype.initItems = function() {
                if (!this.globalData.progressiveLoad) this.buildAllItems();
            };
            BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
                var elements = this.elements;
                var layers = this.layers;
                var i = 0;
                var len = layers.length;
                while (i < len) {
                    if (layers[i].ind == parentName) if (!elements[i] || elements[i] === true) {
                        this.buildItem(i);
                        this.addPendingElement(element);
                    } else {
                        hierarchy.push(elements[i]);
                        elements[i].setAsParent();
                        if (layers[i].parent !== void 0) this.buildElementParenting(element, layers[i].parent, hierarchy); else element.setHierarchy(hierarchy);
                    }
                    i += 1;
                }
            };
            BaseRenderer.prototype.addPendingElement = function(element) {
                this.pendingElements.push(element);
            };
            BaseRenderer.prototype.searchExtraCompositions = function(assets) {
                var i;
                var len = assets.length;
                for (i = 0; i < len; i += 1) if (assets[i].xt) {
                    var comp = this.createComp(assets[i]);
                    comp.initExpressions();
                    this.globalData.projectInterface.registerComposition(comp);
                }
            };
            BaseRenderer.prototype.getElementById = function(ind) {
                var i;
                var len = this.elements.length;
                for (i = 0; i < len; i += 1) if (this.elements[i].data.ind === ind) return this.elements[i];
                return null;
            };
            BaseRenderer.prototype.getElementByPath = function(path) {
                var pathValue = path.shift();
                var element;
                if (typeof pathValue === "number") element = this.elements[pathValue]; else {
                    var i;
                    var len = this.elements.length;
                    for (i = 0; i < len; i += 1) if (this.elements[i].data.nm === pathValue) {
                        element = this.elements[i];
                        break;
                    }
                }
                if (path.length === 0) return element;
                return element.getElementByPath(path);
            };
            BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
                this.globalData.fontManager = new FontManager;
                this.globalData.slotManager = slotFactory(animData);
                this.globalData.fontManager.addChars(animData.chars);
                this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
                this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
                this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
                this.globalData.imageLoader = this.animationItem.imagePreloader;
                this.globalData.audioController = this.animationItem.audioController;
                this.globalData.frameId = 0;
                this.globalData.frameRate = animData.fr;
                this.globalData.nm = animData.nm;
                this.globalData.compSize = {
                    w: animData.w,
                    h: animData.h
                };
            };
            var effectTypes = {
                TRANSFORM_EFFECT: "transformEFfect"
            };
            function TransformElement() {}
            TransformElement.prototype = {
                initTransform: function() {
                    var mat = new Matrix;
                    this.finalTransform = {
                        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                            o: 0
                        },
                        _matMdf: false,
                        _localMatMdf: false,
                        _opMdf: false,
                        mat,
                        localMat: mat,
                        localOpacity: 1
                    };
                    if (this.data.ao) this.finalTransform.mProp.autoOriented = true;
                    if (this.data.ty !== 11) ;
                },
                renderTransform: function() {
                    this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
                    this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
                    if (this.hierarchy) {
                        var mat;
                        var finalMat = this.finalTransform.mat;
                        var i = 0;
                        var len = this.hierarchy.length;
                        if (!this.finalTransform._matMdf) while (i < len) {
                            if (this.hierarchy[i].finalTransform.mProp._mdf) {
                                this.finalTransform._matMdf = true;
                                break;
                            }
                            i += 1;
                        }
                        if (this.finalTransform._matMdf) {
                            mat = this.finalTransform.mProp.v.props;
                            finalMat.cloneFromProps(mat);
                            for (i = 0; i < len; i += 1) finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
                        }
                    }
                    if (this.finalTransform._matMdf) this.finalTransform._localMatMdf = this.finalTransform._matMdf;
                    if (this.finalTransform._opMdf) this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                },
                renderLocalTransform: function() {
                    if (this.localTransforms) {
                        var i = 0;
                        var len = this.localTransforms.length;
                        this.finalTransform._localMatMdf = this.finalTransform._matMdf;
                        if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) while (i < len) {
                            if (this.localTransforms[i]._mdf) this.finalTransform._localMatMdf = true;
                            if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
                                this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                                this.finalTransform._opMdf = true;
                            }
                            i += 1;
                        }
                        if (this.finalTransform._localMatMdf) {
                            var localMat = this.finalTransform.localMat;
                            this.localTransforms[0].matrix.clone(localMat);
                            for (i = 1; i < len; i += 1) {
                                var lmat = this.localTransforms[i].matrix;
                                localMat.multiply(lmat);
                            }
                            localMat.multiply(this.finalTransform.mat);
                        }
                        if (this.finalTransform._opMdf) {
                            var localOp = this.finalTransform.localOpacity;
                            for (i = 0; i < len; i += 1) localOp *= this.localTransforms[i].opacity * .01;
                            this.finalTransform.localOpacity = localOp;
                        }
                    }
                },
                searchEffectTransforms: function() {
                    if (this.renderableEffectsManager) {
                        var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                        if (transformEffects.length) {
                            this.localTransforms = [];
                            this.finalTransform.localMat = new Matrix;
                            var i = 0;
                            var len = transformEffects.length;
                            for (i = 0; i < len; i += 1) this.localTransforms.push(transformEffects[i]);
                        }
                    }
                },
                globalToLocal: function(pt) {
                    var transforms = [];
                    transforms.push(this.finalTransform);
                    var flag = true;
                    var comp = this.comp;
                    while (flag) if (comp.finalTransform) {
                        if (comp.data.hasMask) transforms.splice(0, 0, comp.finalTransform);
                        comp = comp.comp;
                    } else flag = false;
                    var i;
                    var len = transforms.length;
                    var ptNew;
                    for (i = 0; i < len; i += 1) {
                        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
                        pt = [ pt[0] - ptNew[0], pt[1] - ptNew[1], 0 ];
                    }
                    return pt;
                },
                mHelper: new Matrix
            };
            function MaskElement(data, element, globalData) {
                this.data = data;
                this.element = element;
                this.globalData = globalData;
                this.storedData = [];
                this.masksProperties = this.data.masksProperties || [];
                this.maskElement = null;
                var defs = this.globalData.defs;
                var i;
                var len = this.masksProperties ? this.masksProperties.length : 0;
                this.viewData = createSizedArray(len);
                this.solidPath = "";
                var path;
                var properties = this.masksProperties;
                var count = 0;
                var currentMasks = [];
                var j;
                var jLen;
                var layerId = createElementID();
                var rect;
                var expansor;
                var feMorph;
                var x;
                var maskType = "clipPath";
                var maskRef = "clip-path";
                for (i = 0; i < len; i += 1) {
                    if (properties[i].mode !== "a" && properties[i].mode !== "n" || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
                        maskType = "mask";
                        maskRef = "mask";
                    }
                    if ((properties[i].mode === "s" || properties[i].mode === "i") && count === 0) {
                        rect = createNS("rect");
                        rect.setAttribute("fill", "#ffffff");
                        rect.setAttribute("width", this.element.comp.data.w || 0);
                        rect.setAttribute("height", this.element.comp.data.h || 0);
                        currentMasks.push(rect);
                    } else rect = null;
                    path = createNS("path");
                    if (properties[i].mode === "n") {
                        this.viewData[i] = {
                            op: PropertyFactory.getProp(this.element, properties[i].o, 0, .01, this.element),
                            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                            elem: path,
                            lastPath: ""
                        };
                        defs.appendChild(path);
                    } else {
                        count += 1;
                        path.setAttribute("fill", properties[i].mode === "s" ? "#000000" : "#ffffff");
                        path.setAttribute("clip-rule", "nonzero");
                        var filterID;
                        if (properties[i].x.k !== 0) {
                            maskType = "mask";
                            maskRef = "mask";
                            x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
                            filterID = createElementID();
                            expansor = createNS("filter");
                            expansor.setAttribute("id", filterID);
                            feMorph = createNS("feMorphology");
                            feMorph.setAttribute("operator", "erode");
                            feMorph.setAttribute("in", "SourceGraphic");
                            feMorph.setAttribute("radius", "0");
                            expansor.appendChild(feMorph);
                            defs.appendChild(expansor);
                            path.setAttribute("stroke", properties[i].mode === "s" ? "#000000" : "#ffffff");
                        } else {
                            feMorph = null;
                            x = null;
                        }
                        this.storedData[i] = {
                            elem: path,
                            x,
                            expan: feMorph,
                            lastPath: "",
                            lastOperator: "",
                            filterId: filterID,
                            lastRadius: 0
                        };
                        if (properties[i].mode === "i") {
                            jLen = currentMasks.length;
                            var g = createNS("g");
                            for (j = 0; j < jLen; j += 1) g.appendChild(currentMasks[j]);
                            var mask = createNS("mask");
                            mask.setAttribute("mask-type", "alpha");
                            mask.setAttribute("id", layerId + "_" + count);
                            mask.appendChild(path);
                            defs.appendChild(mask);
                            g.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
                            currentMasks.length = 0;
                            currentMasks.push(g);
                        } else currentMasks.push(path);
                        if (properties[i].inv && !this.solidPath) this.solidPath = this.createLayerSolidPath();
                        this.viewData[i] = {
                            elem: path,
                            lastPath: "",
                            op: PropertyFactory.getProp(this.element, properties[i].o, 0, .01, this.element),
                            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                            invRect: rect
                        };
                        if (!this.viewData[i].prop.k) this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
                    }
                }
                this.maskElement = createNS(maskType);
                len = currentMasks.length;
                for (i = 0; i < len; i += 1) this.maskElement.appendChild(currentMasks[i]);
                if (count > 0) {
                    this.maskElement.setAttribute("id", layerId);
                    this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
                    defs.appendChild(this.maskElement);
                }
                if (this.viewData.length) this.element.addRenderableComponent(this);
            }
            MaskElement.prototype.getMaskProperty = function(pos) {
                return this.viewData[pos].prop;
            };
            MaskElement.prototype.renderFrame = function(isFirstFrame) {
                var finalMat = this.element.finalTransform.mat;
                var i;
                var len = this.masksProperties.length;
                for (i = 0; i < len; i += 1) {
                    if (this.viewData[i].prop._mdf || isFirstFrame) this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
                    if (this.viewData[i].op._mdf || isFirstFrame) this.viewData[i].elem.setAttribute("fill-opacity", this.viewData[i].op.v);
                    if (this.masksProperties[i].mode !== "n") {
                        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) this.viewData[i].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
                        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
                            var feMorph = this.storedData[i].expan;
                            if (this.storedData[i].x.v < 0) {
                                if (this.storedData[i].lastOperator !== "erode") {
                                    this.storedData[i].lastOperator = "erode";
                                    this.storedData[i].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i].filterId + ")");
                                }
                                feMorph.setAttribute("radius", -this.storedData[i].x.v);
                            } else {
                                if (this.storedData[i].lastOperator !== "dilate") {
                                    this.storedData[i].lastOperator = "dilate";
                                    this.storedData[i].elem.setAttribute("filter", null);
                                }
                                this.storedData[i].elem.setAttribute("stroke-width", this.storedData[i].x.v * 2);
                            }
                        }
                    }
                }
            };
            MaskElement.prototype.getMaskelement = function() {
                return this.maskElement;
            };
            MaskElement.prototype.createLayerSolidPath = function() {
                var path = "M0,0 ";
                path += " h" + this.globalData.compSize.w;
                path += " v" + this.globalData.compSize.h;
                path += " h-" + this.globalData.compSize.w;
                path += " v-" + this.globalData.compSize.h + " ";
                return path;
            };
            MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
                var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
                var i;
                var len;
                len = pathNodes._length;
                for (i = 1; i < len; i += 1) pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[i][0] + "," + pathNodes.i[i][1] + " " + pathNodes.v[i][0] + "," + pathNodes.v[i][1];
                if (pathNodes.c && len > 1) pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
                if (viewData.lastPath !== pathString) {
                    var pathShapeValue = "";
                    if (viewData.elem) {
                        if (pathNodes.c) pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
                        viewData.elem.setAttribute("d", pathShapeValue);
                    }
                    viewData.lastPath = pathString;
                }
            };
            MaskElement.prototype.destroy = function() {
                this.element = null;
                this.globalData = null;
                this.maskElement = null;
                this.data = null;
                this.masksProperties = null;
            };
            const filtersFactory = function() {
                var ob = {};
                ob.createFilter = createFilter;
                ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
                function createFilter(filId, skipCoordinates) {
                    var fil = createNS("filter");
                    fil.setAttribute("id", filId);
                    if (skipCoordinates !== true) {
                        fil.setAttribute("filterUnits", "objectBoundingBox");
                        fil.setAttribute("x", "0%");
                        fil.setAttribute("y", "0%");
                        fil.setAttribute("width", "100%");
                        fil.setAttribute("height", "100%");
                    }
                    return fil;
                }
                function createAlphaToLuminanceFilter() {
                    var feColorMatrix = createNS("feColorMatrix");
                    feColorMatrix.setAttribute("type", "matrix");
                    feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
                    feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
                    return feColorMatrix;
                }
                return ob;
            }();
            const featureSupport = function() {
                var ob = {
                    maskType: true,
                    svgLumaHidden: true,
                    offscreenCanvas: typeof OffscreenCanvas !== "undefined"
                };
                if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) ob.maskType = false;
                if (/firefox/i.test(navigator.userAgent)) ob.svgLumaHidden = false;
                return ob;
            }();
            var registeredEffects$1 = {};
            var idPrefix = "filter_result_";
            function SVGEffects(elem) {
                var i;
                var source = "SourceGraphic";
                var len = elem.data.ef ? elem.data.ef.length : 0;
                var filId = createElementID();
                var fil = filtersFactory.createFilter(filId, true);
                var count = 0;
                this.filters = [];
                var filterManager;
                for (i = 0; i < len; i += 1) {
                    filterManager = null;
                    var type = elem.data.ef[i].ty;
                    if (registeredEffects$1[type]) {
                        var Effect = registeredEffects$1[type].effect;
                        filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
                        source = idPrefix + count;
                        if (registeredEffects$1[type].countsAsEffect) count += 1;
                    }
                    if (filterManager) this.filters.push(filterManager);
                }
                if (count) {
                    elem.globalData.defs.appendChild(fil);
                    elem.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                }
                if (this.filters.length) elem.addRenderableComponent(this);
            }
            SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
                var i;
                var len = this.filters.length;
                for (i = 0; i < len; i += 1) this.filters[i].renderFrame(_isFirstFrame);
            };
            SVGEffects.prototype.getEffects = function(type) {
                var i;
                var len = this.filters.length;
                var effects = [];
                for (i = 0; i < len; i += 1) if (this.filters[i].type === type) effects.push(this.filters[i]);
                return effects;
            };
            function registerEffect$1(id, effect, countsAsEffect) {
                registeredEffects$1[id] = {
                    effect,
                    countsAsEffect
                };
            }
            function SVGBaseElement() {}
            SVGBaseElement.prototype = {
                initRendererElement: function() {
                    this.layerElement = createNS("g");
                },
                createContainerElements: function() {
                    this.matteElement = createNS("g");
                    this.transformedElement = this.layerElement;
                    this.maskedElement = this.layerElement;
                    this._sizeChanged = false;
                    var layerElementParent = null;
                    if (this.data.td) {
                        this.matteMasks = {};
                        var gg = createNS("g");
                        gg.setAttribute("id", this.layerId);
                        gg.appendChild(this.layerElement);
                        layerElementParent = gg;
                        this.globalData.defs.appendChild(gg);
                    } else if (this.data.tt) {
                        this.matteElement.appendChild(this.layerElement);
                        layerElementParent = this.matteElement;
                        this.baseElement = this.matteElement;
                    } else this.baseElement = this.layerElement;
                    if (this.data.ln) this.layerElement.setAttribute("id", this.data.ln);
                    if (this.data.cl) this.layerElement.setAttribute("class", this.data.cl);
                    if (this.data.ty === 0 && !this.data.hd) {
                        var cp = createNS("clipPath");
                        var pt = createNS("path");
                        pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                        var clipId = createElementID();
                        cp.setAttribute("id", clipId);
                        cp.appendChild(pt);
                        this.globalData.defs.appendChild(cp);
                        if (this.checkMasks()) {
                            var cpGroup = createNS("g");
                            cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
                            cpGroup.appendChild(this.layerElement);
                            this.transformedElement = cpGroup;
                            if (layerElementParent) layerElementParent.appendChild(this.transformedElement); else this.baseElement = this.transformedElement;
                        } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
                    }
                    if (this.data.bm !== 0) this.setBlendMode();
                },
                renderElement: function() {
                    if (this.finalTransform._localMatMdf) this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
                    if (this.finalTransform._opMdf) this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
                },
                destroyBaseElement: function() {
                    this.layerElement = null;
                    this.matteElement = null;
                    this.maskManager.destroy();
                },
                getBaseElement: function() {
                    if (this.data.hd) return null;
                    return this.baseElement;
                },
                createRenderableComponents: function() {
                    this.maskManager = new MaskElement(this.data, this, this.globalData);
                    this.renderableEffectsManager = new SVGEffects(this);
                    this.searchEffectTransforms();
                },
                getMatte: function(matteType) {
                    if (!this.matteMasks) this.matteMasks = {};
                    if (!this.matteMasks[matteType]) {
                        var id = this.layerId + "_" + matteType;
                        var filId;
                        var fil;
                        var useElement;
                        var gg;
                        if (matteType === 1 || matteType === 3) {
                            var masker = createNS("mask");
                            masker.setAttribute("id", id);
                            masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
                            useElement = createNS("use");
                            useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
                            masker.appendChild(useElement);
                            this.globalData.defs.appendChild(masker);
                            if (!featureSupport.maskType && matteType === 1) {
                                masker.setAttribute("mask-type", "luminance");
                                filId = createElementID();
                                fil = filtersFactory.createFilter(filId);
                                this.globalData.defs.appendChild(fil);
                                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                                gg = createNS("g");
                                gg.appendChild(useElement);
                                masker.appendChild(gg);
                                gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                            }
                        } else if (matteType === 2) {
                            var maskGroup = createNS("mask");
                            maskGroup.setAttribute("id", id);
                            maskGroup.setAttribute("mask-type", "alpha");
                            var maskGrouper = createNS("g");
                            maskGroup.appendChild(maskGrouper);
                            filId = createElementID();
                            fil = filtersFactory.createFilter(filId);
                            var feCTr = createNS("feComponentTransfer");
                            feCTr.setAttribute("in", "SourceGraphic");
                            fil.appendChild(feCTr);
                            var feFunc = createNS("feFuncA");
                            feFunc.setAttribute("type", "table");
                            feFunc.setAttribute("tableValues", "1.0 0.0");
                            feCTr.appendChild(feFunc);
                            this.globalData.defs.appendChild(fil);
                            var alphaRect = createNS("rect");
                            alphaRect.setAttribute("width", this.comp.data.w);
                            alphaRect.setAttribute("height", this.comp.data.h);
                            alphaRect.setAttribute("x", "0");
                            alphaRect.setAttribute("y", "0");
                            alphaRect.setAttribute("fill", "#ffffff");
                            alphaRect.setAttribute("opacity", "0");
                            maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                            maskGrouper.appendChild(alphaRect);
                            useElement = createNS("use");
                            useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
                            maskGrouper.appendChild(useElement);
                            if (!featureSupport.maskType) {
                                maskGroup.setAttribute("mask-type", "luminance");
                                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                                gg = createNS("g");
                                maskGrouper.appendChild(alphaRect);
                                gg.appendChild(this.layerElement);
                                maskGrouper.appendChild(gg);
                            }
                            this.globalData.defs.appendChild(maskGroup);
                        }
                        this.matteMasks[matteType] = id;
                    }
                    return this.matteMasks[matteType];
                },
                setMatte: function(id) {
                    if (!this.matteElement) return;
                    this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
                }
            };
            function HierarchyElement() {}
            HierarchyElement.prototype = {
                initHierarchy: function() {
                    this.hierarchy = [];
                    this._isParent = false;
                    this.checkParenting();
                },
                setHierarchy: function(hierarchy) {
                    this.hierarchy = hierarchy;
                },
                setAsParent: function() {
                    this._isParent = true;
                },
                checkParenting: function() {
                    if (this.data.parent !== void 0) this.comp.buildElementParenting(this, this.data.parent, []);
                }
            };
            function RenderableDOMElement() {}
            (function() {
                var _prototype = {
                    initElement: function(data, globalData, comp) {
                        this.initFrame();
                        this.initBaseData(data, globalData, comp);
                        this.initTransform(data, globalData, comp);
                        this.initHierarchy();
                        this.initRenderable();
                        this.initRendererElement();
                        this.createContainerElements();
                        this.createRenderableComponents();
                        this.createContent();
                        this.hide();
                    },
                    hide: function() {
                        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                            var elem = this.baseElement || this.layerElement;
                            elem.style.display = "none";
                            this.hidden = true;
                        }
                    },
                    show: function() {
                        if (this.isInRange && !this.isTransparent) {
                            if (!this.data.hd) {
                                var elem = this.baseElement || this.layerElement;
                                elem.style.display = "block";
                            }
                            this.hidden = false;
                            this._isFirstFrame = true;
                        }
                    },
                    renderFrame: function() {
                        if (this.data.hd || this.hidden) return;
                        this.renderTransform();
                        this.renderRenderable();
                        this.renderLocalTransform();
                        this.renderElement();
                        this.renderInnerContent();
                        if (this._isFirstFrame) this._isFirstFrame = false;
                    },
                    renderInnerContent: function() {},
                    prepareFrame: function(num) {
                        this._mdf = false;
                        this.prepareRenderableFrame(num);
                        this.prepareProperties(num, this.isInRange);
                        this.checkTransparency();
                    },
                    destroy: function() {
                        this.innerElem = null;
                        this.destroyBaseElement();
                    }
                };
                extendPrototype([ RenderableElement, createProxyFunction(_prototype) ], RenderableDOMElement);
            })();
            function IImageElement(data, globalData, comp) {
                this.assetData = globalData.getAssetData(data.refId);
                if (this.assetData && this.assetData.sid) this.assetData = globalData.slotManager.getProp(this.assetData);
                this.initElement(data, globalData, comp);
                this.sourceRect = {
                    top: 0,
                    left: 0,
                    width: this.assetData.w,
                    height: this.assetData.h
                };
            }
            extendPrototype([ BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement ], IImageElement);
            IImageElement.prototype.createContent = function() {
                var assetPath = this.globalData.getAssetsPath(this.assetData);
                this.innerElem = createNS("image");
                this.innerElem.setAttribute("width", this.assetData.w + "px");
                this.innerElem.setAttribute("height", this.assetData.h + "px");
                this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
                this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
                this.layerElement.appendChild(this.innerElem);
            };
            IImageElement.prototype.sourceRectAtTime = function() {
                return this.sourceRect;
            };
            function ProcessedElement(element, position) {
                this.elem = element;
                this.pos = position;
            }
            function IShapeElement() {}
            IShapeElement.prototype = {
                addShapeToModifiers: function(data) {
                    var i;
                    var len = this.shapeModifiers.length;
                    for (i = 0; i < len; i += 1) this.shapeModifiers[i].addShape(data);
                },
                isShapeInAnimatedModifiers: function(data) {
                    var i = 0;
                    var len = this.shapeModifiers.length;
                    while (i < len) if (this.shapeModifiers[i].isAnimatedWithShape(data)) return true;
                    return false;
                },
                renderModifiers: function() {
                    if (!this.shapeModifiers.length) return;
                    var i;
                    var len = this.shapes.length;
                    for (i = 0; i < len; i += 1) this.shapes[i].sh.reset();
                    len = this.shapeModifiers.length;
                    var shouldBreakProcess;
                    for (i = len - 1; i >= 0; i -= 1) {
                        shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
                        if (shouldBreakProcess) break;
                    }
                },
                searchProcessedElement: function(elem) {
                    var elements = this.processedElements;
                    var i = 0;
                    var len = elements.length;
                    while (i < len) {
                        if (elements[i].elem === elem) return elements[i].pos;
                        i += 1;
                    }
                    return 0;
                },
                addProcessedElement: function(elem, pos) {
                    var elements = this.processedElements;
                    var i = elements.length;
                    while (i) {
                        i -= 1;
                        if (elements[i].elem === elem) {
                            elements[i].pos = pos;
                            return;
                        }
                    }
                    elements.push(new ProcessedElement(elem, pos));
                },
                prepareFrame: function(num) {
                    this.prepareRenderableFrame(num);
                    this.prepareProperties(num, this.isInRange);
                }
            };
            const lineCapEnum = {
                1: "butt",
                2: "round",
                3: "square"
            };
            const lineJoinEnum = {
                1: "miter",
                2: "round",
                3: "bevel"
            };
            function SVGShapeData(transformers, level, shape) {
                this.caches = [];
                this.styles = [];
                this.transformers = transformers;
                this.lStr = "";
                this.sh = shape;
                this.lvl = level;
                this._isAnimated = !!shape.k;
                var i = 0;
                var len = transformers.length;
                while (i < len) {
                    if (transformers[i].mProps.dynamicProperties.length) {
                        this._isAnimated = true;
                        break;
                    }
                    i += 1;
                }
            }
            SVGShapeData.prototype.setAsAnimated = function() {
                this._isAnimated = true;
            };
            function SVGStyleData(data, level) {
                this.data = data;
                this.type = data.ty;
                this.d = "";
                this.lvl = level;
                this._mdf = false;
                this.closed = data.hd === true;
                this.pElem = createNS("path");
                this.msElem = null;
            }
            SVGStyleData.prototype.reset = function() {
                this.d = "";
                this._mdf = false;
            };
            function DashProperty(elem, data, renderer, container) {
                this.elem = elem;
                this.frameId = -1;
                this.dataProps = createSizedArray(data.length);
                this.renderer = renderer;
                this.k = false;
                this.dashStr = "";
                this.dashArray = createTypedArray("float32", data.length ? data.length - 1 : 0);
                this.dashoffset = createTypedArray("float32", 1);
                this.initDynamicPropertyContainer(container);
                var i;
                var len = data.length || 0;
                var prop;
                for (i = 0; i < len; i += 1) {
                    prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
                    this.k = prop.k || this.k;
                    this.dataProps[i] = {
                        n: data[i].n,
                        p: prop
                    };
                }
                if (!this.k) this.getValue(true);
                this._isAnimated = this.k;
            }
            DashProperty.prototype.getValue = function(forceRender) {
                if (this.elem.globalData.frameId === this.frameId && !forceRender) return;
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                this._mdf = this._mdf || forceRender;
                if (this._mdf) {
                    var i = 0;
                    var len = this.dataProps.length;
                    if (this.renderer === "svg") this.dashStr = "";
                    for (i = 0; i < len; i += 1) if (this.dataProps[i].n !== "o") if (this.renderer === "svg") this.dashStr += " " + this.dataProps[i].p.v; else this.dashArray[i] = this.dataProps[i].p.v; else this.dashoffset[0] = this.dataProps[i].p.v;
                }
            };
            extendPrototype([ DynamicPropertyContainer ], DashProperty);
            function SVGStrokeStyleData(elem, data, styleOb) {
                this.initDynamicPropertyContainer(elem);
                this.getValue = this.iterateDynamicProperties;
                this.o = PropertyFactory.getProp(elem, data.o, 0, .01, this);
                this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
                this.d = new DashProperty(elem, data.d || {}, "svg", this);
                this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
                this.style = styleOb;
                this._isAnimated = !!this._isAnimated;
            }
            extendPrototype([ DynamicPropertyContainer ], SVGStrokeStyleData);
            function SVGFillStyleData(elem, data, styleOb) {
                this.initDynamicPropertyContainer(elem);
                this.getValue = this.iterateDynamicProperties;
                this.o = PropertyFactory.getProp(elem, data.o, 0, .01, this);
                this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
                this.style = styleOb;
            }
            extendPrototype([ DynamicPropertyContainer ], SVGFillStyleData);
            function SVGNoStyleData(elem, data, styleOb) {
                this.initDynamicPropertyContainer(elem);
                this.getValue = this.iterateDynamicProperties;
                this.style = styleOb;
            }
            extendPrototype([ DynamicPropertyContainer ], SVGNoStyleData);
            function GradientProperty(elem, data, container) {
                this.data = data;
                this.c = createTypedArray("uint8c", data.p * 4);
                var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
                this.o = createTypedArray("float32", cLength);
                this._cmdf = false;
                this._omdf = false;
                this._collapsable = this.checkCollapsable();
                this._hasOpacity = cLength;
                this.initDynamicPropertyContainer(container);
                this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
                this.k = this.prop.k;
                this.getValue(true);
            }
            GradientProperty.prototype.comparePoints = function(values, points) {
                var i = 0;
                var len = this.o.length / 2;
                var diff;
                while (i < len) {
                    diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
                    if (diff > .01) return false;
                    i += 1;
                }
                return true;
            };
            GradientProperty.prototype.checkCollapsable = function() {
                if (this.o.length / 2 !== this.c.length / 4) return false;
                if (this.data.k.k[0].s) {
                    var i = 0;
                    var len = this.data.k.k.length;
                    while (i < len) {
                        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) return false;
                        i += 1;
                    }
                } else if (!this.comparePoints(this.data.k.k, this.data.p)) return false;
                return true;
            };
            GradientProperty.prototype.getValue = function(forceRender) {
                this.prop.getValue();
                this._mdf = false;
                this._cmdf = false;
                this._omdf = false;
                if (this.prop._mdf || forceRender) {
                    var i;
                    var len = this.data.p * 4;
                    var mult;
                    var val;
                    for (i = 0; i < len; i += 1) {
                        mult = i % 4 === 0 ? 100 : 255;
                        val = Math.round(this.prop.v[i] * mult);
                        if (this.c[i] !== val) {
                            this.c[i] = val;
                            this._cmdf = !forceRender;
                        }
                    }
                    if (this.o.length) {
                        len = this.prop.v.length;
                        for (i = this.data.p * 4; i < len; i += 1) {
                            mult = i % 2 === 0 ? 100 : 1;
                            val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
                            if (this.o[i - this.data.p * 4] !== val) {
                                this.o[i - this.data.p * 4] = val;
                                this._omdf = !forceRender;
                            }
                        }
                    }
                    this._mdf = !forceRender;
                }
            };
            extendPrototype([ DynamicPropertyContainer ], GradientProperty);
            function SVGGradientFillStyleData(elem, data, styleOb) {
                this.initDynamicPropertyContainer(elem);
                this.getValue = this.iterateDynamicProperties;
                this.initGradientData(elem, data, styleOb);
            }
            SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {
                this.o = PropertyFactory.getProp(elem, data.o, 0, .01, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
                this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
                this.h = PropertyFactory.getProp(elem, data.h || {
                    k: 0
                }, 0, .01, this);
                this.a = PropertyFactory.getProp(elem, data.a || {
                    k: 0
                }, 0, degToRads, this);
                this.g = new GradientProperty(elem, data.g, this);
                this.style = styleOb;
                this.stops = [];
                this.setGradientData(styleOb.pElem, data);
                this.setGradientOpacity(data, styleOb);
                this._isAnimated = !!this._isAnimated;
            };
            SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {
                var gradientId = createElementID();
                var gfill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
                gfill.setAttribute("id", gradientId);
                gfill.setAttribute("spreadMethod", "pad");
                gfill.setAttribute("gradientUnits", "userSpaceOnUse");
                var stops = [];
                var stop;
                var j;
                var jLen;
                jLen = data.g.p * 4;
                for (j = 0; j < jLen; j += 4) {
                    stop = createNS("stop");
                    gfill.appendChild(stop);
                    stops.push(stop);
                }
                pathElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
                this.gf = gfill;
                this.cst = stops;
            };
            SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {
                if (this.g._hasOpacity && !this.g._collapsable) {
                    var stop;
                    var j;
                    var jLen;
                    var mask = createNS("mask");
                    var maskElement = createNS("path");
                    mask.appendChild(maskElement);
                    var opacityId = createElementID();
                    var maskId = createElementID();
                    mask.setAttribute("id", maskId);
                    var opFill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
                    opFill.setAttribute("id", opacityId);
                    opFill.setAttribute("spreadMethod", "pad");
                    opFill.setAttribute("gradientUnits", "userSpaceOnUse");
                    jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
                    var stops = this.stops;
                    for (j = data.g.p * 4; j < jLen; j += 2) {
                        stop = createNS("stop");
                        stop.setAttribute("stop-color", "rgb(255,255,255)");
                        opFill.appendChild(stop);
                        stops.push(stop);
                    }
                    maskElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
                    if (data.ty === "gs") {
                        maskElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
                        maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
                        if (data.lj === 1) maskElement.setAttribute("stroke-miterlimit", data.ml);
                    }
                    this.of = opFill;
                    this.ms = mask;
                    this.ost = stops;
                    this.maskId = maskId;
                    styleOb.msElem = maskElement;
                }
            };
            extendPrototype([ DynamicPropertyContainer ], SVGGradientFillStyleData);
            function SVGGradientStrokeStyleData(elem, data, styleOb) {
                this.initDynamicPropertyContainer(elem);
                this.getValue = this.iterateDynamicProperties;
                this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
                this.d = new DashProperty(elem, data.d || {}, "svg", this);
                this.initGradientData(elem, data, styleOb);
                this._isAnimated = !!this._isAnimated;
            }
            extendPrototype([ SVGGradientFillStyleData, DynamicPropertyContainer ], SVGGradientStrokeStyleData);
            function ShapeGroupData() {
                this.it = [];
                this.prevViewData = [];
                this.gr = createNS("g");
            }
            function SVGTransformData(mProps, op, container) {
                this.transform = {
                    mProps,
                    op,
                    container
                };
                this.elements = [];
                this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
            }
            const buildShapeString = function(pathNodes, length, closed, mat) {
                if (length === 0) return "";
                var _o = pathNodes.o;
                var _i = pathNodes.i;
                var _v = pathNodes.v;
                var i;
                var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
                for (i = 1; i < length; i += 1) shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
                if (closed && length) {
                    shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
                    shapeString += "z";
                }
                return shapeString;
            };
            const SVGElementsRenderer = function() {
                var _identityMatrix = new Matrix;
                var _matrixHelper = new Matrix;
                var ob = {
                    createRenderFunction
                };
                function createRenderFunction(data) {
                    switch (data.ty) {
                      case "fl":
                        return renderFill;

                      case "gf":
                        return renderGradient;

                      case "gs":
                        return renderGradientStroke;

                      case "st":
                        return renderStroke;

                      case "sh":
                      case "el":
                      case "rc":
                      case "sr":
                        return renderPath;

                      case "tr":
                        return renderContentTransform;

                      case "no":
                        return renderNoop;

                      default:
                        return null;
                    }
                }
                function renderContentTransform(styleData, itemData, isFirstFrame) {
                    if (isFirstFrame || itemData.transform.op._mdf) itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
                    if (isFirstFrame || itemData.transform.mProps._mdf) itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
                }
                function renderNoop() {}
                function renderPath(styleData, itemData, isFirstFrame) {
                    var j;
                    var jLen;
                    var pathStringTransformed;
                    var redraw;
                    var pathNodes;
                    var l;
                    var lLen = itemData.styles.length;
                    var lvl = itemData.lvl;
                    var paths;
                    var mat;
                    var iterations;
                    var k;
                    for (l = 0; l < lLen; l += 1) {
                        redraw = itemData.sh._mdf || isFirstFrame;
                        if (itemData.styles[l].lvl < lvl) {
                            mat = _matrixHelper.reset();
                            iterations = lvl - itemData.styles[l].lvl;
                            k = itemData.transformers.length - 1;
                            while (!redraw && iterations > 0) {
                                redraw = itemData.transformers[k].mProps._mdf || redraw;
                                iterations -= 1;
                                k -= 1;
                            }
                            if (redraw) {
                                iterations = lvl - itemData.styles[l].lvl;
                                k = itemData.transformers.length - 1;
                                while (iterations > 0) {
                                    mat.multiply(itemData.transformers[k].mProps.v);
                                    iterations -= 1;
                                    k -= 1;
                                }
                            }
                        } else mat = _identityMatrix;
                        paths = itemData.sh.paths;
                        jLen = paths._length;
                        if (redraw) {
                            pathStringTransformed = "";
                            for (j = 0; j < jLen; j += 1) {
                                pathNodes = paths.shapes[j];
                                if (pathNodes && pathNodes._length) pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                            }
                            itemData.caches[l] = pathStringTransformed;
                        } else pathStringTransformed = itemData.caches[l];
                        itemData.styles[l].d += styleData.hd === true ? "" : pathStringTransformed;
                        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
                    }
                }
                function renderFill(styleData, itemData, isFirstFrame) {
                    var styleElem = itemData.style;
                    if (itemData.c._mdf || isFirstFrame) styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
                    if (itemData.o._mdf || isFirstFrame) styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
                }
                function renderGradientStroke(styleData, itemData, isFirstFrame) {
                    renderGradient(styleData, itemData, isFirstFrame);
                    renderStroke(styleData, itemData, isFirstFrame);
                }
                function renderGradient(styleData, itemData, isFirstFrame) {
                    var gfill = itemData.gf;
                    var hasOpacity = itemData.g._hasOpacity;
                    var pt1 = itemData.s.v;
                    var pt2 = itemData.e.v;
                    if (itemData.o._mdf || isFirstFrame) {
                        var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                        itemData.style.pElem.setAttribute(attr, itemData.o.v);
                    }
                    if (itemData.s._mdf || isFirstFrame) {
                        var attr1 = styleData.t === 1 ? "x1" : "cx";
                        var attr2 = attr1 === "x1" ? "y1" : "cy";
                        gfill.setAttribute(attr1, pt1[0]);
                        gfill.setAttribute(attr2, pt1[1]);
                        if (hasOpacity && !itemData.g._collapsable) {
                            itemData.of.setAttribute(attr1, pt1[0]);
                            itemData.of.setAttribute(attr2, pt1[1]);
                        }
                    }
                    var stops;
                    var i;
                    var len;
                    var stop;
                    if (itemData.g._cmdf || isFirstFrame) {
                        stops = itemData.cst;
                        var cValues = itemData.g.c;
                        len = stops.length;
                        for (i = 0; i < len; i += 1) {
                            stop = stops[i];
                            stop.setAttribute("offset", cValues[i * 4] + "%");
                            stop.setAttribute("stop-color", "rgb(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + ")");
                        }
                    }
                    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
                        var oValues = itemData.g.o;
                        if (itemData.g._collapsable) stops = itemData.cst; else stops = itemData.ost;
                        len = stops.length;
                        for (i = 0; i < len; i += 1) {
                            stop = stops[i];
                            if (!itemData.g._collapsable) stop.setAttribute("offset", oValues[i * 2] + "%");
                            stop.setAttribute("stop-opacity", oValues[i * 2 + 1]);
                        }
                    }
                    if (styleData.t === 1) {
                        if (itemData.e._mdf || isFirstFrame) {
                            gfill.setAttribute("x2", pt2[0]);
                            gfill.setAttribute("y2", pt2[1]);
                            if (hasOpacity && !itemData.g._collapsable) {
                                itemData.of.setAttribute("x2", pt2[0]);
                                itemData.of.setAttribute("y2", pt2[1]);
                            }
                        }
                    } else {
                        var rad;
                        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                            gfill.setAttribute("r", rad);
                            if (hasOpacity && !itemData.g._collapsable) itemData.of.setAttribute("r", rad);
                        }
                        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                            if (!rad) rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                            var percent = itemData.h.v;
                            if (percent >= 1) percent = .99; else if (percent <= -1) percent = -.99;
                            var dist = rad * percent;
                            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                            gfill.setAttribute("fx", x);
                            gfill.setAttribute("fy", y);
                            if (hasOpacity && !itemData.g._collapsable) {
                                itemData.of.setAttribute("fx", x);
                                itemData.of.setAttribute("fy", y);
                            }
                        }
                    }
                }
                function renderStroke(styleData, itemData, isFirstFrame) {
                    var styleElem = itemData.style;
                    var d = itemData.d;
                    if (d && (d._mdf || isFirstFrame) && d.dashStr) {
                        styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
                        styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0]);
                    }
                    if (itemData.c && (itemData.c._mdf || isFirstFrame)) styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
                    if (itemData.o._mdf || isFirstFrame) styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
                    if (itemData.w._mdf || isFirstFrame) {
                        styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
                        if (styleElem.msElem) styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
                    }
                }
                return ob;
            }();
            function SVGShapeElement(data, globalData, comp) {
                this.shapes = [];
                this.shapesData = data.shapes;
                this.stylesList = [];
                this.shapeModifiers = [];
                this.itemsData = [];
                this.processedElements = [];
                this.animatedContents = [];
                this.initElement(data, globalData, comp);
                this.prevViewData = [];
            }
            extendPrototype([ BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement ], SVGShapeElement);
            SVGShapeElement.prototype.initSecondaryElement = function() {};
            SVGShapeElement.prototype.identityMatrix = new Matrix;
            SVGShapeElement.prototype.buildExpressionInterface = function() {};
            SVGShapeElement.prototype.createContent = function() {
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
                this.filterUniqueShapes();
            };
            SVGShapeElement.prototype.filterUniqueShapes = function() {
                var i;
                var len = this.shapes.length;
                var shape;
                var j;
                var jLen = this.stylesList.length;
                var style;
                var tempShapes = [];
                var areAnimated = false;
                for (j = 0; j < jLen; j += 1) {
                    style = this.stylesList[j];
                    areAnimated = false;
                    tempShapes.length = 0;
                    for (i = 0; i < len; i += 1) {
                        shape = this.shapes[i];
                        if (shape.styles.indexOf(style) !== -1) {
                            tempShapes.push(shape);
                            areAnimated = shape._isAnimated || areAnimated;
                        }
                    }
                    if (tempShapes.length > 1 && areAnimated) this.setShapesAsAnimated(tempShapes);
                }
            };
            SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
                var i;
                var len = shapes.length;
                for (i = 0; i < len; i += 1) shapes[i].setAsAnimated();
            };
            SVGShapeElement.prototype.createStyleElement = function(data, level) {
                var elementData;
                var styleOb = new SVGStyleData(data, level);
                var pathElement = styleOb.pElem;
                if (data.ty === "st") elementData = new SVGStrokeStyleData(this, data, styleOb); else if (data.ty === "fl") elementData = new SVGFillStyleData(this, data, styleOb); else if (data.ty === "gf" || data.ty === "gs") {
                    var GradientConstructor = data.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
                    elementData = new GradientConstructor(this, data, styleOb);
                    this.globalData.defs.appendChild(elementData.gf);
                    if (elementData.maskId) {
                        this.globalData.defs.appendChild(elementData.ms);
                        this.globalData.defs.appendChild(elementData.of);
                        pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
                    }
                } else if (data.ty === "no") elementData = new SVGNoStyleData(this, data, styleOb);
                if (data.ty === "st" || data.ty === "gs") {
                    pathElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
                    pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
                    pathElement.setAttribute("fill-opacity", "0");
                    if (data.lj === 1) pathElement.setAttribute("stroke-miterlimit", data.ml);
                }
                if (data.r === 2) pathElement.setAttribute("fill-rule", "evenodd");
                if (data.ln) pathElement.setAttribute("id", data.ln);
                if (data.cl) pathElement.setAttribute("class", data.cl);
                if (data.bm) pathElement.style["mix-blend-mode"] = getBlendMode(data.bm);
                this.stylesList.push(styleOb);
                this.addToAnimatedContents(data, elementData);
                return elementData;
            };
            SVGShapeElement.prototype.createGroupElement = function(data) {
                var elementData = new ShapeGroupData;
                if (data.ln) elementData.gr.setAttribute("id", data.ln);
                if (data.cl) elementData.gr.setAttribute("class", data.cl);
                if (data.bm) elementData.gr.style["mix-blend-mode"] = getBlendMode(data.bm);
                return elementData;
            };
            SVGShapeElement.prototype.createTransformElement = function(data, container) {
                var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
                var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
                this.addToAnimatedContents(data, elementData);
                return elementData;
            };
            SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
                var ty = 4;
                if (data.ty === "rc") ty = 5; else if (data.ty === "el") ty = 6; else if (data.ty === "sr") ty = 7;
                var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
                var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
                this.shapes.push(elementData);
                this.addShapeToModifiers(elementData);
                this.addToAnimatedContents(data, elementData);
                return elementData;
            };
            SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
                var i = 0;
                var len = this.animatedContents.length;
                while (i < len) {
                    if (this.animatedContents[i].element === element) return;
                    i += 1;
                }
                this.animatedContents.push({
                    fn: SVGElementsRenderer.createRenderFunction(data),
                    element,
                    data
                });
            };
            SVGShapeElement.prototype.setElementStyles = function(elementData) {
                var arr = elementData.styles;
                var j;
                var jLen = this.stylesList.length;
                for (j = 0; j < jLen; j += 1) if (!this.stylesList[j].closed) arr.push(this.stylesList[j]);
            };
            SVGShapeElement.prototype.reloadShapes = function() {
                this._isFirstFrame = true;
                var i;
                var len = this.itemsData.length;
                for (i = 0; i < len; i += 1) this.prevViewData[i] = this.itemsData[i];
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
                this.filterUniqueShapes();
                len = this.dynamicProperties.length;
                for (i = 0; i < len; i += 1) this.dynamicProperties[i].getValue();
                this.renderModifiers();
            };
            SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
                var ownTransformers = [].concat(transformers);
                var i;
                var len = arr.length - 1;
                var j;
                var jLen;
                var ownStyles = [];
                var ownModifiers = [];
                var currentTransform;
                var modifier;
                var processedPos;
                for (i = len; i >= 0; i -= 1) {
                    processedPos = this.searchProcessedElement(arr[i]);
                    if (!processedPos) arr[i]._render = render; else itemsData[i] = prevViewData[processedPos - 1];
                    if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs" || arr[i].ty === "no") {
                        if (!processedPos) itemsData[i] = this.createStyleElement(arr[i], level); else itemsData[i].style.closed = false;
                        if (arr[i]._render) if (itemsData[i].style.pElem.parentNode !== container) container.appendChild(itemsData[i].style.pElem);
                        ownStyles.push(itemsData[i].style);
                    } else if (arr[i].ty === "gr") {
                        if (!processedPos) itemsData[i] = this.createGroupElement(arr[i]); else {
                            jLen = itemsData[i].it.length;
                            for (j = 0; j < jLen; j += 1) itemsData[i].prevViewData[j] = itemsData[i].it[j];
                        }
                        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
                        if (arr[i]._render) if (itemsData[i].gr.parentNode !== container) container.appendChild(itemsData[i].gr);
                    } else if (arr[i].ty === "tr") {
                        if (!processedPos) itemsData[i] = this.createTransformElement(arr[i], container);
                        currentTransform = itemsData[i].transform;
                        ownTransformers.push(currentTransform);
                    } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
                        if (!processedPos) itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
                        this.setElementStyles(itemsData[i]);
                    } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "ms" || arr[i].ty === "pb" || arr[i].ty === "zz" || arr[i].ty === "op") {
                        if (!processedPos) {
                            modifier = ShapeModifiers.getModifier(arr[i].ty);
                            modifier.init(this, arr[i]);
                            itemsData[i] = modifier;
                            this.shapeModifiers.push(modifier);
                        } else {
                            modifier = itemsData[i];
                            modifier.closed = false;
                        }
                        ownModifiers.push(modifier);
                    } else if (arr[i].ty === "rp") {
                        if (!processedPos) {
                            modifier = ShapeModifiers.getModifier(arr[i].ty);
                            itemsData[i] = modifier;
                            modifier.init(this, arr, i, itemsData);
                            this.shapeModifiers.push(modifier);
                            render = false;
                        } else {
                            modifier = itemsData[i];
                            modifier.closed = true;
                        }
                        ownModifiers.push(modifier);
                    }
                    this.addProcessedElement(arr[i], i + 1);
                }
                len = ownStyles.length;
                for (i = 0; i < len; i += 1) ownStyles[i].closed = true;
                len = ownModifiers.length;
                for (i = 0; i < len; i += 1) ownModifiers[i].closed = true;
            };
            SVGShapeElement.prototype.renderInnerContent = function() {
                this.renderModifiers();
                var i;
                var len = this.stylesList.length;
                for (i = 0; i < len; i += 1) this.stylesList[i].reset();
                this.renderShape();
                for (i = 0; i < len; i += 1) if (this.stylesList[i]._mdf || this._isFirstFrame) {
                    if (this.stylesList[i].msElem) {
                        this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d);
                        this.stylesList[i].d = "M0 0" + this.stylesList[i].d;
                    }
                    this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0");
                }
            };
            SVGShapeElement.prototype.renderShape = function() {
                var i;
                var len = this.animatedContents.length;
                var animatedContent;
                for (i = 0; i < len; i += 1) {
                    animatedContent = this.animatedContents[i];
                    if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
                }
            };
            SVGShapeElement.prototype.destroy = function() {
                this.destroyBaseElement();
                this.shapesData = null;
                this.itemsData = null;
            };
            function LetterProps(o, sw, sc, fc, m, p) {
                this.o = o;
                this.sw = sw;
                this.sc = sc;
                this.fc = fc;
                this.m = m;
                this.p = p;
                this._mdf = {
                    o: true,
                    sw: !!sw,
                    sc: !!sc,
                    fc: !!fc,
                    m: true,
                    p: true
                };
            }
            LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
                this._mdf.o = false;
                this._mdf.sw = false;
                this._mdf.sc = false;
                this._mdf.fc = false;
                this._mdf.m = false;
                this._mdf.p = false;
                var updated = false;
                if (this.o !== o) {
                    this.o = o;
                    this._mdf.o = true;
                    updated = true;
                }
                if (this.sw !== sw) {
                    this.sw = sw;
                    this._mdf.sw = true;
                    updated = true;
                }
                if (this.sc !== sc) {
                    this.sc = sc;
                    this._mdf.sc = true;
                    updated = true;
                }
                if (this.fc !== fc) {
                    this.fc = fc;
                    this._mdf.fc = true;
                    updated = true;
                }
                if (this.m !== m) {
                    this.m = m;
                    this._mdf.m = true;
                    updated = true;
                }
                if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
                    this.p = p;
                    this._mdf.p = true;
                    updated = true;
                }
                return updated;
            };
            function TextProperty(elem, data) {
                this._frameId = initialDefaultFrame;
                this.pv = "";
                this.v = "";
                this.kf = false;
                this._isFirstFrame = true;
                this._mdf = false;
                if (data.d && data.d.sid) data.d = elem.globalData.slotManager.getProp(data.d);
                this.data = data;
                this.elem = elem;
                this.comp = this.elem.comp;
                this.keysIndex = 0;
                this.canResize = false;
                this.minimumFontSize = 1;
                this.effectsSequence = [];
                this.currentData = {
                    ascent: 0,
                    boxWidth: this.defaultBoxWidth,
                    f: "",
                    fStyle: "",
                    fWeight: "",
                    fc: "",
                    j: "",
                    justifyOffset: "",
                    l: [],
                    lh: 0,
                    lineWidths: [],
                    ls: "",
                    of: "",
                    s: "",
                    sc: "",
                    sw: 0,
                    t: 0,
                    tr: 0,
                    sz: 0,
                    ps: null,
                    fillColorAnim: false,
                    strokeColorAnim: false,
                    strokeWidthAnim: false,
                    yOffset: 0,
                    finalSize: 0,
                    finalText: [],
                    finalLineHeight: 0,
                    __complete: false
                };
                this.copyData(this.currentData, this.data.d.k[0].s);
                if (!this.searchProperty()) this.completeTextData(this.currentData);
            }
            TextProperty.prototype.defaultBoxWidth = [ 0, 0 ];
            TextProperty.prototype.copyData = function(obj, data) {
                for (var s in data) if (Object.prototype.hasOwnProperty.call(data, s)) obj[s] = data[s];
                return obj;
            };
            TextProperty.prototype.setCurrentData = function(data) {
                if (!data.__complete) this.completeTextData(data);
                this.currentData = data;
                this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
                this._mdf = true;
            };
            TextProperty.prototype.searchProperty = function() {
                return this.searchKeyframes();
            };
            TextProperty.prototype.searchKeyframes = function() {
                this.kf = this.data.d.k.length > 1;
                if (this.kf) this.addEffect(this.getKeyframeValue.bind(this));
                return this.kf;
            };
            TextProperty.prototype.addEffect = function(effectFunction) {
                this.effectsSequence.push(effectFunction);
                this.elem.addDynamicProperty(this);
            };
            TextProperty.prototype.getValue = function(_finalValue) {
                if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) return;
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var currentValue = this.currentData;
                var currentIndex = this.keysIndex;
                if (this.lock) {
                    this.setCurrentData(this.currentData);
                    return;
                }
                this.lock = true;
                this._mdf = false;
                var i;
                var len = this.effectsSequence.length;
                var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
                for (i = 0; i < len; i += 1) if (currentIndex !== this.keysIndex) finalValue = this.effectsSequence[i](finalValue, finalValue.t); else finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
                if (currentValue !== finalValue) this.setCurrentData(finalValue);
                this.v = this.currentData;
                this.pv = this.v;
                this.lock = false;
                this.frameId = this.elem.globalData.frameId;
            };
            TextProperty.prototype.getKeyframeValue = function() {
                var textKeys = this.data.d.k;
                var frameNum = this.elem.comp.renderedFrame;
                var i = 0;
                var len = textKeys.length;
                while (i <= len - 1) {
                    if (i === len - 1 || textKeys[i + 1].t > frameNum) break;
                    i += 1;
                }
                if (this.keysIndex !== i) this.keysIndex = i;
                return this.data.d.k[this.keysIndex].s;
            };
            TextProperty.prototype.buildFinalText = function(text) {
                var charactersArray = [];
                var i = 0;
                var len = text.length;
                var charCode;
                var secondCharCode;
                var shouldCombine = false;
                var shouldCombineNext = false;
                var currentChars = "";
                while (i < len) {
                    shouldCombine = shouldCombineNext;
                    shouldCombineNext = false;
                    charCode = text.charCodeAt(i);
                    currentChars = text.charAt(i);
                    if (FontManager.isCombinedCharacter(charCode)) shouldCombine = true; else if (charCode >= 55296 && charCode <= 56319) if (FontManager.isRegionalFlag(text, i)) currentChars = text.substr(i, 14); else {
                        secondCharCode = text.charCodeAt(i + 1);
                        if (secondCharCode >= 56320 && secondCharCode <= 57343) if (FontManager.isModifier(charCode, secondCharCode)) {
                            currentChars = text.substr(i, 2);
                            shouldCombine = true;
                        } else if (FontManager.isFlagEmoji(text.substr(i, 4))) currentChars = text.substr(i, 4); else currentChars = text.substr(i, 2);
                    } else if (charCode > 56319) {
                        secondCharCode = text.charCodeAt(i + 1);
                        if (FontManager.isVariationSelector(charCode)) shouldCombine = true;
                    } else if (FontManager.isZeroWidthJoiner(charCode)) {
                        shouldCombine = true;
                        shouldCombineNext = true;
                    }
                    if (shouldCombine) {
                        charactersArray[charactersArray.length - 1] += currentChars;
                        shouldCombine = false;
                    } else charactersArray.push(currentChars);
                    i += currentChars.length;
                }
                return charactersArray;
            };
            TextProperty.prototype.completeTextData = function(documentData) {
                documentData.__complete = true;
                var fontManager = this.elem.globalData.fontManager;
                var data = this.data;
                var letters = [];
                var i;
                var len;
                var newLineFlag;
                var index = 0;
                var val;
                var anchorGrouping = data.m.g;
                var currentSize = 0;
                var currentPos = 0;
                var currentLine = 0;
                var lineWidths = [];
                var lineWidth = 0;
                var maxLineWidth = 0;
                var j;
                var jLen;
                var fontData = fontManager.getFontByName(documentData.f);
                var charData;
                var cLength = 0;
                var fontProps = getFontProperties(fontData);
                documentData.fWeight = fontProps.weight;
                documentData.fStyle = fontProps.style;
                documentData.finalSize = documentData.s;
                documentData.finalText = this.buildFinalText(documentData.t);
                len = documentData.finalText.length;
                documentData.finalLineHeight = documentData.lh;
                var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
                var charCode;
                if (documentData.sz) {
                    var flag = true;
                    var boxWidth = documentData.sz[0];
                    var boxHeight = documentData.sz[1];
                    var currentHeight;
                    var finalText;
                    while (flag) {
                        finalText = this.buildFinalText(documentData.t);
                        currentHeight = 0;
                        lineWidth = 0;
                        len = finalText.length;
                        trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
                        var lastSpaceIndex = -1;
                        for (i = 0; i < len; i += 1) {
                            charCode = finalText[i].charCodeAt(0);
                            newLineFlag = false;
                            if (finalText[i] === " ") lastSpaceIndex = i; else if (charCode === 13 || charCode === 3) {
                                lineWidth = 0;
                                newLineFlag = true;
                                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                            }
                            if (fontManager.chars) {
                                charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
                                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                            } else cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
                            if (lineWidth + cLength > boxWidth && finalText[i] !== " ") {
                                if (lastSpaceIndex === -1) len += 1; else i = lastSpaceIndex;
                                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                                finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r");
                                lastSpaceIndex = -1;
                                lineWidth = 0;
                            } else {
                                lineWidth += cLength;
                                lineWidth += trackingOffset;
                            }
                        }
                        currentHeight += fontData.ascent * documentData.finalSize / 100;
                        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                            documentData.finalSize -= 1;
                            documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
                        } else {
                            documentData.finalText = finalText;
                            len = documentData.finalText.length;
                            flag = false;
                        }
                    }
                }
                lineWidth = -trackingOffset;
                cLength = 0;
                var uncollapsedSpaces = 0;
                var currentChar;
                for (i = 0; i < len; i += 1) {
                    newLineFlag = false;
                    currentChar = documentData.finalText[i];
                    charCode = currentChar.charCodeAt(0);
                    if (charCode === 13 || charCode === 3) {
                        uncollapsedSpaces = 0;
                        lineWidths.push(lineWidth);
                        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                        lineWidth = -2 * trackingOffset;
                        val = "";
                        newLineFlag = true;
                        currentLine += 1;
                    } else val = currentChar;
                    if (fontManager.chars) {
                        charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
                        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                    } else cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
                    if (currentChar === " ") uncollapsedSpaces += cLength + trackingOffset; else {
                        lineWidth += cLength + trackingOffset + uncollapsedSpaces;
                        uncollapsedSpaces = 0;
                    }
                    letters.push({
                        l: cLength,
                        an: cLength,
                        add: currentSize,
                        n: newLineFlag,
                        anIndexes: [],
                        val,
                        line: currentLine,
                        animatorJustifyOffset: 0
                    });
                    if (anchorGrouping == 2) {
                        currentSize += cLength;
                        if (val === "" || val === " " || i === len - 1) {
                            if (val === "" || val === " ") currentSize -= cLength;
                            while (currentPos <= i) {
                                letters[currentPos].an = currentSize;
                                letters[currentPos].ind = index;
                                letters[currentPos].extra = cLength;
                                currentPos += 1;
                            }
                            index += 1;
                            currentSize = 0;
                        }
                    } else if (anchorGrouping == 3) {
                        currentSize += cLength;
                        if (val === "" || i === len - 1) {
                            if (val === "") currentSize -= cLength;
                            while (currentPos <= i) {
                                letters[currentPos].an = currentSize;
                                letters[currentPos].ind = index;
                                letters[currentPos].extra = cLength;
                                currentPos += 1;
                            }
                            currentSize = 0;
                            index += 1;
                        }
                    } else {
                        letters[index].ind = index;
                        letters[index].extra = 0;
                        index += 1;
                    }
                }
                documentData.l = letters;
                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                lineWidths.push(lineWidth);
                if (documentData.sz) {
                    documentData.boxWidth = documentData.sz[0];
                    documentData.justifyOffset = 0;
                } else {
                    documentData.boxWidth = maxLineWidth;
                    switch (documentData.j) {
                      case 1:
                        documentData.justifyOffset = -documentData.boxWidth;
                        break;

                      case 2:
                        documentData.justifyOffset = -documentData.boxWidth / 2;
                        break;

                      default:
                        documentData.justifyOffset = 0;
                    }
                }
                documentData.lineWidths = lineWidths;
                var animators = data.a;
                var animatorData;
                var letterData;
                jLen = animators.length;
                var based;
                var ind;
                var indexes = [];
                for (j = 0; j < jLen; j += 1) {
                    animatorData = animators[j];
                    if (animatorData.a.sc) documentData.strokeColorAnim = true;
                    if (animatorData.a.sw) documentData.strokeWidthAnim = true;
                    if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) documentData.fillColorAnim = true;
                    ind = 0;
                    based = animatorData.s.b;
                    for (i = 0; i < len; i += 1) {
                        letterData = letters[i];
                        letterData.anIndexes[j] = ind;
                        if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
                            if (animatorData.s.rn === 1) indexes.push(ind);
                            ind += 1;
                        }
                    }
                    data.a[j].s.totalChars = ind;
                    var currentInd = -1;
                    var newInd;
                    if (animatorData.s.rn === 1) for (i = 0; i < len; i += 1) {
                        letterData = letters[i];
                        if (currentInd != letterData.anIndexes[j]) {
                            currentInd = letterData.anIndexes[j];
                            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                        }
                        letterData.anIndexes[j] = newInd;
                    }
                }
                documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
                documentData.ls = documentData.ls || 0;
                documentData.ascent = fontData.ascent * documentData.finalSize / 100;
            };
            TextProperty.prototype.updateDocumentData = function(newData, index) {
                index = index === void 0 ? this.keysIndex : index;
                var dData = this.copyData({}, this.data.d.k[index].s);
                dData = this.copyData(dData, newData);
                this.data.d.k[index].s = dData;
                this.recalculate(index);
                this.setCurrentData(dData);
                this.elem.addDynamicProperty(this);
            };
            TextProperty.prototype.recalculate = function(index) {
                var dData = this.data.d.k[index].s;
                dData.__complete = false;
                this.keysIndex = 0;
                this._isFirstFrame = true;
                this.getValue(dData);
            };
            TextProperty.prototype.canResizeFont = function(_canResize) {
                this.canResize = _canResize;
                this.recalculate(this.keysIndex);
                this.elem.addDynamicProperty(this);
            };
            TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
                this.minimumFontSize = Math.floor(_fontValue) || 1;
                this.recalculate(this.keysIndex);
                this.elem.addDynamicProperty(this);
            };
            const TextSelectorProp = function() {
                var max = Math.max;
                var min = Math.min;
                var floor = Math.floor;
                function TextSelectorPropFactory(elem, data) {
                    this._currentTextLength = -1;
                    this.k = false;
                    this.data = data;
                    this.elem = elem;
                    this.comp = elem.comp;
                    this.finalS = 0;
                    this.finalE = 0;
                    this.initDynamicPropertyContainer(elem);
                    this.s = PropertyFactory.getProp(elem, data.s || {
                        k: 0
                    }, 0, 0, this);
                    if ("e" in data) this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this); else this.e = {
                        v: 100
                    };
                    this.o = PropertyFactory.getProp(elem, data.o || {
                        k: 0
                    }, 0, 0, this);
                    this.xe = PropertyFactory.getProp(elem, data.xe || {
                        k: 0
                    }, 0, 0, this);
                    this.ne = PropertyFactory.getProp(elem, data.ne || {
                        k: 0
                    }, 0, 0, this);
                    this.sm = PropertyFactory.getProp(elem, data.sm || {
                        k: 100
                    }, 0, 0, this);
                    this.a = PropertyFactory.getProp(elem, data.a, 0, .01, this);
                    if (!this.dynamicProperties.length) this.getValue();
                }
                TextSelectorPropFactory.prototype = {
                    getMult: function(ind) {
                        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) this.getValue();
                        var x1 = 0;
                        var y1 = 0;
                        var x2 = 1;
                        var y2 = 1;
                        if (this.ne.v > 0) x1 = this.ne.v / 100; else y1 = -this.ne.v / 100;
                        if (this.xe.v > 0) x2 = 1 - this.xe.v / 100; else y2 = 1 + this.xe.v / 100;
                        var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
                        var mult = 0;
                        var s = this.finalS;
                        var e = this.finalE;
                        var type = this.data.sh;
                        if (type === 2) {
                            if (e === s) mult = ind >= e ? 1 : 0; else mult = max(0, min(.5 / (e - s) + (ind - s) / (e - s), 1));
                            mult = easer(mult);
                        } else if (type === 3) {
                            if (e === s) mult = ind >= e ? 0 : 1; else mult = 1 - max(0, min(.5 / (e - s) + (ind - s) / (e - s), 1));
                            mult = easer(mult);
                        } else if (type === 4) {
                            if (e === s) mult = 0; else {
                                mult = max(0, min(.5 / (e - s) + (ind - s) / (e - s), 1));
                                if (mult < .5) mult *= 2; else mult = 1 - 2 * (mult - .5);
                            }
                            mult = easer(mult);
                        } else if (type === 5) {
                            if (e === s) mult = 0; else {
                                var tot = e - s;
                                ind = min(max(0, ind + .5 - s), e - s);
                                var x = -tot / 2 + ind;
                                var a = tot / 2;
                                mult = Math.sqrt(1 - x * x / (a * a));
                            }
                            mult = easer(mult);
                        } else if (type === 6) {
                            if (e === s) mult = 0; else {
                                ind = min(max(0, ind + .5 - s), e - s);
                                mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2;
                            }
                            mult = easer(mult);
                        } else {
                            if (ind >= floor(s)) if (ind - s < 0) mult = max(0, min(min(e, 1) - (s - ind), 1)); else mult = max(0, min(e - ind, 1));
                            mult = easer(mult);
                        }
                        if (this.sm.v !== 100) {
                            var smoothness = this.sm.v * .01;
                            if (smoothness === 0) smoothness = 1e-8;
                            var threshold = .5 - smoothness * .5;
                            if (mult < threshold) mult = 0; else {
                                mult = (mult - threshold) / smoothness;
                                if (mult > 1) mult = 1;
                            }
                        }
                        return mult * this.a.v;
                    },
                    getValue: function(newCharsFlag) {
                        this.iterateDynamicProperties();
                        this._mdf = newCharsFlag || this._mdf;
                        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
                        if (newCharsFlag && this.data.r === 2) this.e.v = this._currentTextLength;
                        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
                        var o = this.o.v / divisor;
                        var s = this.s.v / divisor + o;
                        var e = this.e.v / divisor + o;
                        if (s > e) {
                            var _s = s;
                            s = e;
                            e = _s;
                        }
                        this.finalS = s;
                        this.finalE = e;
                    }
                };
                extendPrototype([ DynamicPropertyContainer ], TextSelectorPropFactory);
                function getTextSelectorProp(elem, data, arr) {
                    return new TextSelectorPropFactory(elem, data, arr);
                }
                return {
                    getTextSelectorProp
                };
            }();
            function TextAnimatorDataProperty(elem, animatorProps, container) {
                var defaultData = {
                    propType: false
                };
                var getProp = PropertyFactory.getProp;
                var textAnimatorAnimatables = animatorProps.a;
                this.a = {
                    r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
                    rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
                    ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
                    sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
                    sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
                    s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, .01, container) : defaultData,
                    a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
                    o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, .01, container) : defaultData,
                    p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
                    sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
                    sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
                    fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
                    fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
                    fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, .01, container) : defaultData,
                    fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, .01, container) : defaultData,
                    t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
                };
                this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
                this.s.t = animatorProps.s.t;
            }
            function TextAnimatorProperty(textData, renderType, elem) {
                this._isFirstFrame = true;
                this._hasMaskedPath = false;
                this._frameId = -1;
                this._textData = textData;
                this._renderType = renderType;
                this._elem = elem;
                this._animatorsData = createSizedArray(this._textData.a.length);
                this._pathData = {};
                this._moreOptions = {
                    alignment: {}
                };
                this.renderedLetters = [];
                this.lettersChangedFlag = false;
                this.initDynamicPropertyContainer(elem);
            }
            TextAnimatorProperty.prototype.searchProperties = function() {
                var i;
                var len = this._textData.a.length;
                var animatorProps;
                var getProp = PropertyFactory.getProp;
                for (i = 0; i < len; i += 1) {
                    animatorProps = this._textData.a[i];
                    this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
                }
                if (this._textData.p && "m" in this._textData.p) {
                    this._pathData = {
                        a: getProp(this._elem, this._textData.p.a, 0, 0, this),
                        f: getProp(this._elem, this._textData.p.f, 0, 0, this),
                        l: getProp(this._elem, this._textData.p.l, 0, 0, this),
                        r: getProp(this._elem, this._textData.p.r, 0, 0, this),
                        p: getProp(this._elem, this._textData.p.p, 0, 0, this),
                        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                    };
                    this._hasMaskedPath = true;
                } else this._hasMaskedPath = false;
                this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
            };
            TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
                this.lettersChangedFlag = lettersChangedFlag;
                if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) return;
                this._isFirstFrame = false;
                var alignment = this._moreOptions.alignment.v;
                var animators = this._animatorsData;
                var textData = this._textData;
                var matrixHelper = this.mHelper;
                var renderType = this._renderType;
                var renderedLettersCount = this.renderedLetters.length;
                var xPos;
                var yPos;
                var i;
                var len;
                var letters = documentData.l;
                var pathInfo;
                var currentLength;
                var currentPoint;
                var segmentLength;
                var flag;
                var pointInd;
                var segmentInd;
                var prevPoint;
                var points;
                var segments;
                var partialLength;
                var totalLength;
                var perc;
                var tanAngle;
                var mask;
                if (this._hasMaskedPath) {
                    mask = this._pathData.m;
                    if (!this._pathData.n || this._pathData._mdf) {
                        var paths = mask.v;
                        if (this._pathData.r.v) paths = paths.reverse();
                        pathInfo = {
                            tLength: 0,
                            segments: []
                        };
                        len = paths._length - 1;
                        var bezierData;
                        totalLength = 0;
                        for (i = 0; i < len; i += 1) {
                            bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [ paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1] ], [ paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1] ]);
                            pathInfo.tLength += bezierData.segmentLength;
                            pathInfo.segments.push(bezierData);
                            totalLength += bezierData.segmentLength;
                        }
                        i = len;
                        if (mask.v.c) {
                            bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [ paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1] ], [ paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1] ]);
                            pathInfo.tLength += bezierData.segmentLength;
                            pathInfo.segments.push(bezierData);
                            totalLength += bezierData.segmentLength;
                        }
                        this._pathData.pi = pathInfo;
                    }
                    pathInfo = this._pathData.pi;
                    currentLength = this._pathData.f.v;
                    segmentInd = 0;
                    pointInd = 1;
                    segmentLength = 0;
                    flag = true;
                    segments = pathInfo.segments;
                    if (currentLength < 0 && mask.v.c) {
                        if (pathInfo.tLength < Math.abs(currentLength)) currentLength = -Math.abs(currentLength) % pathInfo.tLength;
                        segmentInd = segments.length - 1;
                        points = segments[segmentInd].points;
                        pointInd = points.length - 1;
                        while (currentLength < 0) {
                            currentLength += points[pointInd].partialLength;
                            pointInd -= 1;
                            if (pointInd < 0) {
                                segmentInd -= 1;
                                points = segments[segmentInd].points;
                                pointInd = points.length - 1;
                            }
                        }
                    }
                    points = segments[segmentInd].points;
                    prevPoint = points[pointInd - 1];
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                }
                len = letters.length;
                xPos = 0;
                yPos = 0;
                var yOff = documentData.finalSize * 1.2 * .714;
                var firstLine = true;
                var animatorProps;
                var animatorSelector;
                var j;
                var jLen;
                var letterValue;
                jLen = animators.length;
                var mult;
                var ind = -1;
                var offf;
                var xPathPos;
                var yPathPos;
                var initPathPos = currentLength;
                var initSegmentInd = segmentInd;
                var initPointInd = pointInd;
                var currentLine = -1;
                var elemOpacity;
                var sc;
                var sw;
                var fc;
                var k;
                var letterSw;
                var letterSc;
                var letterFc;
                var letterM = "";
                var letterP = this.defaultPropsArray;
                var letterO;
                if (documentData.j === 2 || documentData.j === 1) {
                    var animatorJustifyOffset = 0;
                    var animatorFirstCharOffset = 0;
                    var justifyOffsetMult = documentData.j === 2 ? -.5 : -1;
                    var lastIndex = 0;
                    var isNewLine = true;
                    for (i = 0; i < len; i += 1) if (letters[i].n) {
                        if (animatorJustifyOffset) animatorJustifyOffset += animatorFirstCharOffset;
                        while (lastIndex < i) {
                            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                            lastIndex += 1;
                        }
                        animatorJustifyOffset = 0;
                        isNewLine = true;
                    } else {
                        for (j = 0; j < jLen; j += 1) {
                            animatorProps = animators[j].a;
                            if (animatorProps.t.propType) {
                                if (isNewLine && documentData.j === 2) animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                                animatorSelector = animators[j].s;
                                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                if (mult.length) animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult; else animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                            }
                        }
                        isNewLine = false;
                    }
                    if (animatorJustifyOffset) animatorJustifyOffset += animatorFirstCharOffset;
                    while (lastIndex < i) {
                        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                        lastIndex += 1;
                    }
                }
                for (i = 0; i < len; i += 1) {
                    matrixHelper.reset();
                    elemOpacity = 1;
                    if (letters[i].n) {
                        xPos = 0;
                        yPos += documentData.yOffset;
                        yPos += firstLine ? 1 : 0;
                        currentLength = initPathPos;
                        firstLine = false;
                        if (this._hasMaskedPath) {
                            segmentInd = initSegmentInd;
                            pointInd = initPointInd;
                            points = segments[segmentInd].points;
                            prevPoint = points[pointInd - 1];
                            currentPoint = points[pointInd];
                            partialLength = currentPoint.partialLength;
                            segmentLength = 0;
                        }
                        letterM = "";
                        letterFc = "";
                        letterSw = "";
                        letterO = "";
                        letterP = this.defaultPropsArray;
                    } else {
                        if (this._hasMaskedPath) {
                            if (currentLine !== letters[i].line) {
                                switch (documentData.j) {
                                  case 1:
                                    currentLength += totalLength - documentData.lineWidths[letters[i].line];
                                    break;

                                  case 2:
                                    currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                                    break;

                                  default:
                                    break;
                                }
                                currentLine = letters[i].line;
                            }
                            if (ind !== letters[i].ind) {
                                if (letters[ind]) currentLength += letters[ind].extra;
                                currentLength += letters[i].an / 2;
                                ind = letters[i].ind;
                            }
                            currentLength += alignment[0] * letters[i].an * .005;
                            var animatorOffset = 0;
                            for (j = 0; j < jLen; j += 1) {
                                animatorProps = animators[j].a;
                                if (animatorProps.p.propType) {
                                    animatorSelector = animators[j].s;
                                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                    if (mult.length) animatorOffset += animatorProps.p.v[0] * mult[0]; else animatorOffset += animatorProps.p.v[0] * mult;
                                }
                                if (animatorProps.a.propType) {
                                    animatorSelector = animators[j].s;
                                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                    if (mult.length) animatorOffset += animatorProps.a.v[0] * mult[0]; else animatorOffset += animatorProps.a.v[0] * mult;
                                }
                            }
                            flag = true;
                            if (this._pathData.a.v) {
                                currentLength = letters[0].an * .5 + (totalLength - this._pathData.f.v - letters[0].an * .5 - letters[letters.length - 1].an * .5) * ind / (len - 1);
                                currentLength += this._pathData.f.v;
                            }
                            while (flag) if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                                perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                                xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                                yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                                matrixHelper.translate(-alignment[0] * letters[i].an * .005, -alignment[1] * yOff * .01);
                                flag = false;
                            } else if (points) {
                                segmentLength += currentPoint.partialLength;
                                pointInd += 1;
                                if (pointInd >= points.length) {
                                    pointInd = 0;
                                    segmentInd += 1;
                                    if (!segments[segmentInd]) if (mask.v.c) {
                                        pointInd = 0;
                                        segmentInd = 0;
                                        points = segments[segmentInd].points;
                                    } else {
                                        segmentLength -= currentPoint.partialLength;
                                        points = null;
                                    } else points = segments[segmentInd].points;
                                }
                                if (points) {
                                    prevPoint = currentPoint;
                                    currentPoint = points[pointInd];
                                    partialLength = currentPoint.partialLength;
                                }
                            }
                            offf = letters[i].an / 2 - letters[i].add;
                            matrixHelper.translate(-offf, 0, 0);
                        } else {
                            offf = letters[i].an / 2 - letters[i].add;
                            matrixHelper.translate(-offf, 0, 0);
                            matrixHelper.translate(-alignment[0] * letters[i].an * .005, -alignment[1] * yOff * .01, 0);
                        }
                        for (j = 0; j < jLen; j += 1) {
                            animatorProps = animators[j].a;
                            if (animatorProps.t.propType) {
                                animatorSelector = animators[j].s;
                                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                if (xPos !== 0 || documentData.j !== 0) if (this._hasMaskedPath) if (mult.length) currentLength += animatorProps.t.v * mult[0]; else currentLength += animatorProps.t.v * mult; else if (mult.length) xPos += animatorProps.t.v * mult[0]; else xPos += animatorProps.t.v * mult;
                            }
                        }
                        if (documentData.strokeWidthAnim) sw = documentData.sw || 0;
                        if (documentData.strokeColorAnim) if (documentData.sc) sc = [ documentData.sc[0], documentData.sc[1], documentData.sc[2] ]; else sc = [ 0, 0, 0 ];
                        if (documentData.fillColorAnim && documentData.fc) fc = [ documentData.fc[0], documentData.fc[1], documentData.fc[2] ];
                        for (j = 0; j < jLen; j += 1) {
                            animatorProps = animators[j].a;
                            if (animatorProps.a.propType) {
                                animatorSelector = animators[j].s;
                                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                if (mult.length) matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]); else matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                            }
                        }
                        for (j = 0; j < jLen; j += 1) {
                            animatorProps = animators[j].a;
                            if (animatorProps.s.propType) {
                                animatorSelector = animators[j].s;
                                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                if (mult.length) matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1); else matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                            }
                        }
                        for (j = 0; j < jLen; j += 1) {
                            animatorProps = animators[j].a;
                            animatorSelector = animators[j].s;
                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                            if (animatorProps.sk.propType) if (mult.length) matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]); else matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                            if (animatorProps.r.propType) if (mult.length) matrixHelper.rotateZ(-animatorProps.r.v * mult[2]); else matrixHelper.rotateZ(-animatorProps.r.v * mult);
                            if (animatorProps.ry.propType) if (mult.length) matrixHelper.rotateY(animatorProps.ry.v * mult[1]); else matrixHelper.rotateY(animatorProps.ry.v * mult);
                            if (animatorProps.rx.propType) if (mult.length) matrixHelper.rotateX(animatorProps.rx.v * mult[0]); else matrixHelper.rotateX(animatorProps.rx.v * mult);
                            if (animatorProps.o.propType) if (mult.length) elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0]; else elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                            if (documentData.strokeWidthAnim && animatorProps.sw.propType) if (mult.length) sw += animatorProps.sw.v * mult[0]; else sw += animatorProps.sw.v * mult;
                            if (documentData.strokeColorAnim && animatorProps.sc.propType) for (k = 0; k < 3; k += 1) if (mult.length) sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0]; else sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                            if (documentData.fillColorAnim && documentData.fc) {
                                if (animatorProps.fc.propType) for (k = 0; k < 3; k += 1) if (mult.length) fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0]; else fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                                if (animatorProps.fh.propType) if (mult.length) fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]); else fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                                if (animatorProps.fs.propType) if (mult.length) fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]); else fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                                if (animatorProps.fb.propType) if (mult.length) fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]); else fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                            }
                        }
                        for (j = 0; j < jLen; j += 1) {
                            animatorProps = animators[j].a;
                            if (animatorProps.p.propType) {
                                animatorSelector = animators[j].s;
                                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                                if (this._hasMaskedPath) if (mult.length) matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]); else matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult); else if (mult.length) matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]); else matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                            }
                        }
                        if (documentData.strokeWidthAnim) letterSw = sw < 0 ? 0 : sw;
                        if (documentData.strokeColorAnim) letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
                        if (documentData.fillColorAnim && documentData.fc) letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
                        if (this._hasMaskedPath) {
                            matrixHelper.translate(0, -documentData.ls);
                            matrixHelper.translate(0, alignment[1] * yOff * .01 + yPos, 0);
                            if (this._pathData.p.v) {
                                tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                                var rot = Math.atan(tanAngle) * 180 / Math.PI;
                                if (currentPoint.point[0] < prevPoint.point[0]) rot += 180;
                                matrixHelper.rotate(-rot * Math.PI / 180);
                            }
                            matrixHelper.translate(xPathPos, yPathPos, 0);
                            currentLength -= alignment[0] * letters[i].an * .005;
                            if (letters[i + 1] && ind !== letters[i + 1].ind) {
                                currentLength += letters[i].an / 2;
                                currentLength += documentData.tr * .001 * documentData.finalSize;
                            }
                        } else {
                            matrixHelper.translate(xPos, yPos, 0);
                            if (documentData.ps) matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                            switch (documentData.j) {
                              case 1:
                                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                                break;

                              case 2:
                                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                                break;

                              default:
                                break;
                            }
                            matrixHelper.translate(0, -documentData.ls);
                            matrixHelper.translate(offf, 0, 0);
                            matrixHelper.translate(alignment[0] * letters[i].an * .005, alignment[1] * yOff * .01, 0);
                            xPos += letters[i].l + documentData.tr * .001 * documentData.finalSize;
                        }
                        if (renderType === "html") letterM = matrixHelper.toCSS(); else if (renderType === "svg") letterM = matrixHelper.to2dCSS(); else letterP = [ matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15] ];
                        letterO = elemOpacity;
                    }
                    if (renderedLettersCount <= i) {
                        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
                        this.renderedLetters.push(letterValue);
                        renderedLettersCount += 1;
                        this.lettersChangedFlag = true;
                    } else {
                        letterValue = this.renderedLetters[i];
                        this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
                    }
                }
            };
            TextAnimatorProperty.prototype.getValue = function() {
                if (this._elem.globalData.frameId === this._frameId) return;
                this._frameId = this._elem.globalData.frameId;
                this.iterateDynamicProperties();
            };
            TextAnimatorProperty.prototype.mHelper = new Matrix;
            TextAnimatorProperty.prototype.defaultPropsArray = [];
            extendPrototype([ DynamicPropertyContainer ], TextAnimatorProperty);
            function ITextElement() {}
            ITextElement.prototype.initElement = function(data, globalData, comp) {
                this.lettersChangedFlag = true;
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
                this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
                this.initTransform(data, globalData, comp);
                this.initHierarchy();
                this.initRenderable();
                this.initRendererElement();
                this.createContainerElements();
                this.createRenderableComponents();
                this.createContent();
                this.hide();
                this.textAnimator.searchProperties(this.dynamicProperties);
            };
            ITextElement.prototype.prepareFrame = function(num) {
                this._mdf = false;
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
            };
            ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
                var j;
                var jLen = shapes.length;
                var pathNodes;
                var shapeStr = "";
                for (j = 0; j < jLen; j += 1) if (shapes[j].ty === "sh") {
                    pathNodes = shapes[j].ks.k;
                    shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
                }
                return shapeStr;
            };
            ITextElement.prototype.updateDocumentData = function(newData, index) {
                this.textProperty.updateDocumentData(newData, index);
            };
            ITextElement.prototype.canResizeFont = function(_canResize) {
                this.textProperty.canResizeFont(_canResize);
            };
            ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
                this.textProperty.setMinimumFontSize(_fontSize);
            };
            ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
                if (documentData.ps) matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                matrixHelper.translate(0, -documentData.ls, 0);
                switch (documentData.j) {
                  case 1:
                    matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
                    break;

                  case 2:
                    matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
                    break;

                  default:
                    break;
                }
                matrixHelper.translate(xPos, yPos, 0);
            };
            ITextElement.prototype.buildColor = function(colorData) {
                return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
            };
            ITextElement.prototype.emptyProp = new LetterProps;
            ITextElement.prototype.destroy = function() {};
            ITextElement.prototype.validateText = function() {
                if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
                    this.buildNewText();
                    this.textProperty._isFirstFrame = false;
                    this.textProperty._mdf = false;
                }
            };
            var emptyShapeData = {
                shapes: []
            };
            function SVGTextLottieElement(data, globalData, comp) {
                this.textSpans = [];
                this.renderType = "svg";
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement ], SVGTextLottieElement);
            SVGTextLottieElement.prototype.createContent = function() {
                if (this.data.singleShape && !this.globalData.fontManager.chars) this.textContainer = createNS("text");
            };
            SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
                var i = 0;
                var len = textArray.length;
                var textContents = [];
                var currentTextContent = "";
                while (i < len) {
                    if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
                        textContents.push(currentTextContent);
                        currentTextContent = "";
                    } else currentTextContent += textArray[i];
                    i += 1;
                }
                textContents.push(currentTextContent);
                return textContents;
            };
            SVGTextLottieElement.prototype.buildShapeData = function(data, scale) {
                if (data.shapes && data.shapes.length) {
                    var shape = data.shapes[0];
                    if (shape.it) {
                        var shapeItem = shape.it[shape.it.length - 1];
                        if (shapeItem.s) {
                            shapeItem.s.k[0] = scale;
                            shapeItem.s.k[1] = scale;
                        }
                    }
                }
                return data;
            };
            SVGTextLottieElement.prototype.buildNewText = function() {
                this.addDynamicProperty(this);
                var i;
                var len;
                var documentData = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
                if (documentData.fc) this.layerElement.setAttribute("fill", this.buildColor(documentData.fc)); else this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
                if (documentData.sc) {
                    this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
                    this.layerElement.setAttribute("stroke-width", documentData.sw);
                }
                this.layerElement.setAttribute("font-size", documentData.finalSize);
                var fontData = this.globalData.fontManager.getFontByName(documentData.f);
                if (fontData.fClass) this.layerElement.setAttribute("class", fontData.fClass); else {
                    this.layerElement.setAttribute("font-family", fontData.fFamily);
                    var fWeight = documentData.fWeight;
                    var fStyle = documentData.fStyle;
                    this.layerElement.setAttribute("font-style", fStyle);
                    this.layerElement.setAttribute("font-weight", fWeight);
                }
                this.layerElement.setAttribute("aria-label", documentData.t);
                var letters = documentData.l || [];
                var usesGlyphs = !!this.globalData.fontManager.chars;
                len = letters.length;
                var tSpan;
                var matrixHelper = this.mHelper;
                var shapeStr = "";
                var singleShape = this.data.singleShape;
                var xPos = 0;
                var yPos = 0;
                var firstLine = true;
                var trackingOffset = documentData.tr * .001 * documentData.finalSize;
                if (singleShape && !usesGlyphs && !documentData.sz) {
                    var tElement = this.textContainer;
                    var justify = "start";
                    switch (documentData.j) {
                      case 1:
                        justify = "end";
                        break;

                      case 2:
                        justify = "middle";
                        break;

                      default:
                        justify = "start";
                        break;
                    }
                    tElement.setAttribute("text-anchor", justify);
                    tElement.setAttribute("letter-spacing", trackingOffset);
                    var textContent = this.buildTextContents(documentData.finalText);
                    len = textContent.length;
                    yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
                    for (i = 0; i < len; i += 1) {
                        tSpan = this.textSpans[i].span || createNS("tspan");
                        tSpan.textContent = textContent[i];
                        tSpan.setAttribute("x", 0);
                        tSpan.setAttribute("y", yPos);
                        tSpan.style.display = "inherit";
                        tElement.appendChild(tSpan);
                        if (!this.textSpans[i]) this.textSpans[i] = {
                            span: null,
                            glyph: null
                        };
                        this.textSpans[i].span = tSpan;
                        yPos += documentData.finalLineHeight;
                    }
                    this.layerElement.appendChild(tElement);
                } else {
                    var cachedSpansLength = this.textSpans.length;
                    var charData;
                    for (i = 0; i < len; i += 1) {
                        if (!this.textSpans[i]) this.textSpans[i] = {
                            span: null,
                            childSpan: null,
                            glyph: null
                        };
                        if (!usesGlyphs || !singleShape || i === 0) {
                            tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? "g" : "text");
                            if (cachedSpansLength <= i) {
                                tSpan.setAttribute("stroke-linecap", "butt");
                                tSpan.setAttribute("stroke-linejoin", "round");
                                tSpan.setAttribute("stroke-miterlimit", "4");
                                this.textSpans[i].span = tSpan;
                                if (usesGlyphs) {
                                    var childSpan = createNS("g");
                                    tSpan.appendChild(childSpan);
                                    this.textSpans[i].childSpan = childSpan;
                                }
                                this.textSpans[i].span = tSpan;
                                this.layerElement.appendChild(tSpan);
                            }
                            tSpan.style.display = "inherit";
                        }
                        matrixHelper.reset();
                        if (singleShape) {
                            if (letters[i].n) {
                                xPos = -trackingOffset;
                                yPos += documentData.yOffset;
                                yPos += firstLine ? 1 : 0;
                                firstLine = false;
                            }
                            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
                            xPos += letters[i].l || 0;
                            xPos += trackingOffset;
                        }
                        if (usesGlyphs) {
                            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                            var glyphElement;
                            if (charData.t === 1) glyphElement = new SVGCompElement(charData.data, this.globalData, this); else {
                                var data = emptyShapeData;
                                if (charData.data && charData.data.shapes) data = this.buildShapeData(charData.data, documentData.finalSize);
                                glyphElement = new SVGShapeElement(data, this.globalData, this);
                            }
                            if (this.textSpans[i].glyph) {
                                var glyph = this.textSpans[i].glyph;
                                this.textSpans[i].childSpan.removeChild(glyph.layerElement);
                                glyph.destroy();
                            }
                            this.textSpans[i].glyph = glyphElement;
                            glyphElement._debug = true;
                            glyphElement.prepareFrame(0);
                            glyphElement.renderFrame();
                            this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);
                            if (charData.t === 1) this.textSpans[i].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
                        } else {
                            if (singleShape) tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                            tSpan.textContent = letters[i].val;
                            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                        }
                    }
                    if (singleShape && tSpan) tSpan.setAttribute("d", shapeStr);
                }
                while (i < this.textSpans.length) {
                    this.textSpans[i].span.style.display = "none";
                    i += 1;
                }
                this._sizeChanged = true;
            };
            SVGTextLottieElement.prototype.sourceRectAtTime = function() {
                this.prepareFrame(this.comp.renderedFrame - this.data.st);
                this.renderInnerContent();
                if (this._sizeChanged) {
                    this._sizeChanged = false;
                    var textBox = this.layerElement.getBBox();
                    this.bbox = {
                        top: textBox.y,
                        left: textBox.x,
                        width: textBox.width,
                        height: textBox.height
                    };
                }
                return this.bbox;
            };
            SVGTextLottieElement.prototype.getValue = function() {
                var i;
                var len = this.textSpans.length;
                var glyphElement;
                this.renderedFrame = this.comp.renderedFrame;
                for (i = 0; i < len; i += 1) {
                    glyphElement = this.textSpans[i].glyph;
                    if (glyphElement) {
                        glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
                        if (glyphElement._mdf) this._mdf = true;
                    }
                }
            };
            SVGTextLottieElement.prototype.renderInnerContent = function() {
                this.validateText();
                if (!this.data.singleShape || this._mdf) {
                    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                    if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                        this._sizeChanged = true;
                        var i;
                        var len;
                        var renderedLetters = this.textAnimator.renderedLetters;
                        var letters = this.textProperty.currentData.l;
                        len = letters.length;
                        var renderedLetter;
                        var textSpan;
                        var glyphElement;
                        for (i = 0; i < len; i += 1) if (!letters[i].n) {
                            renderedLetter = renderedLetters[i];
                            textSpan = this.textSpans[i].span;
                            glyphElement = this.textSpans[i].glyph;
                            if (glyphElement) glyphElement.renderFrame();
                            if (renderedLetter._mdf.m) textSpan.setAttribute("transform", renderedLetter.m);
                            if (renderedLetter._mdf.o) textSpan.setAttribute("opacity", renderedLetter.o);
                            if (renderedLetter._mdf.sw) textSpan.setAttribute("stroke-width", renderedLetter.sw);
                            if (renderedLetter._mdf.sc) textSpan.setAttribute("stroke", renderedLetter.sc);
                            if (renderedLetter._mdf.fc) textSpan.setAttribute("fill", renderedLetter.fc);
                        }
                    }
                }
            };
            function ISolidElement(data, globalData, comp) {
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ IImageElement ], ISolidElement);
            ISolidElement.prototype.createContent = function() {
                var rect = createNS("rect");
                rect.setAttribute("width", this.data.sw);
                rect.setAttribute("height", this.data.sh);
                rect.setAttribute("fill", this.data.sc);
                this.layerElement.appendChild(rect);
            };
            function NullElement(data, globalData, comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initFrame();
                this.initTransform(data, globalData, comp);
                this.initHierarchy();
            }
            NullElement.prototype.prepareFrame = function(num) {
                this.prepareProperties(num, true);
            };
            NullElement.prototype.renderFrame = function() {};
            NullElement.prototype.getBaseElement = function() {
                return null;
            };
            NullElement.prototype.destroy = function() {};
            NullElement.prototype.sourceRectAtTime = function() {};
            NullElement.prototype.hide = function() {};
            extendPrototype([ BaseElement, TransformElement, HierarchyElement, FrameElement ], NullElement);
            function SVGRendererBase() {}
            extendPrototype([ BaseRenderer ], SVGRendererBase);
            SVGRendererBase.prototype.createNull = function(data) {
                return new NullElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createShape = function(data) {
                return new SVGShapeElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createText = function(data) {
                return new SVGTextLottieElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createImage = function(data) {
                return new IImageElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.createSolid = function(data) {
                return new ISolidElement(data, this.globalData, this);
            };
            SVGRendererBase.prototype.configAnimation = function(animData) {
                this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
                if (this.renderConfig.viewBoxSize) this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize); else this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
                if (!this.renderConfig.viewBoxOnly) {
                    this.svgElement.setAttribute("width", animData.w);
                    this.svgElement.setAttribute("height", animData.h);
                    this.svgElement.style.width = "100%";
                    this.svgElement.style.height = "100%";
                    this.svgElement.style.transform = "translate3d(0,0,0)";
                    this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
                }
                if (this.renderConfig.width) this.svgElement.setAttribute("width", this.renderConfig.width);
                if (this.renderConfig.height) this.svgElement.setAttribute("height", this.renderConfig.height);
                if (this.renderConfig.className) this.svgElement.setAttribute("class", this.renderConfig.className);
                if (this.renderConfig.id) this.svgElement.setAttribute("id", this.renderConfig.id);
                if (this.renderConfig.focusable !== void 0) this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
                this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
                this.animationItem.wrapper.appendChild(this.svgElement);
                var defs = this.globalData.defs;
                this.setupGlobalData(animData, defs);
                this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
                this.data = animData;
                var maskElement = createNS("clipPath");
                var rect = createNS("rect");
                rect.setAttribute("width", animData.w);
                rect.setAttribute("height", animData.h);
                rect.setAttribute("x", 0);
                rect.setAttribute("y", 0);
                var maskId = createElementID();
                maskElement.setAttribute("id", maskId);
                maskElement.appendChild(rect);
                this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
                defs.appendChild(maskElement);
                this.layers = animData.layers;
                this.elements = createSizedArray(animData.layers.length);
            };
            SVGRendererBase.prototype.destroy = function() {
                if (this.animationItem.wrapper) this.animationItem.wrapper.innerText = "";
                this.layerElement = null;
                this.globalData.defs = null;
                var i;
                var len = this.layers ? this.layers.length : 0;
                for (i = 0; i < len; i += 1) if (this.elements[i] && this.elements[i].destroy) this.elements[i].destroy();
                this.elements.length = 0;
                this.destroyed = true;
                this.animationItem = null;
            };
            SVGRendererBase.prototype.updateContainerSize = function() {};
            SVGRendererBase.prototype.findIndexByInd = function(ind) {
                var i = 0;
                var len = this.layers.length;
                for (i = 0; i < len; i += 1) if (this.layers[i].ind === ind) return i;
                return -1;
            };
            SVGRendererBase.prototype.buildItem = function(pos) {
                var elements = this.elements;
                if (elements[pos] || this.layers[pos].ty === 99) return;
                elements[pos] = true;
                var element = this.createItem(this.layers[pos]);
                elements[pos] = element;
                if (getExpressionsPlugin()) {
                    if (this.layers[pos].ty === 0) this.globalData.projectInterface.registerComposition(element);
                    element.initExpressions();
                }
                this.appendElementInPos(element, pos);
                if (this.layers[pos].tt) {
                    var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
                    if (elementIndex === -1) return;
                    if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
                        this.buildItem(elementIndex);
                        this.addPendingElement(element);
                    } else {
                        var matteElement = elements[elementIndex];
                        var matteMask = matteElement.getMatte(this.layers[pos].tt);
                        element.setMatte(matteMask);
                    }
                }
            };
            SVGRendererBase.prototype.checkPendingElements = function() {
                while (this.pendingElements.length) {
                    var element = this.pendingElements.pop();
                    element.checkParenting();
                    if (element.data.tt) {
                        var i = 0;
                        var len = this.elements.length;
                        while (i < len) {
                            if (this.elements[i] === element) {
                                var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
                                var matteElement = this.elements[elementIndex];
                                var matteMask = matteElement.getMatte(this.layers[i].tt);
                                element.setMatte(matteMask);
                                break;
                            }
                            i += 1;
                        }
                    }
                }
            };
            SVGRendererBase.prototype.renderFrame = function(num) {
                if (this.renderedFrame === num || this.destroyed) return;
                if (num === null) num = this.renderedFrame; else this.renderedFrame = num;
                this.globalData.frameNum = num;
                this.globalData.frameId += 1;
                this.globalData.projectInterface.currentFrame = num;
                this.globalData._mdf = false;
                var i;
                var len = this.layers.length;
                if (!this.completeLayers) this.checkLayers(num);
                for (i = len - 1; i >= 0; i -= 1) if (this.completeLayers || this.elements[i]) this.elements[i].prepareFrame(num - this.layers[i].st);
                if (this.globalData._mdf) for (i = 0; i < len; i += 1) if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
            };
            SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
                var newElement = element.getBaseElement();
                if (!newElement) return;
                var i = 0;
                var nextElement;
                while (i < pos) {
                    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) nextElement = this.elements[i].getBaseElement();
                    i += 1;
                }
                if (nextElement) this.layerElement.insertBefore(newElement, nextElement); else this.layerElement.appendChild(newElement);
            };
            SVGRendererBase.prototype.hide = function() {
                this.layerElement.style.display = "none";
            };
            SVGRendererBase.prototype.show = function() {
                this.layerElement.style.display = "block";
            };
            function ICompElement() {}
            extendPrototype([ BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement ], ICompElement);
            ICompElement.prototype.initElement = function(data, globalData, comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initTransform(data, globalData, comp);
                this.initRenderable();
                this.initHierarchy();
                this.initRendererElement();
                this.createContainerElements();
                this.createRenderableComponents();
                if (this.data.xt || !globalData.progressiveLoad) this.buildAllItems();
                this.hide();
            };
            ICompElement.prototype.prepareFrame = function(num) {
                this._mdf = false;
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
                if (!this.isInRange && !this.data.xt) return;
                if (!this.tm._placeholder) {
                    var timeRemapped = this.tm.v;
                    if (timeRemapped === this.data.op) timeRemapped = this.data.op - 1;
                    this.renderedFrame = timeRemapped;
                } else this.renderedFrame = num / this.data.sr;
                var i;
                var len = this.elements.length;
                if (!this.completeLayers) this.checkLayers(this.renderedFrame);
                for (i = len - 1; i >= 0; i -= 1) if (this.completeLayers || this.elements[i]) {
                    this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
                    if (this.elements[i]._mdf) this._mdf = true;
                }
            };
            ICompElement.prototype.renderInnerContent = function() {
                var i;
                var len = this.layers.length;
                for (i = 0; i < len; i += 1) if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
            };
            ICompElement.prototype.setElements = function(elems) {
                this.elements = elems;
            };
            ICompElement.prototype.getElements = function() {
                return this.elements;
            };
            ICompElement.prototype.destroyElements = function() {
                var i;
                var len = this.layers.length;
                for (i = 0; i < len; i += 1) if (this.elements[i]) this.elements[i].destroy();
            };
            ICompElement.prototype.destroy = function() {
                this.destroyElements();
                this.destroyBaseElement();
            };
            function SVGCompElement(data, globalData, comp) {
                this.layers = data.layers;
                this.supports3d = true;
                this.completeLayers = false;
                this.pendingElements = [];
                this.elements = this.layers ? createSizedArray(this.layers.length) : [];
                this.initElement(data, globalData, comp);
                this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                    _placeholder: true
                };
            }
            extendPrototype([ SVGRendererBase, ICompElement, SVGBaseElement ], SVGCompElement);
            SVGCompElement.prototype.createComp = function(data) {
                return new SVGCompElement(data, this.globalData, this);
            };
            function SVGRenderer(animationItem, config) {
                this.animationItem = animationItem;
                this.layers = null;
                this.renderedFrame = -1;
                this.svgElement = createNS("svg");
                var ariaLabel = "";
                if (config && config.title) {
                    var titleElement = createNS("title");
                    var titleId = createElementID();
                    titleElement.setAttribute("id", titleId);
                    titleElement.textContent = config.title;
                    this.svgElement.appendChild(titleElement);
                    ariaLabel += titleId;
                }
                if (config && config.description) {
                    var descElement = createNS("desc");
                    var descId = createElementID();
                    descElement.setAttribute("id", descId);
                    descElement.textContent = config.description;
                    this.svgElement.appendChild(descElement);
                    ariaLabel += " " + descId;
                }
                if (ariaLabel) this.svgElement.setAttribute("aria-labelledby", ariaLabel);
                var defs = createNS("defs");
                this.svgElement.appendChild(defs);
                var maskElement = createNS("g");
                this.svgElement.appendChild(maskElement);
                this.layerElement = maskElement;
                this.renderConfig = {
                    preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
                    imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                    contentVisibility: config && config.contentVisibility || "visible",
                    progressiveLoad: config && config.progressiveLoad || false,
                    hideOnTransparent: !(config && config.hideOnTransparent === false),
                    viewBoxOnly: config && config.viewBoxOnly || false,
                    viewBoxSize: config && config.viewBoxSize || false,
                    className: config && config.className || "",
                    id: config && config.id || "",
                    focusable: config && config.focusable,
                    filterSize: {
                        width: config && config.filterSize && config.filterSize.width || "100%",
                        height: config && config.filterSize && config.filterSize.height || "100%",
                        x: config && config.filterSize && config.filterSize.x || "0%",
                        y: config && config.filterSize && config.filterSize.y || "0%"
                    },
                    width: config && config.width,
                    height: config && config.height,
                    runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
                };
                this.globalData = {
                    _mdf: false,
                    frameNum: -1,
                    defs,
                    renderConfig: this.renderConfig
                };
                this.elements = [];
                this.pendingElements = [];
                this.destroyed = false;
                this.rendererType = "svg";
            }
            extendPrototype([ SVGRendererBase ], SVGRenderer);
            SVGRenderer.prototype.createComp = function(data) {
                return new SVGCompElement(data, this.globalData, this);
            };
            function ShapeTransformManager() {
                this.sequences = {};
                this.sequenceList = [];
                this.transform_key_count = 0;
            }
            ShapeTransformManager.prototype = {
                addTransformSequence: function(transforms) {
                    var i;
                    var len = transforms.length;
                    var key = "_";
                    for (i = 0; i < len; i += 1) key += transforms[i].transform.key + "_";
                    var sequence = this.sequences[key];
                    if (!sequence) {
                        sequence = {
                            transforms: [].concat(transforms),
                            finalTransform: new Matrix,
                            _mdf: false
                        };
                        this.sequences[key] = sequence;
                        this.sequenceList.push(sequence);
                    }
                    return sequence;
                },
                processSequence: function(sequence, isFirstFrame) {
                    var i = 0;
                    var len = sequence.transforms.length;
                    var _mdf = isFirstFrame;
                    while (i < len && !isFirstFrame) {
                        if (sequence.transforms[i].transform.mProps._mdf) {
                            _mdf = true;
                            break;
                        }
                        i += 1;
                    }
                    if (_mdf) {
                        sequence.finalTransform.reset();
                        for (i = len - 1; i >= 0; i -= 1) sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
                    }
                    sequence._mdf = _mdf;
                },
                processSequences: function(isFirstFrame) {
                    var i;
                    var len = this.sequenceList.length;
                    for (i = 0; i < len; i += 1) this.processSequence(this.sequenceList[i], isFirstFrame);
                },
                getNewKey: function() {
                    this.transform_key_count += 1;
                    return "_" + this.transform_key_count;
                }
            };
            var lumaLoader = function() {
                var id = "__lottie_element_luma_buffer";
                var lumaBuffer = null;
                var lumaBufferCtx = null;
                var svg = null;
                function createLumaSvgFilter() {
                    var _svg = createNS("svg");
                    var fil = createNS("filter");
                    var matrix = createNS("feColorMatrix");
                    fil.setAttribute("id", id);
                    matrix.setAttribute("type", "matrix");
                    matrix.setAttribute("color-interpolation-filters", "sRGB");
                    matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
                    fil.appendChild(matrix);
                    _svg.appendChild(fil);
                    _svg.setAttribute("id", id + "_svg");
                    if (featureSupport.svgLumaHidden) _svg.style.display = "none";
                    return _svg;
                }
                function loadLuma() {
                    if (!lumaBuffer) {
                        svg = createLumaSvgFilter();
                        document.body.appendChild(svg);
                        lumaBuffer = createTag("canvas");
                        lumaBufferCtx = lumaBuffer.getContext("2d");
                        lumaBufferCtx.filter = "url(#" + id + ")";
                        lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
                        lumaBufferCtx.fillRect(0, 0, 1, 1);
                    }
                }
                function getLuma(canvas) {
                    if (!lumaBuffer) loadLuma();
                    lumaBuffer.width = canvas.width;
                    lumaBuffer.height = canvas.height;
                    lumaBufferCtx.filter = "url(#" + id + ")";
                    return lumaBuffer;
                }
                return {
                    load: loadLuma,
                    get: getLuma
                };
            };
            function createCanvas(width, height) {
                if (featureSupport.offscreenCanvas) return new OffscreenCanvas(width, height);
                var canvas = createTag("canvas");
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }
            const assetLoader = function() {
                return {
                    loadLumaCanvas: lumaLoader.load,
                    getLumaCanvas: lumaLoader.get,
                    createCanvas
                };
            }();
            var registeredEffects = {};
            function CVEffects(elem) {
                var i;
                var len = elem.data.ef ? elem.data.ef.length : 0;
                this.filters = [];
                var filterManager;
                for (i = 0; i < len; i += 1) {
                    filterManager = null;
                    var type = elem.data.ef[i].ty;
                    if (registeredEffects[type]) {
                        var Effect = registeredEffects[type].effect;
                        filterManager = new Effect(elem.effectsManager.effectElements[i], elem);
                    }
                    if (filterManager) this.filters.push(filterManager);
                }
                if (this.filters.length) elem.addRenderableComponent(this);
            }
            CVEffects.prototype.renderFrame = function(_isFirstFrame) {
                var i;
                var len = this.filters.length;
                for (i = 0; i < len; i += 1) this.filters[i].renderFrame(_isFirstFrame);
            };
            CVEffects.prototype.getEffects = function(type) {
                var i;
                var len = this.filters.length;
                var effects = [];
                for (i = 0; i < len; i += 1) if (this.filters[i].type === type) effects.push(this.filters[i]);
                return effects;
            };
            function registerEffect(id, effect) {
                registeredEffects[id] = {
                    effect
                };
            }
            function CVMaskElement(data, element) {
                this.data = data;
                this.element = element;
                this.masksProperties = this.data.masksProperties || [];
                this.viewData = createSizedArray(this.masksProperties.length);
                var i;
                var len = this.masksProperties.length;
                var hasMasks = false;
                for (i = 0; i < len; i += 1) {
                    if (this.masksProperties[i].mode !== "n") hasMasks = true;
                    this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
                }
                this.hasMasks = hasMasks;
                if (hasMasks) this.element.addRenderableComponent(this);
            }
            CVMaskElement.prototype.renderFrame = function() {
                if (!this.hasMasks) return;
                var transform = this.element.finalTransform.mat;
                var ctx = this.element.canvasContext;
                var i;
                var len = this.masksProperties.length;
                var pt;
                var pts;
                var data;
                ctx.beginPath();
                for (i = 0; i < len; i += 1) if (this.masksProperties[i].mode !== "n") {
                    if (this.masksProperties[i].inv) {
                        ctx.moveTo(0, 0);
                        ctx.lineTo(this.element.globalData.compSize.w, 0);
                        ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
                        ctx.lineTo(0, this.element.globalData.compSize.h);
                        ctx.lineTo(0, 0);
                    }
                    data = this.viewData[i].v;
                    pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
                    ctx.moveTo(pt[0], pt[1]);
                    var j;
                    var jLen = data._length;
                    for (j = 1; j < jLen; j += 1) {
                        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
                        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
                    }
                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
                    ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
                }
                this.element.globalData.renderer.save(true);
                ctx.clip();
            };
            CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
            CVMaskElement.prototype.destroy = function() {
                this.element = null;
            };
            function CVBaseElement() {}
            var operationsMap = {
                1: "source-in",
                2: "source-out",
                3: "source-in",
                4: "source-out"
            };
            CVBaseElement.prototype = {
                createElements: function() {},
                initRendererElement: function() {},
                createContainerElements: function() {
                    if (this.data.tt >= 1) {
                        this.buffers = [];
                        var canvasContext = this.globalData.canvasContext;
                        var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
                        this.buffers.push(bufferCanvas);
                        var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
                        this.buffers.push(bufferCanvas2);
                        if (this.data.tt >= 3 && !document._isProxy) assetLoader.loadLumaCanvas();
                    }
                    this.canvasContext = this.globalData.canvasContext;
                    this.transformCanvas = this.globalData.transformCanvas;
                    this.renderableEffectsManager = new CVEffects(this);
                    this.searchEffectTransforms();
                },
                createContent: function() {},
                setBlendMode: function() {
                    var globalData = this.globalData;
                    if (globalData.blendMode !== this.data.bm) {
                        globalData.blendMode = this.data.bm;
                        var blendModeValue = getBlendMode(this.data.bm);
                        globalData.canvasContext.globalCompositeOperation = blendModeValue;
                    }
                },
                createRenderableComponents: function() {
                    this.maskManager = new CVMaskElement(this.data, this);
                    this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                },
                hideElement: function() {
                    if (!this.hidden && (!this.isInRange || this.isTransparent)) this.hidden = true;
                },
                showElement: function() {
                    if (this.isInRange && !this.isTransparent) {
                        this.hidden = false;
                        this._isFirstFrame = true;
                        this.maskManager._isFirstFrame = true;
                    }
                },
                clearCanvas: function(canvasContext) {
                    canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
                },
                prepareLayer: function() {
                    if (this.data.tt >= 1) {
                        var buffer = this.buffers[0];
                        var bufferCtx = buffer.getContext("2d");
                        this.clearCanvas(bufferCtx);
                        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
                        this.currentTransform = this.canvasContext.getTransform();
                        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
                        this.clearCanvas(this.canvasContext);
                        this.canvasContext.setTransform(this.currentTransform);
                    }
                },
                exitLayer: function() {
                    if (this.data.tt >= 1) {
                        var buffer = this.buffers[1];
                        var bufferCtx = buffer.getContext("2d");
                        this.clearCanvas(bufferCtx);
                        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
                        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
                        this.clearCanvas(this.canvasContext);
                        this.canvasContext.setTransform(this.currentTransform);
                        const mask = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
                        mask.renderFrame(true);
                        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
                        if (this.data.tt >= 3 && !document._isProxy) {
                            var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
                            var lumaBufferCtx = lumaBuffer.getContext("2d");
                            lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
                            this.clearCanvas(this.canvasContext);
                            this.canvasContext.drawImage(lumaBuffer, 0, 0);
                        }
                        this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
                        this.canvasContext.drawImage(buffer, 0, 0);
                        this.canvasContext.globalCompositeOperation = "destination-over";
                        this.canvasContext.drawImage(this.buffers[0], 0, 0);
                        this.canvasContext.setTransform(this.currentTransform);
                        this.canvasContext.globalCompositeOperation = "source-over";
                    }
                },
                renderFrame: function(forceRender) {
                    if (this.hidden || this.data.hd) return;
                    if (this.data.td === 1 && !forceRender) return;
                    this.renderTransform();
                    this.renderRenderable();
                    this.renderLocalTransform();
                    this.setBlendMode();
                    var forceRealStack = this.data.ty === 0;
                    this.prepareLayer();
                    this.globalData.renderer.save(forceRealStack);
                    this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
                    this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
                    this.renderInnerContent();
                    this.globalData.renderer.restore(forceRealStack);
                    this.exitLayer();
                    if (this.maskManager.hasMasks) this.globalData.renderer.restore(true);
                    if (this._isFirstFrame) this._isFirstFrame = false;
                },
                destroy: function() {
                    this.canvasContext = null;
                    this.data = null;
                    this.globalData = null;
                    this.maskManager.destroy();
                },
                mHelper: new Matrix
            };
            CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
            CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
            function CVShapeData(element, data, styles, transformsManager) {
                this.styledShapes = [];
                this.tr = [ 0, 0, 0, 0, 0, 0 ];
                var ty = 4;
                if (data.ty === "rc") ty = 5; else if (data.ty === "el") ty = 6; else if (data.ty === "sr") ty = 7;
                this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
                var i;
                var len = styles.length;
                var styledShape;
                for (i = 0; i < len; i += 1) if (!styles[i].closed) {
                    styledShape = {
                        transforms: transformsManager.addTransformSequence(styles[i].transforms),
                        trNodes: []
                    };
                    this.styledShapes.push(styledShape);
                    styles[i].elements.push(styledShape);
                }
            }
            CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
            function CVShapeElement(data, globalData, comp) {
                this.shapes = [];
                this.shapesData = data.shapes;
                this.stylesList = [];
                this.itemsData = [];
                this.prevViewData = [];
                this.shapeModifiers = [];
                this.processedElements = [];
                this.transformsManager = new ShapeTransformManager;
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement ], CVShapeElement);
            CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
            CVShapeElement.prototype.transformHelper = {
                opacity: 1,
                _opMdf: false
            };
            CVShapeElement.prototype.dashResetter = [];
            CVShapeElement.prototype.createContent = function() {
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
            };
            CVShapeElement.prototype.createStyleElement = function(data, transforms) {
                var styleElem = {
                    data,
                    type: data.ty,
                    preTransforms: this.transformsManager.addTransformSequence(transforms),
                    transforms: [],
                    elements: [],
                    closed: data.hd === true
                };
                var elementData = {};
                if (data.ty === "fl" || data.ty === "st") {
                    elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
                    if (!elementData.c.k) styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
                } else if (data.ty === "gf" || data.ty === "gs") {
                    elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
                    elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
                    elementData.h = PropertyFactory.getProp(this, data.h || {
                        k: 0
                    }, 0, .01, this);
                    elementData.a = PropertyFactory.getProp(this, data.a || {
                        k: 0
                    }, 0, degToRads, this);
                    elementData.g = new GradientProperty(this, data.g, this);
                }
                elementData.o = PropertyFactory.getProp(this, data.o, 0, .01, this);
                if (data.ty === "st" || data.ty === "gs") {
                    styleElem.lc = lineCapEnum[data.lc || 2];
                    styleElem.lj = lineJoinEnum[data.lj || 2];
                    if (data.lj == 1) styleElem.ml = data.ml;
                    elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
                    if (!elementData.w.k) styleElem.wi = elementData.w.v;
                    if (data.d) {
                        var d = new DashProperty(this, data.d, "canvas", this);
                        elementData.d = d;
                        if (!elementData.d.k) {
                            styleElem.da = elementData.d.dashArray;
                            styleElem.do = elementData.d.dashoffset[0];
                        }
                    }
                } else styleElem.r = data.r === 2 ? "evenodd" : "nonzero";
                this.stylesList.push(styleElem);
                elementData.style = styleElem;
                return elementData;
            };
            CVShapeElement.prototype.createGroupElement = function() {
                var elementData = {
                    it: [],
                    prevViewData: []
                };
                return elementData;
            };
            CVShapeElement.prototype.createTransformElement = function(data) {
                var elementData = {
                    transform: {
                        opacity: 1,
                        _opMdf: false,
                        key: this.transformsManager.getNewKey(),
                        op: PropertyFactory.getProp(this, data.o, 0, .01, this),
                        mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
                    }
                };
                return elementData;
            };
            CVShapeElement.prototype.createShapeElement = function(data) {
                var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
                this.shapes.push(elementData);
                this.addShapeToModifiers(elementData);
                return elementData;
            };
            CVShapeElement.prototype.reloadShapes = function() {
                this._isFirstFrame = true;
                var i;
                var len = this.itemsData.length;
                for (i = 0; i < len; i += 1) this.prevViewData[i] = this.itemsData[i];
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
                len = this.dynamicProperties.length;
                for (i = 0; i < len; i += 1) this.dynamicProperties[i].getValue();
                this.renderModifiers();
                this.transformsManager.processSequences(this._isFirstFrame);
            };
            CVShapeElement.prototype.addTransformToStyleList = function(transform) {
                var i;
                var len = this.stylesList.length;
                for (i = 0; i < len; i += 1) if (!this.stylesList[i].closed) this.stylesList[i].transforms.push(transform);
            };
            CVShapeElement.prototype.removeTransformFromStyleList = function() {
                var i;
                var len = this.stylesList.length;
                for (i = 0; i < len; i += 1) if (!this.stylesList[i].closed) this.stylesList[i].transforms.pop();
            };
            CVShapeElement.prototype.closeStyles = function(styles) {
                var i;
                var len = styles.length;
                for (i = 0; i < len; i += 1) styles[i].closed = true;
            };
            CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
                var i;
                var len = arr.length - 1;
                var j;
                var jLen;
                var ownStyles = [];
                var ownModifiers = [];
                var processedPos;
                var modifier;
                var currentTransform;
                var ownTransforms = [].concat(transforms);
                for (i = len; i >= 0; i -= 1) {
                    processedPos = this.searchProcessedElement(arr[i]);
                    if (!processedPos) arr[i]._shouldRender = shouldRender; else itemsData[i] = prevViewData[processedPos - 1];
                    if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs") {
                        if (!processedPos) itemsData[i] = this.createStyleElement(arr[i], ownTransforms); else itemsData[i].style.closed = false;
                        ownStyles.push(itemsData[i].style);
                    } else if (arr[i].ty === "gr") {
                        if (!processedPos) itemsData[i] = this.createGroupElement(arr[i]); else {
                            jLen = itemsData[i].it.length;
                            for (j = 0; j < jLen; j += 1) itemsData[i].prevViewData[j] = itemsData[i].it[j];
                        }
                        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
                    } else if (arr[i].ty === "tr") {
                        if (!processedPos) {
                            currentTransform = this.createTransformElement(arr[i]);
                            itemsData[i] = currentTransform;
                        }
                        ownTransforms.push(itemsData[i]);
                        this.addTransformToStyleList(itemsData[i]);
                    } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
                        if (!processedPos) itemsData[i] = this.createShapeElement(arr[i]);
                    } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "pb" || arr[i].ty === "zz" || arr[i].ty === "op") {
                        if (!processedPos) {
                            modifier = ShapeModifiers.getModifier(arr[i].ty);
                            modifier.init(this, arr[i]);
                            itemsData[i] = modifier;
                            this.shapeModifiers.push(modifier);
                        } else {
                            modifier = itemsData[i];
                            modifier.closed = false;
                        }
                        ownModifiers.push(modifier);
                    } else if (arr[i].ty === "rp") {
                        if (!processedPos) {
                            modifier = ShapeModifiers.getModifier(arr[i].ty);
                            itemsData[i] = modifier;
                            modifier.init(this, arr, i, itemsData);
                            this.shapeModifiers.push(modifier);
                            shouldRender = false;
                        } else {
                            modifier = itemsData[i];
                            modifier.closed = true;
                        }
                        ownModifiers.push(modifier);
                    }
                    this.addProcessedElement(arr[i], i + 1);
                }
                this.removeTransformFromStyleList();
                this.closeStyles(ownStyles);
                len = ownModifiers.length;
                for (i = 0; i < len; i += 1) ownModifiers[i].closed = true;
            };
            CVShapeElement.prototype.renderInnerContent = function() {
                this.transformHelper.opacity = 1;
                this.transformHelper._opMdf = false;
                this.renderModifiers();
                this.transformsManager.processSequences(this._isFirstFrame);
                this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
            };
            CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
                if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
                    groupTransform.opacity = parentTransform.opacity;
                    groupTransform.opacity *= groupTransform.op.v;
                    groupTransform._opMdf = true;
                }
            };
            CVShapeElement.prototype.drawLayer = function() {
                var i;
                var len = this.stylesList.length;
                var j;
                var jLen;
                var k;
                var kLen;
                var elems;
                var nodes;
                var renderer = this.globalData.renderer;
                var ctx = this.globalData.canvasContext;
                var type;
                var currentStyle;
                for (i = 0; i < len; i += 1) {
                    currentStyle = this.stylesList[i];
                    type = currentStyle.type;
                    if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                        renderer.save();
                        elems = currentStyle.elements;
                        if (type === "st" || type === "gs") {
                            renderer.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
                            renderer.ctxLineWidth(currentStyle.wi);
                            renderer.ctxLineCap(currentStyle.lc);
                            renderer.ctxLineJoin(currentStyle.lj);
                            renderer.ctxMiterLimit(currentStyle.ml || 0);
                        } else renderer.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
                        renderer.ctxOpacity(currentStyle.coOp);
                        if (type !== "st" && type !== "gs") ctx.beginPath();
                        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
                        jLen = elems.length;
                        for (j = 0; j < jLen; j += 1) {
                            if (type === "st" || type === "gs") {
                                ctx.beginPath();
                                if (currentStyle.da) {
                                    ctx.setLineDash(currentStyle.da);
                                    ctx.lineDashOffset = currentStyle.do;
                                }
                            }
                            nodes = elems[j].trNodes;
                            kLen = nodes.length;
                            for (k = 0; k < kLen; k += 1) if (nodes[k].t === "m") ctx.moveTo(nodes[k].p[0], nodes[k].p[1]); else if (nodes[k].t === "c") ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]); else ctx.closePath();
                            if (type === "st" || type === "gs") {
                                renderer.ctxStroke();
                                if (currentStyle.da) ctx.setLineDash(this.dashResetter);
                            }
                        }
                        if (type !== "st" && type !== "gs") this.globalData.renderer.ctxFill(currentStyle.r);
                        renderer.restore();
                    }
                }
            };
            CVShapeElement.prototype.renderShape = function(parentTransform, items, data, isMain) {
                var i;
                var len = items.length - 1;
                var groupTransform;
                groupTransform = parentTransform;
                for (i = len; i >= 0; i -= 1) if (items[i].ty === "tr") {
                    groupTransform = data[i].transform;
                    this.renderShapeTransform(parentTransform, groupTransform);
                } else if (items[i].ty === "sh" || items[i].ty === "el" || items[i].ty === "rc" || items[i].ty === "sr") this.renderPath(items[i], data[i]); else if (items[i].ty === "fl") this.renderFill(items[i], data[i], groupTransform); else if (items[i].ty === "st") this.renderStroke(items[i], data[i], groupTransform); else if (items[i].ty === "gf" || items[i].ty === "gs") this.renderGradientFill(items[i], data[i], groupTransform); else if (items[i].ty === "gr") this.renderShape(groupTransform, items[i].it, data[i].it); else if (items[i].ty === "tm") ;
                if (isMain) this.drawLayer();
            };
            CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
                if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
                    var shapeNodes = styledShape.trNodes;
                    var paths = shape.paths;
                    var i;
                    var len;
                    var j;
                    var jLen = paths._length;
                    shapeNodes.length = 0;
                    var groupTransformMat = styledShape.transforms.finalTransform;
                    for (j = 0; j < jLen; j += 1) {
                        var pathNodes = paths.shapes[j];
                        if (pathNodes && pathNodes.v) {
                            len = pathNodes._length;
                            for (i = 1; i < len; i += 1) {
                                if (i === 1) shapeNodes.push({
                                    t: "m",
                                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                                });
                                shapeNodes.push({
                                    t: "c",
                                    pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                                });
                            }
                            if (len === 1) shapeNodes.push({
                                t: "m",
                                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                            });
                            if (pathNodes.c && len) {
                                shapeNodes.push({
                                    t: "c",
                                    pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                                });
                                shapeNodes.push({
                                    t: "z"
                                });
                            }
                        }
                    }
                    styledShape.trNodes = shapeNodes;
                }
            };
            CVShapeElement.prototype.renderPath = function(pathData, itemData) {
                if (pathData.hd !== true && pathData._shouldRender) {
                    var i;
                    var len = itemData.styledShapes.length;
                    for (i = 0; i < len; i += 1) this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
                }
            };
            CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
                var styleElem = itemData.style;
                if (itemData.c._mdf || this._isFirstFrame) styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
                if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) styleElem.coOp = itemData.o.v * groupTransform.opacity;
            };
            CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
                var styleElem = itemData.style;
                var grd;
                if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
                    var ctx = this.globalData.canvasContext;
                    var pt1 = itemData.s.v;
                    var pt2 = itemData.e.v;
                    if (styleData.t === 1) grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]); else {
                        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                        var percent = itemData.h.v;
                        if (percent >= 1) percent = .99; else if (percent <= -1) percent = -.99;
                        var dist = rad * percent;
                        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                        grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
                    }
                    var i;
                    var len = styleData.g.p;
                    var cValues = itemData.g.c;
                    var opacity = 1;
                    for (i = 0; i < len; i += 1) {
                        if (itemData.g._hasOpacity && itemData.g._collapsable) opacity = itemData.g.o[i * 2 + 1];
                        grd.addColorStop(cValues[i * 4] / 100, "rgba(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + "," + opacity + ")");
                    }
                    styleElem.grd = grd;
                }
                styleElem.coOp = itemData.o.v * groupTransform.opacity;
            };
            CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
                var styleElem = itemData.style;
                var d = itemData.d;
                if (d && (d._mdf || this._isFirstFrame)) {
                    styleElem.da = d.dashArray;
                    styleElem.do = d.dashoffset[0];
                }
                if (itemData.c._mdf || this._isFirstFrame) styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
                if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) styleElem.coOp = itemData.o.v * groupTransform.opacity;
                if (itemData.w._mdf || this._isFirstFrame) styleElem.wi = itemData.w.v;
            };
            CVShapeElement.prototype.destroy = function() {
                this.shapesData = null;
                this.globalData = null;
                this.canvasContext = null;
                this.stylesList.length = 0;
                this.itemsData.length = 0;
            };
            function CVTextElement(data, globalData, comp) {
                this.textSpans = [];
                this.yOffset = 0;
                this.fillColorAnim = false;
                this.strokeColorAnim = false;
                this.strokeWidthAnim = false;
                this.stroke = false;
                this.fill = false;
                this.justifyOffset = 0;
                this.currentRender = null;
                this.renderType = "canvas";
                this.values = {
                    fill: "rgba(0,0,0,0)",
                    stroke: "rgba(0,0,0,0)",
                    sWidth: 0,
                    fValue: ""
                };
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement ], CVTextElement);
            CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
            CVTextElement.prototype.buildNewText = function() {
                var documentData = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
                var hasFill = false;
                if (documentData.fc) {
                    hasFill = true;
                    this.values.fill = this.buildColor(documentData.fc);
                } else this.values.fill = "rgba(0,0,0,0)";
                this.fill = hasFill;
                var hasStroke = false;
                if (documentData.sc) {
                    hasStroke = true;
                    this.values.stroke = this.buildColor(documentData.sc);
                    this.values.sWidth = documentData.sw;
                }
                var fontData = this.globalData.fontManager.getFontByName(documentData.f);
                var i;
                var len;
                var letters = documentData.l;
                var matrixHelper = this.mHelper;
                this.stroke = hasStroke;
                this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
                len = documentData.finalText.length;
                var charData;
                var shapeData;
                var k;
                var kLen;
                var shapes;
                var j;
                var jLen;
                var pathNodes;
                var commands;
                var pathArr;
                var singleShape = this.data.singleShape;
                var trackingOffset = documentData.tr * .001 * documentData.finalSize;
                var xPos = 0;
                var yPos = 0;
                var firstLine = true;
                var cnt = 0;
                for (i = 0; i < len; i += 1) {
                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                    shapeData = charData && charData.data || {};
                    matrixHelper.reset();
                    if (singleShape && letters[i].n) {
                        xPos = -trackingOffset;
                        yPos += documentData.yOffset;
                        yPos += firstLine ? 1 : 0;
                        firstLine = false;
                    }
                    shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
                    jLen = shapes.length;
                    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                    if (singleShape) this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
                    commands = createSizedArray(jLen - 1);
                    var commandsCounter = 0;
                    for (j = 0; j < jLen; j += 1) if (shapes[j].ty === "sh") {
                        kLen = shapes[j].ks.k.i.length;
                        pathNodes = shapes[j].ks.k;
                        pathArr = [];
                        for (k = 1; k < kLen; k += 1) {
                            if (k === 1) pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
                        }
                        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                        commands[commandsCounter] = pathArr;
                        commandsCounter += 1;
                    }
                    if (singleShape) {
                        xPos += letters[i].l;
                        xPos += trackingOffset;
                    }
                    if (this.textSpans[cnt]) this.textSpans[cnt].elem = commands; else this.textSpans[cnt] = {
                        elem: commands
                    };
                    cnt += 1;
                }
            };
            CVTextElement.prototype.renderInnerContent = function() {
                this.validateText();
                var ctx = this.canvasContext;
                ctx.font = this.values.fValue;
                this.globalData.renderer.ctxLineCap("butt");
                this.globalData.renderer.ctxLineJoin("miter");
                this.globalData.renderer.ctxMiterLimit(4);
                if (!this.data.singleShape) this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                var i;
                var len;
                var j;
                var jLen;
                var k;
                var kLen;
                var renderedLetters = this.textAnimator.renderedLetters;
                var letters = this.textProperty.currentData.l;
                len = letters.length;
                var renderedLetter;
                var lastFill = null;
                var lastStroke = null;
                var lastStrokeW = null;
                var commands;
                var pathArr;
                var renderer = this.globalData.renderer;
                for (i = 0; i < len; i += 1) if (!letters[i].n) {
                    renderedLetter = renderedLetters[i];
                    if (renderedLetter) {
                        renderer.save();
                        renderer.ctxTransform(renderedLetter.p);
                        renderer.ctxOpacity(renderedLetter.o);
                    }
                    if (this.fill) {
                        if (renderedLetter && renderedLetter.fc) {
                            if (lastFill !== renderedLetter.fc) {
                                renderer.ctxFillStyle(renderedLetter.fc);
                                lastFill = renderedLetter.fc;
                            }
                        } else if (lastFill !== this.values.fill) {
                            lastFill = this.values.fill;
                            renderer.ctxFillStyle(this.values.fill);
                        }
                        commands = this.textSpans[i].elem;
                        jLen = commands.length;
                        this.globalData.canvasContext.beginPath();
                        for (j = 0; j < jLen; j += 1) {
                            pathArr = commands[j];
                            kLen = pathArr.length;
                            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                            for (k = 2; k < kLen; k += 6) this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                        }
                        this.globalData.canvasContext.closePath();
                        renderer.ctxFill();
                    }
                    if (this.stroke) {
                        if (renderedLetter && renderedLetter.sw) {
                            if (lastStrokeW !== renderedLetter.sw) {
                                lastStrokeW = renderedLetter.sw;
                                renderer.ctxLineWidth(renderedLetter.sw);
                            }
                        } else if (lastStrokeW !== this.values.sWidth) {
                            lastStrokeW = this.values.sWidth;
                            renderer.ctxLineWidth(this.values.sWidth);
                        }
                        if (renderedLetter && renderedLetter.sc) {
                            if (lastStroke !== renderedLetter.sc) {
                                lastStroke = renderedLetter.sc;
                                renderer.ctxStrokeStyle(renderedLetter.sc);
                            }
                        } else if (lastStroke !== this.values.stroke) {
                            lastStroke = this.values.stroke;
                            renderer.ctxStrokeStyle(this.values.stroke);
                        }
                        commands = this.textSpans[i].elem;
                        jLen = commands.length;
                        this.globalData.canvasContext.beginPath();
                        for (j = 0; j < jLen; j += 1) {
                            pathArr = commands[j];
                            kLen = pathArr.length;
                            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                            for (k = 2; k < kLen; k += 6) this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                        }
                        this.globalData.canvasContext.closePath();
                        renderer.ctxStroke();
                    }
                    if (renderedLetter) this.globalData.renderer.restore();
                }
            };
            function CVImageElement(data, globalData, comp) {
                this.assetData = globalData.getAssetData(data.refId);
                this.img = globalData.imageLoader.getAsset(this.assetData);
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement ], CVImageElement);
            CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
            CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
            CVImageElement.prototype.createContent = function() {
                if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                    var canvas = createTag("canvas");
                    canvas.width = this.assetData.w;
                    canvas.height = this.assetData.h;
                    var ctx = canvas.getContext("2d");
                    var imgW = this.img.width;
                    var imgH = this.img.height;
                    var imgRel = imgW / imgH;
                    var canvasRel = this.assetData.w / this.assetData.h;
                    var widthCrop;
                    var heightCrop;
                    var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                    if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
                        heightCrop = imgH;
                        widthCrop = heightCrop * canvasRel;
                    } else {
                        widthCrop = imgW;
                        heightCrop = widthCrop / canvasRel;
                    }
                    ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
                    this.img = canvas;
                }
            };
            CVImageElement.prototype.renderInnerContent = function() {
                this.canvasContext.drawImage(this.img, 0, 0);
            };
            CVImageElement.prototype.destroy = function() {
                this.img = null;
            };
            function CVSolidElement(data, globalData, comp) {
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement ], CVSolidElement);
            CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
            CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
            CVSolidElement.prototype.renderInnerContent = function() {
                this.globalData.renderer.ctxFillStyle(this.data.sc);
                this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
            };
            function CanvasRendererBase() {}
            extendPrototype([ BaseRenderer ], CanvasRendererBase);
            CanvasRendererBase.prototype.createShape = function(data) {
                return new CVShapeElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createText = function(data) {
                return new CVTextElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createImage = function(data) {
                return new CVImageElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createSolid = function(data) {
                return new CVSolidElement(data, this.globalData, this);
            };
            CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
            CanvasRendererBase.prototype.ctxTransform = function(props) {
                if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) return;
                this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
            };
            CanvasRendererBase.prototype.ctxOpacity = function(op) {
                this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
            };
            CanvasRendererBase.prototype.ctxFillStyle = function(value) {
                this.canvasContext.fillStyle = value;
            };
            CanvasRendererBase.prototype.ctxStrokeStyle = function(value) {
                this.canvasContext.strokeStyle = value;
            };
            CanvasRendererBase.prototype.ctxLineWidth = function(value) {
                this.canvasContext.lineWidth = value;
            };
            CanvasRendererBase.prototype.ctxLineCap = function(value) {
                this.canvasContext.lineCap = value;
            };
            CanvasRendererBase.prototype.ctxLineJoin = function(value) {
                this.canvasContext.lineJoin = value;
            };
            CanvasRendererBase.prototype.ctxMiterLimit = function(value) {
                this.canvasContext.miterLimit = value;
            };
            CanvasRendererBase.prototype.ctxFill = function(rule) {
                this.canvasContext.fill(rule);
            };
            CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {
                this.canvasContext.fillRect(x, y, w, h);
            };
            CanvasRendererBase.prototype.ctxStroke = function() {
                this.canvasContext.stroke();
            };
            CanvasRendererBase.prototype.reset = function() {
                if (!this.renderConfig.clearCanvas) {
                    this.canvasContext.restore();
                    return;
                }
                this.contextData.reset();
            };
            CanvasRendererBase.prototype.save = function() {
                this.canvasContext.save();
            };
            CanvasRendererBase.prototype.restore = function(actionFlag) {
                if (!this.renderConfig.clearCanvas) {
                    this.canvasContext.restore();
                    return;
                }
                if (actionFlag) this.globalData.blendMode = "source-over";
                this.contextData.restore(actionFlag);
            };
            CanvasRendererBase.prototype.configAnimation = function(animData) {
                if (this.animationItem.wrapper) {
                    this.animationItem.container = createTag("canvas");
                    var containerStyle = this.animationItem.container.style;
                    containerStyle.width = "100%";
                    containerStyle.height = "100%";
                    var origin = "0px 0px 0px";
                    containerStyle.transformOrigin = origin;
                    containerStyle.mozTransformOrigin = origin;
                    containerStyle.webkitTransformOrigin = origin;
                    containerStyle["-webkit-transform"] = origin;
                    containerStyle.contentVisibility = this.renderConfig.contentVisibility;
                    this.animationItem.wrapper.appendChild(this.animationItem.container);
                    this.canvasContext = this.animationItem.container.getContext("2d");
                    if (this.renderConfig.className) this.animationItem.container.setAttribute("class", this.renderConfig.className);
                    if (this.renderConfig.id) this.animationItem.container.setAttribute("id", this.renderConfig.id);
                } else this.canvasContext = this.renderConfig.context;
                this.contextData.setContext(this.canvasContext);
                this.data = animData;
                this.layers = animData.layers;
                this.transformCanvas = {
                    w: animData.w,
                    h: animData.h,
                    sx: 0,
                    sy: 0,
                    tx: 0,
                    ty: 0
                };
                this.setupGlobalData(animData, document.body);
                this.globalData.canvasContext = this.canvasContext;
                this.globalData.renderer = this;
                this.globalData.isDashed = false;
                this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
                this.globalData.transformCanvas = this.transformCanvas;
                this.elements = createSizedArray(animData.layers.length);
                this.updateContainerSize();
            };
            CanvasRendererBase.prototype.updateContainerSize = function(width, height) {
                this.reset();
                var elementWidth;
                var elementHeight;
                if (width) {
                    elementWidth = width;
                    elementHeight = height;
                    this.canvasContext.canvas.width = elementWidth;
                    this.canvasContext.canvas.height = elementHeight;
                } else {
                    if (this.animationItem.wrapper && this.animationItem.container) {
                        elementWidth = this.animationItem.wrapper.offsetWidth;
                        elementHeight = this.animationItem.wrapper.offsetHeight;
                    } else {
                        elementWidth = this.canvasContext.canvas.width;
                        elementHeight = this.canvasContext.canvas.height;
                    }
                    this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
                    this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
                }
                var elementRel;
                var animationRel;
                if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
                    var par = this.renderConfig.preserveAspectRatio.split(" ");
                    var fillType = par[1] || "meet";
                    var pos = par[0] || "xMidYMid";
                    var xPos = pos.substr(0, 4);
                    var yPos = pos.substr(4);
                    elementRel = elementWidth / elementHeight;
                    animationRel = this.transformCanvas.w / this.transformCanvas.h;
                    if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
                        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                    } else {
                        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                    }
                    if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr; else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr; else this.transformCanvas.tx = 0;
                    if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr; else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr; else this.transformCanvas.ty = 0;
                } else if (this.renderConfig.preserveAspectRatio === "none") {
                    this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                    this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                    this.transformCanvas.tx = 0;
                    this.transformCanvas.ty = 0;
                } else {
                    this.transformCanvas.sx = this.renderConfig.dpr;
                    this.transformCanvas.sy = this.renderConfig.dpr;
                    this.transformCanvas.tx = 0;
                    this.transformCanvas.ty = 0;
                }
                this.transformCanvas.props = [ this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1 ];
                this.ctxTransform(this.transformCanvas.props);
                this.canvasContext.beginPath();
                this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
                this.canvasContext.closePath();
                this.canvasContext.clip();
                this.renderFrame(this.renderedFrame, true);
            };
            CanvasRendererBase.prototype.destroy = function() {
                if (this.renderConfig.clearCanvas && this.animationItem.wrapper) this.animationItem.wrapper.innerText = "";
                var i;
                var len = this.layers ? this.layers.length : 0;
                for (i = len - 1; i >= 0; i -= 1) if (this.elements[i] && this.elements[i].destroy) this.elements[i].destroy();
                this.elements.length = 0;
                this.globalData.canvasContext = null;
                this.animationItem.container = null;
                this.destroyed = true;
            };
            CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
                if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) return;
                this.renderedFrame = num;
                this.globalData.frameNum = num - this.animationItem._isFirstFrame;
                this.globalData.frameId += 1;
                this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
                this.globalData.projectInterface.currentFrame = num;
                var i;
                var len = this.layers.length;
                if (!this.completeLayers) this.checkLayers(num);
                for (i = len - 1; i >= 0; i -= 1) if (this.completeLayers || this.elements[i]) this.elements[i].prepareFrame(num - this.layers[i].st);
                if (this.globalData._mdf) {
                    if (this.renderConfig.clearCanvas === true) this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h); else this.save();
                    for (i = len - 1; i >= 0; i -= 1) if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
                    if (this.renderConfig.clearCanvas !== true) this.restore();
                }
            };
            CanvasRendererBase.prototype.buildItem = function(pos) {
                var elements = this.elements;
                if (elements[pos] || this.layers[pos].ty === 99) return;
                var element = this.createItem(this.layers[pos], this, this.globalData);
                elements[pos] = element;
                element.initExpressions();
            };
            CanvasRendererBase.prototype.checkPendingElements = function() {
                while (this.pendingElements.length) {
                    var element = this.pendingElements.pop();
                    element.checkParenting();
                }
            };
            CanvasRendererBase.prototype.hide = function() {
                this.animationItem.container.style.display = "none";
            };
            CanvasRendererBase.prototype.show = function() {
                this.animationItem.container.style.display = "block";
            };
            function CanvasContext() {
                this.opacity = -1;
                this.transform = createTypedArray("float32", 16);
                this.fillStyle = "";
                this.strokeStyle = "";
                this.lineWidth = "";
                this.lineCap = "";
                this.lineJoin = "";
                this.miterLimit = "";
                this.id = Math.random();
            }
            function CVContextData() {
                this.stack = [];
                this.cArrPos = 0;
                this.cTr = new Matrix;
                var i;
                var len = 15;
                for (i = 0; i < len; i += 1) {
                    var canvasContext = new CanvasContext;
                    this.stack[i] = canvasContext;
                }
                this._length = len;
                this.nativeContext = null;
                this.transformMat = new Matrix;
                this.currentOpacity = 1;
                this.currentFillStyle = "";
                this.appliedFillStyle = "";
                this.currentStrokeStyle = "";
                this.appliedStrokeStyle = "";
                this.currentLineWidth = "";
                this.appliedLineWidth = "";
                this.currentLineCap = "";
                this.appliedLineCap = "";
                this.currentLineJoin = "";
                this.appliedLineJoin = "";
                this.appliedMiterLimit = "";
                this.currentMiterLimit = "";
            }
            CVContextData.prototype.duplicate = function() {
                var newLength = this._length * 2;
                var i = 0;
                for (i = this._length; i < newLength; i += 1) this.stack[i] = new CanvasContext;
                this._length = newLength;
            };
            CVContextData.prototype.reset = function() {
                this.cArrPos = 0;
                this.cTr.reset();
                this.stack[this.cArrPos].opacity = 1;
            };
            CVContextData.prototype.restore = function(forceRestore) {
                this.cArrPos -= 1;
                var currentContext = this.stack[this.cArrPos];
                var transform = currentContext.transform;
                var i;
                var arr = this.cTr.props;
                for (i = 0; i < 16; i += 1) arr[i] = transform[i];
                if (forceRestore) {
                    this.nativeContext.restore();
                    var prevStack = this.stack[this.cArrPos + 1];
                    this.appliedFillStyle = prevStack.fillStyle;
                    this.appliedStrokeStyle = prevStack.strokeStyle;
                    this.appliedLineWidth = prevStack.lineWidth;
                    this.appliedLineCap = prevStack.lineCap;
                    this.appliedLineJoin = prevStack.lineJoin;
                    this.appliedMiterLimit = prevStack.miterLimit;
                }
                this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);
                if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
                    this.nativeContext.globalAlpha = currentContext.opacity;
                    this.currentOpacity = currentContext.opacity;
                }
                this.currentFillStyle = currentContext.fillStyle;
                this.currentStrokeStyle = currentContext.strokeStyle;
                this.currentLineWidth = currentContext.lineWidth;
                this.currentLineCap = currentContext.lineCap;
                this.currentLineJoin = currentContext.lineJoin;
                this.currentMiterLimit = currentContext.miterLimit;
            };
            CVContextData.prototype.save = function(saveOnNativeFlag) {
                if (saveOnNativeFlag) this.nativeContext.save();
                var props = this.cTr.props;
                if (this._length <= this.cArrPos) this.duplicate();
                var currentStack = this.stack[this.cArrPos];
                var i;
                for (i = 0; i < 16; i += 1) currentStack.transform[i] = props[i];
                this.cArrPos += 1;
                var newStack = this.stack[this.cArrPos];
                newStack.opacity = currentStack.opacity;
                newStack.fillStyle = currentStack.fillStyle;
                newStack.strokeStyle = currentStack.strokeStyle;
                newStack.lineWidth = currentStack.lineWidth;
                newStack.lineCap = currentStack.lineCap;
                newStack.lineJoin = currentStack.lineJoin;
                newStack.miterLimit = currentStack.miterLimit;
            };
            CVContextData.prototype.setOpacity = function(value) {
                this.stack[this.cArrPos].opacity = value;
            };
            CVContextData.prototype.setContext = function(value) {
                this.nativeContext = value;
            };
            CVContextData.prototype.fillStyle = function(value) {
                if (this.stack[this.cArrPos].fillStyle !== value) {
                    this.currentFillStyle = value;
                    this.stack[this.cArrPos].fillStyle = value;
                }
            };
            CVContextData.prototype.strokeStyle = function(value) {
                if (this.stack[this.cArrPos].strokeStyle !== value) {
                    this.currentStrokeStyle = value;
                    this.stack[this.cArrPos].strokeStyle = value;
                }
            };
            CVContextData.prototype.lineWidth = function(value) {
                if (this.stack[this.cArrPos].lineWidth !== value) {
                    this.currentLineWidth = value;
                    this.stack[this.cArrPos].lineWidth = value;
                }
            };
            CVContextData.prototype.lineCap = function(value) {
                if (this.stack[this.cArrPos].lineCap !== value) {
                    this.currentLineCap = value;
                    this.stack[this.cArrPos].lineCap = value;
                }
            };
            CVContextData.prototype.lineJoin = function(value) {
                if (this.stack[this.cArrPos].lineJoin !== value) {
                    this.currentLineJoin = value;
                    this.stack[this.cArrPos].lineJoin = value;
                }
            };
            CVContextData.prototype.miterLimit = function(value) {
                if (this.stack[this.cArrPos].miterLimit !== value) {
                    this.currentMiterLimit = value;
                    this.stack[this.cArrPos].miterLimit = value;
                }
            };
            CVContextData.prototype.transform = function(props) {
                this.transformMat.cloneFromProps(props);
                var currentTransform = this.cTr;
                this.transformMat.multiply(currentTransform);
                currentTransform.cloneFromProps(this.transformMat.props);
                var trProps = currentTransform.props;
                this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
            };
            CVContextData.prototype.opacity = function(op) {
                var currentOpacity = this.stack[this.cArrPos].opacity;
                currentOpacity *= op < 0 ? 0 : op;
                if (this.stack[this.cArrPos].opacity !== currentOpacity) {
                    if (this.currentOpacity !== op) {
                        this.nativeContext.globalAlpha = op;
                        this.currentOpacity = op;
                    }
                    this.stack[this.cArrPos].opacity = currentOpacity;
                }
            };
            CVContextData.prototype.fill = function(rule) {
                if (this.appliedFillStyle !== this.currentFillStyle) {
                    this.appliedFillStyle = this.currentFillStyle;
                    this.nativeContext.fillStyle = this.appliedFillStyle;
                }
                this.nativeContext.fill(rule);
            };
            CVContextData.prototype.fillRect = function(x, y, w, h) {
                if (this.appliedFillStyle !== this.currentFillStyle) {
                    this.appliedFillStyle = this.currentFillStyle;
                    this.nativeContext.fillStyle = this.appliedFillStyle;
                }
                this.nativeContext.fillRect(x, y, w, h);
            };
            CVContextData.prototype.stroke = function() {
                if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
                    this.appliedStrokeStyle = this.currentStrokeStyle;
                    this.nativeContext.strokeStyle = this.appliedStrokeStyle;
                }
                if (this.appliedLineWidth !== this.currentLineWidth) {
                    this.appliedLineWidth = this.currentLineWidth;
                    this.nativeContext.lineWidth = this.appliedLineWidth;
                }
                if (this.appliedLineCap !== this.currentLineCap) {
                    this.appliedLineCap = this.currentLineCap;
                    this.nativeContext.lineCap = this.appliedLineCap;
                }
                if (this.appliedLineJoin !== this.currentLineJoin) {
                    this.appliedLineJoin = this.currentLineJoin;
                    this.nativeContext.lineJoin = this.appliedLineJoin;
                }
                if (this.appliedMiterLimit !== this.currentMiterLimit) {
                    this.appliedMiterLimit = this.currentMiterLimit;
                    this.nativeContext.miterLimit = this.appliedMiterLimit;
                }
                this.nativeContext.stroke();
            };
            function CVCompElement(data, globalData, comp) {
                this.completeLayers = false;
                this.layers = data.layers;
                this.pendingElements = [];
                this.elements = createSizedArray(this.layers.length);
                this.initElement(data, globalData, comp);
                this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                    _placeholder: true
                };
            }
            extendPrototype([ CanvasRendererBase, ICompElement, CVBaseElement ], CVCompElement);
            CVCompElement.prototype.renderInnerContent = function() {
                var ctx = this.canvasContext;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.data.w, 0);
                ctx.lineTo(this.data.w, this.data.h);
                ctx.lineTo(0, this.data.h);
                ctx.lineTo(0, 0);
                ctx.clip();
                var i;
                var len = this.layers.length;
                for (i = len - 1; i >= 0; i -= 1) if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
            };
            CVCompElement.prototype.destroy = function() {
                var i;
                var len = this.layers.length;
                for (i = len - 1; i >= 0; i -= 1) if (this.elements[i]) this.elements[i].destroy();
                this.layers = null;
                this.elements = null;
            };
            CVCompElement.prototype.createComp = function(data) {
                return new CVCompElement(data, this.globalData, this);
            };
            function CanvasRenderer(animationItem, config) {
                this.animationItem = animationItem;
                this.renderConfig = {
                    clearCanvas: config && config.clearCanvas !== void 0 ? config.clearCanvas : true,
                    context: config && config.context || null,
                    progressiveLoad: config && config.progressiveLoad || false,
                    preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
                    imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                    contentVisibility: config && config.contentVisibility || "visible",
                    className: config && config.className || "",
                    id: config && config.id || "",
                    runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
                };
                this.renderConfig.dpr = config && config.dpr || 1;
                if (this.animationItem.wrapper) this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
                this.renderedFrame = -1;
                this.globalData = {
                    frameNum: -1,
                    _mdf: false,
                    renderConfig: this.renderConfig,
                    currentGlobalAlpha: -1
                };
                this.contextData = new CVContextData;
                this.elements = [];
                this.pendingElements = [];
                this.transformMat = new Matrix;
                this.completeLayers = false;
                this.rendererType = "canvas";
                if (this.renderConfig.clearCanvas) {
                    this.ctxTransform = this.contextData.transform.bind(this.contextData);
                    this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
                    this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
                    this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
                    this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
                    this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
                    this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
                    this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
                    this.ctxFill = this.contextData.fill.bind(this.contextData);
                    this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
                    this.ctxStroke = this.contextData.stroke.bind(this.contextData);
                    this.save = this.contextData.save.bind(this.contextData);
                }
            }
            extendPrototype([ CanvasRendererBase ], CanvasRenderer);
            CanvasRenderer.prototype.createComp = function(data) {
                return new CVCompElement(data, this.globalData, this);
            };
            function HBaseElement() {}
            HBaseElement.prototype = {
                checkBlendMode: function() {},
                initRendererElement: function() {
                    this.baseElement = createTag(this.data.tg || "div");
                    if (this.data.hasMask) {
                        this.svgElement = createNS("svg");
                        this.layerElement = createNS("g");
                        this.maskedElement = this.layerElement;
                        this.svgElement.appendChild(this.layerElement);
                        this.baseElement.appendChild(this.svgElement);
                    } else this.layerElement = this.baseElement;
                    styleDiv(this.baseElement);
                },
                createContainerElements: function() {
                    this.renderableEffectsManager = new CVEffects(this);
                    this.transformedElement = this.baseElement;
                    this.maskedElement = this.layerElement;
                    if (this.data.ln) this.layerElement.setAttribute("id", this.data.ln);
                    if (this.data.cl) this.layerElement.setAttribute("class", this.data.cl);
                    if (this.data.bm !== 0) this.setBlendMode();
                },
                renderElement: function() {
                    var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
                    if (this.finalTransform._matMdf) {
                        var matrixValue = this.finalTransform.mat.toCSS();
                        transformedElementStyle.transform = matrixValue;
                        transformedElementStyle.webkitTransform = matrixValue;
                    }
                    if (this.finalTransform._opMdf) transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
                },
                renderFrame: function() {
                    if (this.data.hd || this.hidden) return;
                    this.renderTransform();
                    this.renderRenderable();
                    this.renderElement();
                    this.renderInnerContent();
                    if (this._isFirstFrame) this._isFirstFrame = false;
                },
                destroy: function() {
                    this.layerElement = null;
                    this.transformedElement = null;
                    if (this.matteElement) this.matteElement = null;
                    if (this.maskManager) {
                        this.maskManager.destroy();
                        this.maskManager = null;
                    }
                },
                createRenderableComponents: function() {
                    this.maskManager = new MaskElement(this.data, this, this.globalData);
                },
                addEffects: function() {},
                setMatte: function() {}
            };
            HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
            HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
            HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
            function HSolidElement(data, globalData, comp) {
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement ], HSolidElement);
            HSolidElement.prototype.createContent = function() {
                var rect;
                if (this.data.hasMask) {
                    rect = createNS("rect");
                    rect.setAttribute("width", this.data.sw);
                    rect.setAttribute("height", this.data.sh);
                    rect.setAttribute("fill", this.data.sc);
                    this.svgElement.setAttribute("width", this.data.sw);
                    this.svgElement.setAttribute("height", this.data.sh);
                } else {
                    rect = createTag("div");
                    rect.style.width = this.data.sw + "px";
                    rect.style.height = this.data.sh + "px";
                    rect.style.backgroundColor = this.data.sc;
                }
                this.layerElement.appendChild(rect);
            };
            function HShapeElement(data, globalData, comp) {
                this.shapes = [];
                this.shapesData = data.shapes;
                this.stylesList = [];
                this.shapeModifiers = [];
                this.itemsData = [];
                this.processedElements = [];
                this.animatedContents = [];
                this.shapesContainer = createNS("g");
                this.initElement(data, globalData, comp);
                this.prevViewData = [];
                this.currentBBox = {
                    x: 999999,
                    y: -999999,
                    h: 0,
                    w: 0
                };
            }
            extendPrototype([ BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement ], HShapeElement);
            HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
            HShapeElement.prototype.createContent = function() {
                var cont;
                this.baseElement.style.fontSize = 0;
                if (this.data.hasMask) {
                    this.layerElement.appendChild(this.shapesContainer);
                    cont = this.svgElement;
                } else {
                    cont = createNS("svg");
                    var size = this.comp.data ? this.comp.data : this.globalData.compSize;
                    cont.setAttribute("width", size.w);
                    cont.setAttribute("height", size.h);
                    cont.appendChild(this.shapesContainer);
                    this.layerElement.appendChild(cont);
                }
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
                this.filterUniqueShapes();
                this.shapeCont = cont;
            };
            HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
                var i;
                var len = transformers.length;
                for (i = 0; i < len; i += 1) point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
                return point;
            };
            HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
                var shape = item.sh.v;
                var transformers = item.transformers;
                var i;
                var len = shape._length;
                var vPoint;
                var oPoint;
                var nextIPoint;
                var nextVPoint;
                if (len <= 1) return;
                for (i = 0; i < len - 1; i += 1) {
                    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
                    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
                    nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
                    nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
                    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
                }
                if (shape.c) {
                    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
                    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
                    nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
                    nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
                    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
                }
            };
            HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
                this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
                var bounds = this.shapeBoundingBox;
                boundingBox.x = bmMin(bounds.left, boundingBox.x);
                boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
                boundingBox.y = bmMin(bounds.top, boundingBox.y);
                boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
            };
            HShapeElement.prototype.shapeBoundingBox = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            HShapeElement.prototype.tempBoundingBox = {
                x: 0,
                xMax: 0,
                y: 0,
                yMax: 0,
                width: 0,
                height: 0
            };
            HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
                var bounds = [ [ p0[0], p3[0] ], [ p0[1], p3[1] ] ];
                for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
                    b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    c = 3 * p1[i] - 3 * p0[i];
                    b |= 0;
                    a |= 0;
                    c |= 0;
                    if (a === 0 && b === 0) ; else if (a === 0) {
                        t = -c / b;
                        if (t > 0 && t < 1) bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
                    } else {
                        b2ac = b * b - 4 * c * a;
                        if (b2ac >= 0) {
                            t1 = (-b + bmSqrt(b2ac)) / (2 * a);
                            if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
                            t2 = (-b - bmSqrt(b2ac)) / (2 * a);
                            if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
                        }
                    }
                }
                this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
                this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
                this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
                this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
            };
            HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
                return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
            };
            HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
                var i;
                var len = itemsData.length;
                for (i = 0; i < len; i += 1) if (itemsData[i] && itemsData[i].sh) this.calculateShapeBoundingBox(itemsData[i], boundingBox); else if (itemsData[i] && itemsData[i].it) this.calculateBoundingBox(itemsData[i].it, boundingBox); else if (itemsData[i] && itemsData[i].style && itemsData[i].w) this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
            };
            HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
                var width = 0;
                if (widthProperty.keyframes) {
                    for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
                        var kfw = widthProperty.keyframes[i].s;
                        if (kfw > width) width = kfw;
                    }
                    width *= widthProperty.mult;
                } else width = widthProperty.v * widthProperty.mult;
                boundingBox.x -= width;
                boundingBox.xMax += width;
                boundingBox.y -= width;
                boundingBox.yMax += width;
            };
            HShapeElement.prototype.currentBoxContains = function(box) {
                return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
            };
            HShapeElement.prototype.renderInnerContent = function() {
                this._renderShapeFrame();
                if (!this.hidden && (this._isFirstFrame || this._mdf)) {
                    var tempBoundingBox = this.tempBoundingBox;
                    var max = 999999;
                    tempBoundingBox.x = max;
                    tempBoundingBox.xMax = -max;
                    tempBoundingBox.y = max;
                    tempBoundingBox.yMax = -max;
                    this.calculateBoundingBox(this.itemsData, tempBoundingBox);
                    tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
                    tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
                    if (this.currentBoxContains(tempBoundingBox)) return;
                    var changed = false;
                    if (this.currentBBox.w !== tempBoundingBox.width) {
                        this.currentBBox.w = tempBoundingBox.width;
                        this.shapeCont.setAttribute("width", tempBoundingBox.width);
                        changed = true;
                    }
                    if (this.currentBBox.h !== tempBoundingBox.height) {
                        this.currentBBox.h = tempBoundingBox.height;
                        this.shapeCont.setAttribute("height", tempBoundingBox.height);
                        changed = true;
                    }
                    if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
                        this.currentBBox.w = tempBoundingBox.width;
                        this.currentBBox.h = tempBoundingBox.height;
                        this.currentBBox.x = tempBoundingBox.x;
                        this.currentBBox.y = tempBoundingBox.y;
                        this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                        var shapeStyle = this.shapeCont.style;
                        var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        shapeStyle.transform = shapeTransform;
                        shapeStyle.webkitTransform = shapeTransform;
                    }
                }
            };
            function HTextElement(data, globalData, comp) {
                this.textSpans = [];
                this.textPaths = [];
                this.currentBBox = {
                    x: 999999,
                    y: -999999,
                    h: 0,
                    w: 0
                };
                this.renderType = "svg";
                this.isMasked = false;
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement ], HTextElement);
            HTextElement.prototype.createContent = function() {
                this.isMasked = this.checkMasks();
                if (this.isMasked) {
                    this.renderType = "svg";
                    this.compW = this.comp.data.w;
                    this.compH = this.comp.data.h;
                    this.svgElement.setAttribute("width", this.compW);
                    this.svgElement.setAttribute("height", this.compH);
                    var g = createNS("g");
                    this.maskedElement.appendChild(g);
                    this.innerElem = g;
                } else {
                    this.renderType = "html";
                    this.innerElem = this.layerElement;
                }
                this.checkParenting();
            };
            HTextElement.prototype.buildNewText = function() {
                var documentData = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
                var innerElemStyle = this.innerElem.style;
                var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
                innerElemStyle.fill = textColor;
                innerElemStyle.color = textColor;
                if (documentData.sc) {
                    innerElemStyle.stroke = this.buildColor(documentData.sc);
                    innerElemStyle.strokeWidth = documentData.sw + "px";
                }
                var fontData = this.globalData.fontManager.getFontByName(documentData.f);
                if (!this.globalData.fontManager.chars) {
                    innerElemStyle.fontSize = documentData.finalSize + "px";
                    innerElemStyle.lineHeight = documentData.finalSize + "px";
                    if (fontData.fClass) this.innerElem.className = fontData.fClass; else {
                        innerElemStyle.fontFamily = fontData.fFamily;
                        var fWeight = documentData.fWeight;
                        var fStyle = documentData.fStyle;
                        innerElemStyle.fontStyle = fStyle;
                        innerElemStyle.fontWeight = fWeight;
                    }
                }
                var i;
                var len;
                var letters = documentData.l;
                len = letters.length;
                var tSpan;
                var tParent;
                var tCont;
                var matrixHelper = this.mHelper;
                var shapes;
                var shapeStr = "";
                var cnt = 0;
                for (i = 0; i < len; i += 1) {
                    if (this.globalData.fontManager.chars) {
                        if (!this.textPaths[cnt]) {
                            tSpan = createNS("path");
                            tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
                            tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
                            tSpan.setAttribute("stroke-miterlimit", "4");
                        } else tSpan = this.textPaths[cnt];
                        if (!this.isMasked) if (this.textSpans[cnt]) {
                            tParent = this.textSpans[cnt];
                            tCont = tParent.children[0];
                        } else {
                            tParent = createTag("div");
                            tParent.style.lineHeight = 0;
                            tCont = createNS("svg");
                            tCont.appendChild(tSpan);
                            styleDiv(tParent);
                        }
                    } else if (!this.isMasked) if (this.textSpans[cnt]) {
                        tParent = this.textSpans[cnt];
                        tSpan = this.textPaths[cnt];
                    } else {
                        tParent = createTag("span");
                        styleDiv(tParent);
                        tSpan = createTag("span");
                        styleDiv(tSpan);
                        tParent.appendChild(tSpan);
                    } else tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
                    if (this.globalData.fontManager.chars) {
                        var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                        var shapeData;
                        if (charData) shapeData = charData.data; else shapeData = null;
                        matrixHelper.reset();
                        if (shapeData && shapeData.shapes && shapeData.shapes.length) {
                            shapes = shapeData.shapes[0].it;
                            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                            shapeStr = this.createPathShape(matrixHelper, shapes);
                            tSpan.setAttribute("d", shapeStr);
                        }
                        if (!this.isMasked) {
                            this.innerElem.appendChild(tParent);
                            if (shapeData && shapeData.shapes) {
                                document.body.appendChild(tCont);
                                var boundingBox = tCont.getBBox();
                                tCont.setAttribute("width", boundingBox.width + 2);
                                tCont.setAttribute("height", boundingBox.height + 2);
                                tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                                var tContStyle = tCont.style;
                                var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                                tContStyle.transform = tContTranslation;
                                tContStyle.webkitTransform = tContTranslation;
                                letters[i].yOffset = boundingBox.y - 1;
                            } else {
                                tCont.setAttribute("width", 1);
                                tCont.setAttribute("height", 1);
                            }
                            tParent.appendChild(tCont);
                        } else this.innerElem.appendChild(tSpan);
                    } else {
                        tSpan.textContent = letters[i].val;
                        tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                        if (!this.isMasked) {
                            this.innerElem.appendChild(tParent);
                            var tStyle = tSpan.style;
                            var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
                            tStyle.transform = tSpanTranslation;
                            tStyle.webkitTransform = tSpanTranslation;
                        } else this.innerElem.appendChild(tSpan);
                    }
                    if (!this.isMasked) this.textSpans[cnt] = tParent; else this.textSpans[cnt] = tSpan;
                    this.textSpans[cnt].style.display = "block";
                    this.textPaths[cnt] = tSpan;
                    cnt += 1;
                }
                while (cnt < this.textSpans.length) {
                    this.textSpans[cnt].style.display = "none";
                    cnt += 1;
                }
            };
            HTextElement.prototype.renderInnerContent = function() {
                this.validateText();
                var svgStyle;
                if (this.data.singleShape) {
                    if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                    if (this.isMasked && this.finalTransform._matMdf) {
                        this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
                        svgStyle = this.svgElement.style;
                        var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                        svgStyle.transform = translation;
                        svgStyle.webkitTransform = translation;
                    }
                }
                this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) return;
                var i;
                var len;
                var count = 0;
                var renderedLetters = this.textAnimator.renderedLetters;
                var letters = this.textProperty.currentData.l;
                len = letters.length;
                var renderedLetter;
                var textSpan;
                var textPath;
                for (i = 0; i < len; i += 1) if (letters[i].n) count += 1; else {
                    textSpan = this.textSpans[i];
                    textPath = this.textPaths[i];
                    renderedLetter = renderedLetters[count];
                    count += 1;
                    if (renderedLetter._mdf.m) if (!this.isMasked) {
                        textSpan.style.webkitTransform = renderedLetter.m;
                        textSpan.style.transform = renderedLetter.m;
                    } else textSpan.setAttribute("transform", renderedLetter.m);
                    textSpan.style.opacity = renderedLetter.o;
                    if (renderedLetter.sw && renderedLetter._mdf.sw) textPath.setAttribute("stroke-width", renderedLetter.sw);
                    if (renderedLetter.sc && renderedLetter._mdf.sc) textPath.setAttribute("stroke", renderedLetter.sc);
                    if (renderedLetter.fc && renderedLetter._mdf.fc) {
                        textPath.setAttribute("fill", renderedLetter.fc);
                        textPath.style.color = renderedLetter.fc;
                    }
                }
                if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var boundingBox = this.innerElem.getBBox();
                    if (this.currentBBox.w !== boundingBox.width) {
                        this.currentBBox.w = boundingBox.width;
                        this.svgElement.setAttribute("width", boundingBox.width);
                    }
                    if (this.currentBBox.h !== boundingBox.height) {
                        this.currentBBox.h = boundingBox.height;
                        this.svgElement.setAttribute("height", boundingBox.height);
                    }
                    var margin = 1;
                    if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
                        this.currentBBox.w = boundingBox.width + margin * 2;
                        this.currentBBox.h = boundingBox.height + margin * 2;
                        this.currentBBox.x = boundingBox.x - margin;
                        this.currentBBox.y = boundingBox.y - margin;
                        this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                        svgStyle = this.svgElement.style;
                        var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        svgStyle.transform = svgTransform;
                        svgStyle.webkitTransform = svgTransform;
                    }
                }
            };
            function HCameraElement(data, globalData, comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initHierarchy();
                var getProp = PropertyFactory.getProp;
                this.pe = getProp(this, data.pe, 0, 0, this);
                if (data.ks.p.s) {
                    this.px = getProp(this, data.ks.p.x, 1, 0, this);
                    this.py = getProp(this, data.ks.p.y, 1, 0, this);
                    this.pz = getProp(this, data.ks.p.z, 1, 0, this);
                } else this.p = getProp(this, data.ks.p, 1, 0, this);
                if (data.ks.a) this.a = getProp(this, data.ks.a, 1, 0, this);
                if (data.ks.or.k.length && data.ks.or.k[0].to) {
                    var i;
                    var len = data.ks.or.k.length;
                    for (i = 0; i < len; i += 1) {
                        data.ks.or.k[i].to = null;
                        data.ks.or.k[i].ti = null;
                    }
                }
                this.or = getProp(this, data.ks.or, 1, degToRads, this);
                this.or.sh = true;
                this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
                this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
                this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
                this.mat = new Matrix;
                this._prevMat = new Matrix;
                this._isFirstFrame = true;
                this.finalTransform = {
                    mProp: this
                };
            }
            extendPrototype([ BaseElement, FrameElement, HierarchyElement ], HCameraElement);
            HCameraElement.prototype.setup = function() {
                var i;
                var len = this.comp.threeDElements.length;
                var comp;
                var perspectiveStyle;
                var containerStyle;
                for (i = 0; i < len; i += 1) {
                    comp = this.comp.threeDElements[i];
                    if (comp.type === "3d") {
                        perspectiveStyle = comp.perspectiveElem.style;
                        containerStyle = comp.container.style;
                        var perspective = this.pe.v + "px";
                        var origin = "0px 0px 0px";
                        var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                        perspectiveStyle.perspective = perspective;
                        perspectiveStyle.webkitPerspective = perspective;
                        containerStyle.transformOrigin = origin;
                        containerStyle.mozTransformOrigin = origin;
                        containerStyle.webkitTransformOrigin = origin;
                        perspectiveStyle.transform = matrix;
                        perspectiveStyle.webkitTransform = matrix;
                    }
                }
            };
            HCameraElement.prototype.createElements = function() {};
            HCameraElement.prototype.hide = function() {};
            HCameraElement.prototype.renderFrame = function() {
                var _mdf = this._isFirstFrame;
                var i;
                var len;
                if (this.hierarchy) {
                    len = this.hierarchy.length;
                    for (i = 0; i < len; i += 1) _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
                }
                if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                    this.mat.reset();
                    if (this.hierarchy) {
                        len = this.hierarchy.length - 1;
                        for (i = len; i >= 0; i -= 1) {
                            var mTransf = this.hierarchy[i].finalTransform.mProp;
                            this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
                            this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
                            this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
                            this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
                            this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
                        }
                    }
                    if (this.p) this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]); else this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
                    if (this.a) {
                        var diffVector;
                        if (this.p) diffVector = [ this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2] ]; else diffVector = [ this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2] ];
                        var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
                        var lookDir = [ diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag ];
                        var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
                        var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
                        var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
                        this.mat.rotateY(mRotationY).rotateX(-mRotationX);
                    }
                    this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
                    this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
                    this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
                    this.mat.translate(0, 0, this.pe.v);
                    var hasMatrixChanged = !this._prevMat.equals(this.mat);
                    if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
                        len = this.comp.threeDElements.length;
                        var comp;
                        var perspectiveStyle;
                        var containerStyle;
                        for (i = 0; i < len; i += 1) {
                            comp = this.comp.threeDElements[i];
                            if (comp.type === "3d") {
                                if (hasMatrixChanged) {
                                    var matValue = this.mat.toCSS();
                                    containerStyle = comp.container.style;
                                    containerStyle.transform = matValue;
                                    containerStyle.webkitTransform = matValue;
                                }
                                if (this.pe._mdf) {
                                    perspectiveStyle = comp.perspectiveElem.style;
                                    perspectiveStyle.perspective = this.pe.v + "px";
                                    perspectiveStyle.webkitPerspective = this.pe.v + "px";
                                }
                            }
                        }
                        this.mat.clone(this._prevMat);
                    }
                }
                this._isFirstFrame = false;
            };
            HCameraElement.prototype.prepareFrame = function(num) {
                this.prepareProperties(num, true);
            };
            HCameraElement.prototype.destroy = function() {};
            HCameraElement.prototype.getBaseElement = function() {
                return null;
            };
            function HImageElement(data, globalData, comp) {
                this.assetData = globalData.getAssetData(data.refId);
                this.initElement(data, globalData, comp);
            }
            extendPrototype([ BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement ], HImageElement);
            HImageElement.prototype.createContent = function() {
                var assetPath = this.globalData.getAssetsPath(this.assetData);
                var img = new Image;
                if (this.data.hasMask) {
                    this.imageElem = createNS("image");
                    this.imageElem.setAttribute("width", this.assetData.w + "px");
                    this.imageElem.setAttribute("height", this.assetData.h + "px");
                    this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
                    this.layerElement.appendChild(this.imageElem);
                    this.baseElement.setAttribute("width", this.assetData.w);
                    this.baseElement.setAttribute("height", this.assetData.h);
                } else this.layerElement.appendChild(img);
                img.crossOrigin = "anonymous";
                img.src = assetPath;
                if (this.data.ln) this.baseElement.setAttribute("id", this.data.ln);
            };
            function HybridRendererBase(animationItem, config) {
                this.animationItem = animationItem;
                this.layers = null;
                this.renderedFrame = -1;
                this.renderConfig = {
                    className: config && config.className || "",
                    imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                    hideOnTransparent: !(config && config.hideOnTransparent === false),
                    filterSize: {
                        width: config && config.filterSize && config.filterSize.width || "400%",
                        height: config && config.filterSize && config.filterSize.height || "400%",
                        x: config && config.filterSize && config.filterSize.x || "-100%",
                        y: config && config.filterSize && config.filterSize.y || "-100%"
                    }
                };
                this.globalData = {
                    _mdf: false,
                    frameNum: -1,
                    renderConfig: this.renderConfig
                };
                this.pendingElements = [];
                this.elements = [];
                this.threeDElements = [];
                this.destroyed = false;
                this.camera = null;
                this.supports3d = true;
                this.rendererType = "html";
            }
            extendPrototype([ BaseRenderer ], HybridRendererBase);
            HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
            HybridRendererBase.prototype.checkPendingElements = function() {
                while (this.pendingElements.length) {
                    var element = this.pendingElements.pop();
                    element.checkParenting();
                }
            };
            HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
                var newDOMElement = element.getBaseElement();
                if (!newDOMElement) return;
                var layer = this.layers[pos];
                if (!layer.ddd || !this.supports3d) if (this.threeDElements) this.addTo3dContainer(newDOMElement, pos); else {
                    var i = 0;
                    var nextDOMElement;
                    var nextLayer;
                    var tmpDOMElement;
                    while (i < pos) {
                        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
                            nextLayer = this.elements[i];
                            tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
                            nextDOMElement = tmpDOMElement || nextDOMElement;
                        }
                        i += 1;
                    }
                    if (nextDOMElement) {
                        if (!layer.ddd || !this.supports3d) this.layerElement.insertBefore(newDOMElement, nextDOMElement);
                    } else if (!layer.ddd || !this.supports3d) this.layerElement.appendChild(newDOMElement);
                } else this.addTo3dContainer(newDOMElement, pos);
            };
            HybridRendererBase.prototype.createShape = function(data) {
                if (!this.supports3d) return new SVGShapeElement(data, this.globalData, this);
                return new HShapeElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createText = function(data) {
                if (!this.supports3d) return new SVGTextLottieElement(data, this.globalData, this);
                return new HTextElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createCamera = function(data) {
                this.camera = new HCameraElement(data, this.globalData, this);
                return this.camera;
            };
            HybridRendererBase.prototype.createImage = function(data) {
                if (!this.supports3d) return new IImageElement(data, this.globalData, this);
                return new HImageElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createSolid = function(data) {
                if (!this.supports3d) return new ISolidElement(data, this.globalData, this);
                return new HSolidElement(data, this.globalData, this);
            };
            HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
            HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
                var i = 0;
                var len = this.threeDElements.length;
                while (i < len) {
                    if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) return this.threeDElements[i].perspectiveElem;
                    i += 1;
                }
                return null;
            };
            HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
                var perspectiveElem = createTag("div");
                var style;
                var containerStyle;
                styleDiv(perspectiveElem);
                var container = createTag("div");
                styleDiv(container);
                if (type === "3d") {
                    style = perspectiveElem.style;
                    style.width = this.globalData.compSize.w + "px";
                    style.height = this.globalData.compSize.h + "px";
                    var center = "50% 50%";
                    style.webkitTransformOrigin = center;
                    style.mozTransformOrigin = center;
                    style.transformOrigin = center;
                    containerStyle = container.style;
                    var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    containerStyle.transform = matrix;
                    containerStyle.webkitTransform = matrix;
                }
                perspectiveElem.appendChild(container);
                var threeDContainerData = {
                    container,
                    perspectiveElem,
                    startPos: pos,
                    endPos: pos,
                    type
                };
                this.threeDElements.push(threeDContainerData);
                return threeDContainerData;
            };
            HybridRendererBase.prototype.build3dContainers = function() {
                var i;
                var len = this.layers.length;
                var lastThreeDContainerData;
                var currentContainer = "";
                for (i = 0; i < len; i += 1) if (this.layers[i].ddd && this.layers[i].ty !== 3) {
                    if (currentContainer !== "3d") {
                        currentContainer = "3d";
                        lastThreeDContainerData = this.createThreeDContainer(i, "3d");
                    }
                    lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
                } else {
                    if (currentContainer !== "2d") {
                        currentContainer = "2d";
                        lastThreeDContainerData = this.createThreeDContainer(i, "2d");
                    }
                    lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
                }
                len = this.threeDElements.length;
                for (i = len - 1; i >= 0; i -= 1) this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
            };
            HybridRendererBase.prototype.addTo3dContainer = function(elem, pos) {
                var i = 0;
                var len = this.threeDElements.length;
                while (i < len) {
                    if (pos <= this.threeDElements[i].endPos) {
                        var j = this.threeDElements[i].startPos;
                        var nextElement;
                        while (j < pos) {
                            if (this.elements[j] && this.elements[j].getBaseElement) nextElement = this.elements[j].getBaseElement();
                            j += 1;
                        }
                        if (nextElement) this.threeDElements[i].container.insertBefore(elem, nextElement); else this.threeDElements[i].container.appendChild(elem);
                        break;
                    }
                    i += 1;
                }
            };
            HybridRendererBase.prototype.configAnimation = function(animData) {
                var resizerElem = createTag("div");
                var wrapper = this.animationItem.wrapper;
                var style = resizerElem.style;
                style.width = animData.w + "px";
                style.height = animData.h + "px";
                this.resizerElem = resizerElem;
                styleDiv(resizerElem);
                style.transformStyle = "flat";
                style.mozTransformStyle = "flat";
                style.webkitTransformStyle = "flat";
                if (this.renderConfig.className) resizerElem.setAttribute("class", this.renderConfig.className);
                wrapper.appendChild(resizerElem);
                style.overflow = "hidden";
                var svg = createNS("svg");
                svg.setAttribute("width", "1");
                svg.setAttribute("height", "1");
                styleDiv(svg);
                this.resizerElem.appendChild(svg);
                var defs = createNS("defs");
                svg.appendChild(defs);
                this.data = animData;
                this.setupGlobalData(animData, svg);
                this.globalData.defs = defs;
                this.layers = animData.layers;
                this.layerElement = this.resizerElem;
                this.build3dContainers();
                this.updateContainerSize();
            };
            HybridRendererBase.prototype.destroy = function() {
                if (this.animationItem.wrapper) this.animationItem.wrapper.innerText = "";
                this.animationItem.container = null;
                this.globalData.defs = null;
                var i;
                var len = this.layers ? this.layers.length : 0;
                for (i = 0; i < len; i += 1) if (this.elements[i] && this.elements[i].destroy) this.elements[i].destroy();
                this.elements.length = 0;
                this.destroyed = true;
                this.animationItem = null;
            };
            HybridRendererBase.prototype.updateContainerSize = function() {
                var elementWidth = this.animationItem.wrapper.offsetWidth;
                var elementHeight = this.animationItem.wrapper.offsetHeight;
                var elementRel = elementWidth / elementHeight;
                var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
                var sx;
                var sy;
                var tx;
                var ty;
                if (animationRel > elementRel) {
                    sx = elementWidth / this.globalData.compSize.w;
                    sy = elementWidth / this.globalData.compSize.w;
                    tx = 0;
                    ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
                } else {
                    sx = elementHeight / this.globalData.compSize.h;
                    sy = elementHeight / this.globalData.compSize.h;
                    tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
                    ty = 0;
                }
                var style = this.resizerElem.style;
                style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
                style.transform = style.webkitTransform;
            };
            HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
            HybridRendererBase.prototype.hide = function() {
                this.resizerElem.style.display = "none";
            };
            HybridRendererBase.prototype.show = function() {
                this.resizerElem.style.display = "block";
            };
            HybridRendererBase.prototype.initItems = function() {
                this.buildAllItems();
                if (this.camera) this.camera.setup(); else {
                    var cWidth = this.globalData.compSize.w;
                    var cHeight = this.globalData.compSize.h;
                    var i;
                    var len = this.threeDElements.length;
                    for (i = 0; i < len; i += 1) {
                        var style = this.threeDElements[i].perspectiveElem.style;
                        style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
                        style.perspective = style.webkitPerspective;
                    }
                }
            };
            HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
                var i;
                var len = assets.length;
                var floatingContainer = createTag("div");
                for (i = 0; i < len; i += 1) if (assets[i].xt) {
                    var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
                    comp.initExpressions();
                    this.globalData.projectInterface.registerComposition(comp);
                }
            };
            function HCompElement(data, globalData, comp) {
                this.layers = data.layers;
                this.supports3d = !data.hasMask;
                this.completeLayers = false;
                this.pendingElements = [];
                this.elements = this.layers ? createSizedArray(this.layers.length) : [];
                this.initElement(data, globalData, comp);
                this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                    _placeholder: true
                };
            }
            extendPrototype([ HybridRendererBase, ICompElement, HBaseElement ], HCompElement);
            HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
            HCompElement.prototype.createContainerElements = function() {
                this._createBaseContainerElements();
                if (this.data.hasMask) {
                    this.svgElement.setAttribute("width", this.data.w);
                    this.svgElement.setAttribute("height", this.data.h);
                    this.transformedElement = this.baseElement;
                } else this.transformedElement = this.layerElement;
            };
            HCompElement.prototype.addTo3dContainer = function(elem, pos) {
                var j = 0;
                var nextElement;
                while (j < pos) {
                    if (this.elements[j] && this.elements[j].getBaseElement) nextElement = this.elements[j].getBaseElement();
                    j += 1;
                }
                if (nextElement) this.layerElement.insertBefore(elem, nextElement); else this.layerElement.appendChild(elem);
            };
            HCompElement.prototype.createComp = function(data) {
                if (!this.supports3d) return new SVGCompElement(data, this.globalData, this);
                return new HCompElement(data, this.globalData, this);
            };
            function HybridRenderer(animationItem, config) {
                this.animationItem = animationItem;
                this.layers = null;
                this.renderedFrame = -1;
                this.renderConfig = {
                    className: config && config.className || "",
                    imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                    hideOnTransparent: !(config && config.hideOnTransparent === false),
                    filterSize: {
                        width: config && config.filterSize && config.filterSize.width || "400%",
                        height: config && config.filterSize && config.filterSize.height || "400%",
                        x: config && config.filterSize && config.filterSize.x || "-100%",
                        y: config && config.filterSize && config.filterSize.y || "-100%"
                    },
                    runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
                };
                this.globalData = {
                    _mdf: false,
                    frameNum: -1,
                    renderConfig: this.renderConfig
                };
                this.pendingElements = [];
                this.elements = [];
                this.threeDElements = [];
                this.destroyed = false;
                this.camera = null;
                this.supports3d = true;
                this.rendererType = "html";
            }
            extendPrototype([ HybridRendererBase ], HybridRenderer);
            HybridRenderer.prototype.createComp = function(data) {
                if (!this.supports3d) return new SVGCompElement(data, this.globalData, this);
                return new HCompElement(data, this.globalData, this);
            };
            const CompExpressionInterface = function() {
                return function(comp) {
                    function _thisLayerFunction(name) {
                        var i = 0;
                        var len = comp.layers.length;
                        while (i < len) {
                            if (comp.layers[i].nm === name || comp.layers[i].ind === name) return comp.elements[i].layerInterface;
                            i += 1;
                        }
                        return null;
                    }
                    Object.defineProperty(_thisLayerFunction, "_name", {
                        value: comp.data.nm
                    });
                    _thisLayerFunction.layer = _thisLayerFunction;
                    _thisLayerFunction.pixelAspect = 1;
                    _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
                    _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
                    _thisLayerFunction.pixelAspect = 1;
                    _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
                    _thisLayerFunction.displayStartTime = 0;
                    _thisLayerFunction.numLayers = comp.layers.length;
                    return _thisLayerFunction;
                };
            }();
            function seedRandom(pool, math) {
                var nodecrypto, global = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1;
                function seedrandom(seed, options, callback) {
                    var key = [];
                    options = options === true ? {
                        entropy: true
                    } : options || {};
                    var shortseed = mixkey(flatten(options.entropy ? [ seed, tostring(pool) ] : seed === null ? autoseed() : seed, 3), key);
                    var arc4 = new ARC4(key);
                    var prng = function() {
                        var n = arc4.g(chunks), d = startdenom, x = 0;
                        while (n < significance) {
                            n = (n + x) * width;
                            d *= width;
                            x = arc4.g(1);
                        }
                        while (n >= overflow) {
                            n /= 2;
                            d /= 2;
                            x >>>= 1;
                        }
                        return (n + x) / d;
                    };
                    prng.int32 = function() {
                        return arc4.g(4) | 0;
                    };
                    prng.quick = function() {
                        return arc4.g(4) / 4294967296;
                    };
                    prng.double = prng;
                    mixkey(tostring(arc4.S), pool);
                    return (options.pass || callback || function(prng, seed, is_math_call, state) {
                        if (state) {
                            if (state.S) copy(state, arc4);
                            prng.state = function() {
                                return copy(arc4, {});
                            };
                        }
                        if (is_math_call) {
                            math[rngname] = prng;
                            return seed;
                        } else return prng;
                    })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
                }
                math["seed" + rngname] = seedrandom;
                function ARC4(key) {
                    var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
                    if (!keylen) key = [ keylen++ ];
                    while (i < width) s[i] = i++;
                    for (i = 0; i < width; i++) {
                        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
                        s[j] = t;
                    }
                    me.g = function(count) {
                        var t, r = 0, i = me.i, j = me.j, s = me.S;
                        while (count--) {
                            t = s[i = mask & i + 1];
                            r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
                        }
                        me.i = i;
                        me.j = j;
                        return r;
                    };
                }
                function copy(f, t) {
                    t.i = f.i;
                    t.j = f.j;
                    t.S = f.S.slice();
                    return t;
                }
                function flatten(obj, depth) {
                    var prop, result = [], typ = typeof obj;
                    if (depth && typ == "object") for (prop in obj) try {
                        result.push(flatten(obj[prop], depth - 1));
                    } catch (e) {}
                    return result.length ? result : typ == "string" ? obj : obj + "\0";
                }
                function mixkey(seed, key) {
                    var smear, stringseed = seed + "", j = 0;
                    while (j < stringseed.length) key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
                    return tostring(key);
                }
                function autoseed() {
                    try {
                        if (nodecrypto) return tostring(nodecrypto.randomBytes(width));
                        var out = new Uint8Array(width);
                        (global.crypto || global.msCrypto).getRandomValues(out);
                        return tostring(out);
                    } catch (e) {
                        var browser = global.navigator, plugins = browser && browser.plugins;
                        return [ +new Date, global, plugins, global.screen, tostring(pool) ];
                    }
                }
                function tostring(a) {
                    return String.fromCharCode.apply(0, a);
                }
                mixkey(math.random(), pool);
            }
            function initialize$2(BMMath) {
                seedRandom([], BMMath);
            }
            var propTypes = {
                SHAPE: "shape"
            };
            const ExpressionManager = function() {
                "use strict";
                var ob = {};
                var Math = BMMath;
                var window = null;
                var document = null;
                var XMLHttpRequest = null;
                var fetch = null;
                var frames = null;
                var _lottieGlobal = {};
                initialize$2(BMMath);
                function resetFrame() {
                    _lottieGlobal = {};
                }
                function $bm_isInstanceOfArray(arr) {
                    return arr.constructor === Array || arr.constructor === Float32Array;
                }
                function isNumerable(tOfV, v) {
                    return tOfV === "number" || v instanceof Number || tOfV === "boolean" || tOfV === "string";
                }
                function $bm_neg(a) {
                    var tOfA = typeof a;
                    if (tOfA === "number" || a instanceof Number || tOfA === "boolean") return -a;
                    if ($bm_isInstanceOfArray(a)) {
                        var i;
                        var lenA = a.length;
                        var retArr = [];
                        for (i = 0; i < lenA; i += 1) retArr[i] = -a[i];
                        return retArr;
                    }
                    if (a.propType) return a.v;
                    return -a;
                }
                var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get;
                var easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get;
                var easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
                function sum(a, b) {
                    var tOfA = typeof a;
                    var tOfB = typeof b;
                    if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === "string" || tOfB === "string") return a + b;
                    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                        a = a.slice(0);
                        a[0] += b;
                        return a;
                    }
                    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                        b = b.slice(0);
                        b[0] = a + b[0];
                        return b;
                    }
                    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                        var i = 0;
                        var lenA = a.length;
                        var lenB = b.length;
                        var retArr = [];
                        while (i < lenA || i < lenB) {
                            if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) retArr[i] = a[i] + b[i]; else retArr[i] = b[i] === void 0 ? a[i] : a[i] || b[i];
                            i += 1;
                        }
                        return retArr;
                    }
                    return 0;
                }
                var add = sum;
                function sub(a, b) {
                    var tOfA = typeof a;
                    var tOfB = typeof b;
                    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                        if (tOfA === "string") a = parseInt(a, 10);
                        if (tOfB === "string") b = parseInt(b, 10);
                        return a - b;
                    }
                    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                        a = a.slice(0);
                        a[0] -= b;
                        return a;
                    }
                    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                        b = b.slice(0);
                        b[0] = a - b[0];
                        return b;
                    }
                    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                        var i = 0;
                        var lenA = a.length;
                        var lenB = b.length;
                        var retArr = [];
                        while (i < lenA || i < lenB) {
                            if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) retArr[i] = a[i] - b[i]; else retArr[i] = b[i] === void 0 ? a[i] : a[i] || b[i];
                            i += 1;
                        }
                        return retArr;
                    }
                    return 0;
                }
                function mul(a, b) {
                    var tOfA = typeof a;
                    var tOfB = typeof b;
                    var arr;
                    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a * b;
                    var i;
                    var len;
                    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                        len = a.length;
                        arr = createTypedArray("float32", len);
                        for (i = 0; i < len; i += 1) arr[i] = a[i] * b;
                        return arr;
                    }
                    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                        len = b.length;
                        arr = createTypedArray("float32", len);
                        for (i = 0; i < len; i += 1) arr[i] = a * b[i];
                        return arr;
                    }
                    return 0;
                }
                function div(a, b) {
                    var tOfA = typeof a;
                    var tOfB = typeof b;
                    var arr;
                    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a / b;
                    var i;
                    var len;
                    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                        len = a.length;
                        arr = createTypedArray("float32", len);
                        for (i = 0; i < len; i += 1) arr[i] = a[i] / b;
                        return arr;
                    }
                    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                        len = b.length;
                        arr = createTypedArray("float32", len);
                        for (i = 0; i < len; i += 1) arr[i] = a / b[i];
                        return arr;
                    }
                    return 0;
                }
                function mod(a, b) {
                    if (typeof a === "string") a = parseInt(a, 10);
                    if (typeof b === "string") b = parseInt(b, 10);
                    return a % b;
                }
                var $bm_sum = sum;
                var $bm_sub = sub;
                var $bm_mul = mul;
                var $bm_div = div;
                var $bm_mod = mod;
                function clamp(num, min, max) {
                    if (min > max) {
                        var mm = max;
                        max = min;
                        min = mm;
                    }
                    return Math.min(Math.max(num, min), max);
                }
                function radiansToDegrees(val) {
                    return val / degToRads;
                }
                var radians_to_degrees = radiansToDegrees;
                function degreesToRadians(val) {
                    return val * degToRads;
                }
                var degrees_to_radians = radiansToDegrees;
                var helperLengthArray = [ 0, 0, 0, 0, 0, 0 ];
                function length(arr1, arr2) {
                    if (typeof arr1 === "number" || arr1 instanceof Number) {
                        arr2 = arr2 || 0;
                        return Math.abs(arr1 - arr2);
                    }
                    if (!arr2) arr2 = helperLengthArray;
                    var i;
                    var len = Math.min(arr1.length, arr2.length);
                    var addedLength = 0;
                    for (i = 0; i < len; i += 1) addedLength += Math.pow(arr2[i] - arr1[i], 2);
                    return Math.sqrt(addedLength);
                }
                function normalize(vec) {
                    return div(vec, length(vec));
                }
                function rgbToHsl(val) {
                    var r = val[0];
                    var g = val[1];
                    var b = val[2];
                    var max = Math.max(r, g, b);
                    var min = Math.min(r, g, b);
                    var h;
                    var s;
                    var l = (max + min) / 2;
                    if (max === min) {
                        h = 0;
                        s = 0;
                    } else {
                        var d = max - min;
                        s = l > .5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                          case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;

                          case g:
                            h = (b - r) / d + 2;
                            break;

                          case b:
                            h = (r - g) / d + 4;
                            break;

                          default:
                            break;
                        }
                        h /= 6;
                    }
                    return [ h, s, l, val[3] ];
                }
                function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }
                function hslToRgb(val) {
                    var h = val[0];
                    var s = val[1];
                    var l = val[2];
                    var r;
                    var g;
                    var b;
                    if (s === 0) {
                        r = l;
                        b = l;
                        g = l;
                    } else {
                        var q = l < .5 ? l * (1 + s) : l + s - l * s;
                        var p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1 / 3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1 / 3);
                    }
                    return [ r, g, b, val[3] ];
                }
                function linear(t, tMin, tMax, value1, value2) {
                    if (value1 === void 0 || value2 === void 0) {
                        value1 = tMin;
                        value2 = tMax;
                        tMin = 0;
                        tMax = 1;
                    }
                    if (tMax < tMin) {
                        var _tMin = tMax;
                        tMax = tMin;
                        tMin = _tMin;
                    }
                    if (t <= tMin) return value1;
                    if (t >= tMax) return value2;
                    var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
                    if (!value1.length) return value1 + (value2 - value1) * perc;
                    var i;
                    var len = value1.length;
                    var arr = createTypedArray("float32", len);
                    for (i = 0; i < len; i += 1) arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
                    return arr;
                }
                function random(min, max) {
                    if (max === void 0) if (min === void 0) {
                        min = 0;
                        max = 1;
                    } else {
                        max = min;
                        min = void 0;
                    }
                    if (max.length) {
                        var i;
                        var len = max.length;
                        if (!min) min = createTypedArray("float32", len);
                        var arr = createTypedArray("float32", len);
                        var rnd = BMMath.random();
                        for (i = 0; i < len; i += 1) arr[i] = min[i] + rnd * (max[i] - min[i]);
                        return arr;
                    }
                    if (min === void 0) min = 0;
                    var rndm = BMMath.random();
                    return min + rndm * (max - min);
                }
                function createPath(points, inTangents, outTangents, closed) {
                    var i;
                    var len = points.length;
                    var path = shapePool.newElement();
                    path.setPathData(!!closed, len);
                    var arrPlaceholder = [ 0, 0 ];
                    var inVertexPoint;
                    var outVertexPoint;
                    for (i = 0; i < len; i += 1) {
                        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
                        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
                        path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
                    }
                    return path;
                }
                function initiateExpression(elem, data, property) {
                    function noOp(_value) {
                        return _value;
                    }
                    if (!elem.globalData.renderConfig.runExpressions) return noOp;
                    var val = data.x;
                    var needsVelocity = /velocity(?![\w\d])/.test(val);
                    var _needsRandom = val.indexOf("random") !== -1;
                    var elemType = elem.data.ty;
                    var transform;
                    var $bm_transform;
                    var content;
                    var effect;
                    var thisProperty = property;
                    thisProperty.valueAtTime = thisProperty.getValueAtTime;
                    Object.defineProperty(thisProperty, "value", {
                        get: function() {
                            return thisProperty.v;
                        }
                    });
                    elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
                    elem.comp.displayStartTime = 0;
                    var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
                    var outPoint = elem.data.op / elem.comp.globalData.frameRate;
                    var width = elem.data.sw ? elem.data.sw : 0;
                    var height = elem.data.sh ? elem.data.sh : 0;
                    var name = elem.data.nm;
                    var loopIn;
                    var loop_in;
                    var loopOut;
                    var loop_out;
                    var smooth;
                    var toWorld;
                    var fromWorld;
                    var fromComp;
                    var toComp;
                    var fromCompToSurface;
                    var position;
                    var rotation;
                    var anchorPoint;
                    var scale;
                    var thisLayer;
                    var thisComp;
                    var mask;
                    var valueAtTime;
                    var velocityAtTime;
                    var scoped_bm_rt;
                    var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
                    var numKeys = property.kf ? data.k.length : 0;
                    var active = !this.data || this.data.hd !== true;
                    var wiggle = function wiggle(freq, amp) {
                        var iWiggle;
                        var j;
                        var lenWiggle = this.pv.length ? this.pv.length : 1;
                        var addedAmps = createTypedArray("float32", lenWiggle);
                        freq = 5;
                        var iterations = Math.floor(time * freq);
                        iWiggle = 0;
                        j = 0;
                        while (iWiggle < iterations) {
                            for (j = 0; j < lenWiggle; j += 1) addedAmps[j] += -amp + amp * 2 * BMMath.random();
                            iWiggle += 1;
                        }
                        var periods = time * freq;
                        var perc = periods - Math.floor(periods);
                        var arr = createTypedArray("float32", lenWiggle);
                        if (lenWiggle > 1) {
                            for (j = 0; j < lenWiggle; j += 1) arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
                            return arr;
                        }
                        return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
                    }.bind(this);
                    if (thisProperty.loopIn) {
                        loopIn = thisProperty.loopIn.bind(thisProperty);
                        loop_in = loopIn;
                    }
                    if (thisProperty.loopOut) {
                        loopOut = thisProperty.loopOut.bind(thisProperty);
                        loop_out = loopOut;
                    }
                    if (thisProperty.smooth) smooth = thisProperty.smooth.bind(thisProperty);
                    function loopInDuration(type, duration) {
                        return loopIn(type, duration, true);
                    }
                    function loopOutDuration(type, duration) {
                        return loopOut(type, duration, true);
                    }
                    if (this.getValueAtTime) valueAtTime = this.getValueAtTime.bind(this);
                    if (this.getVelocityAtTime) velocityAtTime = this.getVelocityAtTime.bind(this);
                    var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
                    function lookAt(elem1, elem2) {
                        var fVec = [ elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2] ];
                        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
                        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
                        return [ yaw, pitch, 0 ];
                    }
                    function easeOut(t, tMin, tMax, val1, val2) {
                        return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
                    }
                    function easeIn(t, tMin, tMax, val1, val2) {
                        return applyEase(easeInBez, t, tMin, tMax, val1, val2);
                    }
                    function ease(t, tMin, tMax, val1, val2) {
                        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
                    }
                    function applyEase(fn, t, tMin, tMax, val1, val2) {
                        if (val1 === void 0) {
                            val1 = tMin;
                            val2 = tMax;
                        } else t = (t - tMin) / (tMax - tMin);
                        if (t > 1) t = 1; else if (t < 0) t = 0;
                        var mult = fn(t);
                        if ($bm_isInstanceOfArray(val1)) {
                            var iKey;
                            var lenKey = val1.length;
                            var arr = createTypedArray("float32", lenKey);
                            for (iKey = 0; iKey < lenKey; iKey += 1) arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                            return arr;
                        }
                        return (val2 - val1) * mult + val1;
                    }
                    function nearestKey(time) {
                        var iKey;
                        var lenKey = data.k.length;
                        var index;
                        var keyTime;
                        if (!data.k.length || typeof data.k[0] === "number") {
                            index = 0;
                            keyTime = 0;
                        } else {
                            index = -1;
                            time *= elem.comp.globalData.frameRate;
                            if (time < data.k[0].t) {
                                index = 1;
                                keyTime = data.k[0].t;
                            } else {
                                for (iKey = 0; iKey < lenKey - 1; iKey += 1) if (time === data.k[iKey].t) {
                                    index = iKey + 1;
                                    keyTime = data.k[iKey].t;
                                    break;
                                } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
                                    if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                                        index = iKey + 2;
                                        keyTime = data.k[iKey + 1].t;
                                    } else {
                                        index = iKey + 1;
                                        keyTime = data.k[iKey].t;
                                    }
                                    break;
                                }
                                if (index === -1) {
                                    index = iKey + 1;
                                    keyTime = data.k[iKey].t;
                                }
                            }
                        }
                        var obKey = {};
                        obKey.index = index;
                        obKey.time = keyTime / elem.comp.globalData.frameRate;
                        return obKey;
                    }
                    function key(ind) {
                        var obKey;
                        var iKey;
                        var lenKey;
                        if (!data.k.length || typeof data.k[0] === "number") throw new Error("The property has no keyframe at index " + ind);
                        ind -= 1;
                        obKey = {
                            time: data.k[ind].t / elem.comp.globalData.frameRate,
                            value: []
                        };
                        var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
                        lenKey = arr.length;
                        for (iKey = 0; iKey < lenKey; iKey += 1) {
                            obKey[iKey] = arr[iKey];
                            obKey.value[iKey] = arr[iKey];
                        }
                        return obKey;
                    }
                    function framesToTime(fr, fps) {
                        if (!fps) fps = elem.comp.globalData.frameRate;
                        return fr / fps;
                    }
                    function timeToFrames(t, fps) {
                        if (!t && t !== 0) t = time;
                        if (!fps) fps = elem.comp.globalData.frameRate;
                        return t * fps;
                    }
                    function seedRandom(seed) {
                        BMMath.seedrandom(randSeed + seed);
                    }
                    function sourceRectAtTime() {
                        return elem.sourceRectAtTime();
                    }
                    function substring(init, end) {
                        if (typeof value === "string") {
                            if (end === void 0) return value.substring(init);
                            return value.substring(init, end);
                        }
                        return "";
                    }
                    function substr(init, end) {
                        if (typeof value === "string") {
                            if (end === void 0) return value.substr(init);
                            return value.substr(init, end);
                        }
                        return "";
                    }
                    function posterizeTime(framesPerSecond) {
                        time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
                        value = valueAtTime(time);
                    }
                    var time;
                    var velocity;
                    var value;
                    var text;
                    var textIndex;
                    var textTotal;
                    var selectorValue;
                    var index = elem.data.ind;
                    var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
                    var parent;
                    var randSeed = Math.floor(Math.random() * 1e6);
                    var globalData = elem.globalData;
                    function executeExpression(_value) {
                        value = _value;
                        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") return value;
                        if (this.propType === "textSelector") {
                            textIndex = this.textIndex;
                            textTotal = this.textTotal;
                            selectorValue = this.selectorValue;
                        }
                        if (!thisLayer) {
                            text = elem.layerInterface.text;
                            thisLayer = elem.layerInterface;
                            thisComp = elem.comp.compInterface;
                            toWorld = thisLayer.toWorld.bind(thisLayer);
                            fromWorld = thisLayer.fromWorld.bind(thisLayer);
                            fromComp = thisLayer.fromComp.bind(thisLayer);
                            toComp = thisLayer.toComp.bind(thisLayer);
                            mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                            fromCompToSurface = fromComp;
                        }
                        if (!transform) {
                            transform = elem.layerInterface("ADBE Transform Group");
                            $bm_transform = transform;
                            if (transform) anchorPoint = transform.anchorPoint;
                        }
                        if (elemType === 4 && !content) content = thisLayer("ADBE Root Vectors Group");
                        if (!effect) effect = thisLayer(4);
                        hasParent = !!(elem.hierarchy && elem.hierarchy.length);
                        if (hasParent && !parent) parent = elem.hierarchy[0].layerInterface;
                        time = this.comp.renderedFrame / this.comp.globalData.frameRate;
                        if (_needsRandom) seedRandom(randSeed + time);
                        if (needsVelocity) velocity = velocityAtTime(time);
                        expression_function();
                        this.frameExpressionId = elem.globalData.frameId;
                        scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
                        return scoped_bm_rt;
                    }
                    executeExpression.__preventDeadCodeRemoval = [ $bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData ];
                    return executeExpression;
                }
                ob.initiateExpression = initiateExpression;
                ob.__preventDeadCodeRemoval = [ window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal ];
                ob.resetFrame = resetFrame;
                return ob;
            }();
            const Expressions = function() {
                var ob = {};
                ob.initExpressions = initExpressions;
                ob.resetFrame = ExpressionManager.resetFrame;
                function initExpressions(animation) {
                    var stackCount = 0;
                    var registers = [];
                    function pushExpression() {
                        stackCount += 1;
                    }
                    function popExpression() {
                        stackCount -= 1;
                        if (stackCount === 0) releaseInstances();
                    }
                    function registerExpressionProperty(expression) {
                        if (registers.indexOf(expression) === -1) registers.push(expression);
                    }
                    function releaseInstances() {
                        var i;
                        var len = registers.length;
                        for (i = 0; i < len; i += 1) registers[i].release();
                        registers.length = 0;
                    }
                    animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
                    animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
                    animation.renderer.globalData.pushExpression = pushExpression;
                    animation.renderer.globalData.popExpression = popExpression;
                    animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
                }
                return ob;
            }();
            const MaskManagerInterface = function() {
                function MaskInterface(mask, data) {
                    this._mask = mask;
                    this._data = data;
                }
                Object.defineProperty(MaskInterface.prototype, "maskPath", {
                    get: function() {
                        if (this._mask.prop.k) this._mask.prop.getValue();
                        return this._mask.prop;
                    }
                });
                Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
                    get: function() {
                        if (this._mask.op.k) this._mask.op.getValue();
                        return this._mask.op.v * 100;
                    }
                });
                var MaskManager = function(maskManager) {
                    var _masksInterfaces = createSizedArray(maskManager.viewData.length);
                    var i;
                    var len = maskManager.viewData.length;
                    for (i = 0; i < len; i += 1) _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
                    var maskFunction = function(name) {
                        i = 0;
                        while (i < len) {
                            if (maskManager.masksProperties[i].nm === name) return _masksInterfaces[i];
                            i += 1;
                        }
                        return null;
                    };
                    return maskFunction;
                };
                return MaskManager;
            }();
            const ExpressionPropertyInterface = function() {
                var defaultUnidimensionalValue = {
                    pv: 0,
                    v: 0,
                    mult: 1
                };
                var defaultMultidimensionalValue = {
                    pv: [ 0, 0, 0 ],
                    v: [ 0, 0, 0 ],
                    mult: 1
                };
                function completeProperty(expressionValue, property, type) {
                    Object.defineProperty(expressionValue, "velocity", {
                        get: function() {
                            return property.getVelocityAtTime(property.comp.currentFrame);
                        }
                    });
                    expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
                    expressionValue.key = function(pos) {
                        if (!expressionValue.numKeys) return 0;
                        var value = "";
                        if ("s" in property.keyframes[pos - 1]) value = property.keyframes[pos - 1].s; else if ("e" in property.keyframes[pos - 2]) value = property.keyframes[pos - 2].e; else value = property.keyframes[pos - 2].s;
                        var valueProp = type === "unidimensional" ? new Number(value) : Object.assign({}, value);
                        valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
                        valueProp.value = type === "unidimensional" ? value[0] : value;
                        return valueProp;
                    };
                    expressionValue.valueAtTime = property.getValueAtTime;
                    expressionValue.speedAtTime = property.getSpeedAtTime;
                    expressionValue.velocityAtTime = property.getVelocityAtTime;
                    expressionValue.propertyGroup = property.propertyGroup;
                }
                function UnidimensionalPropertyInterface(property) {
                    if (!property || !("pv" in property)) property = defaultUnidimensionalValue;
                    var mult = 1 / property.mult;
                    var val = property.pv * mult;
                    var expressionValue = new Number(val);
                    expressionValue.value = val;
                    completeProperty(expressionValue, property, "unidimensional");
                    return function() {
                        if (property.k) property.getValue();
                        val = property.v * mult;
                        if (expressionValue.value !== val) {
                            expressionValue = new Number(val);
                            expressionValue.value = val;
                            completeProperty(expressionValue, property, "unidimensional");
                        }
                        return expressionValue;
                    };
                }
                function MultidimensionalPropertyInterface(property) {
                    if (!property || !("pv" in property)) property = defaultMultidimensionalValue;
                    var mult = 1 / property.mult;
                    var len = property.data && property.data.l || property.pv.length;
                    var expressionValue = createTypedArray("float32", len);
                    var arrValue = createTypedArray("float32", len);
                    expressionValue.value = arrValue;
                    completeProperty(expressionValue, property, "multidimensional");
                    return function() {
                        if (property.k) property.getValue();
                        for (var i = 0; i < len; i += 1) {
                            arrValue[i] = property.v[i] * mult;
                            expressionValue[i] = arrValue[i];
                        }
                        return expressionValue;
                    };
                }
                function defaultGetter() {
                    return defaultUnidimensionalValue;
                }
                return function(property) {
                    if (!property) return defaultGetter;
                    if (property.propType === "unidimensional") return UnidimensionalPropertyInterface(property);
                    return MultidimensionalPropertyInterface(property);
                };
            }();
            const TransformExpressionInterface = function() {
                return function(transform) {
                    function _thisFunction(name) {
                        switch (name) {
                          case "scale":
                          case "Scale":
                          case "ADBE Scale":
                          case 6:
                            return _thisFunction.scale;

                          case "rotation":
                          case "Rotation":
                          case "ADBE Rotation":
                          case "ADBE Rotate Z":
                          case 10:
                            return _thisFunction.rotation;

                          case "ADBE Rotate X":
                            return _thisFunction.xRotation;

                          case "ADBE Rotate Y":
                            return _thisFunction.yRotation;

                          case "position":
                          case "Position":
                          case "ADBE Position":
                          case 2:
                            return _thisFunction.position;

                          case "ADBE Position_0":
                            return _thisFunction.xPosition;

                          case "ADBE Position_1":
                            return _thisFunction.yPosition;

                          case "ADBE Position_2":
                            return _thisFunction.zPosition;

                          case "anchorPoint":
                          case "AnchorPoint":
                          case "Anchor Point":
                          case "ADBE AnchorPoint":
                          case 1:
                            return _thisFunction.anchorPoint;

                          case "opacity":
                          case "Opacity":
                          case 11:
                            return _thisFunction.opacity;

                          default:
                            return null;
                        }
                    }
                    Object.defineProperty(_thisFunction, "rotation", {
                        get: ExpressionPropertyInterface(transform.r || transform.rz)
                    });
                    Object.defineProperty(_thisFunction, "zRotation", {
                        get: ExpressionPropertyInterface(transform.rz || transform.r)
                    });
                    Object.defineProperty(_thisFunction, "xRotation", {
                        get: ExpressionPropertyInterface(transform.rx)
                    });
                    Object.defineProperty(_thisFunction, "yRotation", {
                        get: ExpressionPropertyInterface(transform.ry)
                    });
                    Object.defineProperty(_thisFunction, "scale", {
                        get: ExpressionPropertyInterface(transform.s)
                    });
                    var _px;
                    var _py;
                    var _pz;
                    var _transformFactory;
                    if (transform.p) _transformFactory = ExpressionPropertyInterface(transform.p); else {
                        _px = ExpressionPropertyInterface(transform.px);
                        _py = ExpressionPropertyInterface(transform.py);
                        if (transform.pz) _pz = ExpressionPropertyInterface(transform.pz);
                    }
                    Object.defineProperty(_thisFunction, "position", {
                        get: function() {
                            if (transform.p) return _transformFactory();
                            return [ _px(), _py(), _pz ? _pz() : 0 ];
                        }
                    });
                    Object.defineProperty(_thisFunction, "xPosition", {
                        get: ExpressionPropertyInterface(transform.px)
                    });
                    Object.defineProperty(_thisFunction, "yPosition", {
                        get: ExpressionPropertyInterface(transform.py)
                    });
                    Object.defineProperty(_thisFunction, "zPosition", {
                        get: ExpressionPropertyInterface(transform.pz)
                    });
                    Object.defineProperty(_thisFunction, "anchorPoint", {
                        get: ExpressionPropertyInterface(transform.a)
                    });
                    Object.defineProperty(_thisFunction, "opacity", {
                        get: ExpressionPropertyInterface(transform.o)
                    });
                    Object.defineProperty(_thisFunction, "skew", {
                        get: ExpressionPropertyInterface(transform.sk)
                    });
                    Object.defineProperty(_thisFunction, "skewAxis", {
                        get: ExpressionPropertyInterface(transform.sa)
                    });
                    Object.defineProperty(_thisFunction, "orientation", {
                        get: ExpressionPropertyInterface(transform.or)
                    });
                    return _thisFunction;
                };
            }();
            const LayerExpressionInterface = function() {
                function getMatrix(time) {
                    var toWorldMat = new Matrix;
                    if (time !== void 0) {
                        var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
                        propMatrix.clone(toWorldMat);
                    } else {
                        var transformMat = this._elem.finalTransform.mProp;
                        transformMat.applyToMatrix(toWorldMat);
                    }
                    return toWorldMat;
                }
                function toWorldVec(arr, time) {
                    var toWorldMat = this.getMatrix(time);
                    toWorldMat.props[12] = 0;
                    toWorldMat.props[13] = 0;
                    toWorldMat.props[14] = 0;
                    return this.applyPoint(toWorldMat, arr);
                }
                function toWorld(arr, time) {
                    var toWorldMat = this.getMatrix(time);
                    return this.applyPoint(toWorldMat, arr);
                }
                function fromWorldVec(arr, time) {
                    var toWorldMat = this.getMatrix(time);
                    toWorldMat.props[12] = 0;
                    toWorldMat.props[13] = 0;
                    toWorldMat.props[14] = 0;
                    return this.invertPoint(toWorldMat, arr);
                }
                function fromWorld(arr, time) {
                    var toWorldMat = this.getMatrix(time);
                    return this.invertPoint(toWorldMat, arr);
                }
                function applyPoint(matrix, arr) {
                    if (this._elem.hierarchy && this._elem.hierarchy.length) {
                        var i;
                        var len = this._elem.hierarchy.length;
                        for (i = 0; i < len; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
                    }
                    return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
                }
                function invertPoint(matrix, arr) {
                    if (this._elem.hierarchy && this._elem.hierarchy.length) {
                        var i;
                        var len = this._elem.hierarchy.length;
                        for (i = 0; i < len; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
                    }
                    return matrix.inversePoint(arr);
                }
                function fromComp(arr) {
                    var toWorldMat = new Matrix;
                    toWorldMat.reset();
                    this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
                    if (this._elem.hierarchy && this._elem.hierarchy.length) {
                        var i;
                        var len = this._elem.hierarchy.length;
                        for (i = 0; i < len; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                        return toWorldMat.inversePoint(arr);
                    }
                    return toWorldMat.inversePoint(arr);
                }
                function sampleImage() {
                    return [ 1, 1, 1, 1 ];
                }
                return function(elem) {
                    var transformInterface;
                    function _registerMaskInterface(maskManager) {
                        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
                    }
                    function _registerEffectsInterface(effects) {
                        _thisLayerFunction.effect = effects;
                    }
                    function _thisLayerFunction(name) {
                        switch (name) {
                          case "ADBE Root Vectors Group":
                          case "Contents":
                          case 2:
                            return _thisLayerFunction.shapeInterface;

                          case 1:
                          case 6:
                          case "Transform":
                          case "transform":
                          case "ADBE Transform Group":
                            return transformInterface;

                          case 4:
                          case "ADBE Effect Parade":
                          case "effects":
                          case "Effects":
                            return _thisLayerFunction.effect;

                          case "ADBE Text Properties":
                            return _thisLayerFunction.textInterface;

                          default:
                            return null;
                        }
                    }
                    _thisLayerFunction.getMatrix = getMatrix;
                    _thisLayerFunction.invertPoint = invertPoint;
                    _thisLayerFunction.applyPoint = applyPoint;
                    _thisLayerFunction.toWorld = toWorld;
                    _thisLayerFunction.toWorldVec = toWorldVec;
                    _thisLayerFunction.fromWorld = fromWorld;
                    _thisLayerFunction.fromWorldVec = fromWorldVec;
                    _thisLayerFunction.toComp = toWorld;
                    _thisLayerFunction.fromComp = fromComp;
                    _thisLayerFunction.sampleImage = sampleImage;
                    _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
                    _thisLayerFunction._elem = elem;
                    transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
                    var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
                    Object.defineProperties(_thisLayerFunction, {
                        hasParent: {
                            get: function() {
                                return elem.hierarchy.length;
                            }
                        },
                        parent: {
                            get: function() {
                                return elem.hierarchy[0].layerInterface;
                            }
                        },
                        rotation: getDescriptor(transformInterface, "rotation"),
                        scale: getDescriptor(transformInterface, "scale"),
                        position: getDescriptor(transformInterface, "position"),
                        opacity: getDescriptor(transformInterface, "opacity"),
                        anchorPoint: anchorPointDescriptor,
                        anchor_point: anchorPointDescriptor,
                        transform: {
                            get: function() {
                                return transformInterface;
                            }
                        },
                        active: {
                            get: function() {
                                return elem.isInRange;
                            }
                        }
                    });
                    _thisLayerFunction.startTime = elem.data.st;
                    _thisLayerFunction.index = elem.data.ind;
                    _thisLayerFunction.source = elem.data.refId;
                    _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
                    _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
                    _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
                    _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
                    _thisLayerFunction._name = elem.data.nm;
                    _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
                    _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
                    return _thisLayerFunction;
                };
            }();
            const propertyGroupFactory = function() {
                return function(interfaceFunction, parentPropertyGroup) {
                    return function(val) {
                        val = val === void 0 ? 1 : val;
                        if (val <= 0) return interfaceFunction;
                        return parentPropertyGroup(val - 1);
                    };
                };
            }();
            const PropertyInterface = function() {
                return function(propertyName, propertyGroup) {
                    var interfaceFunction = {
                        _name: propertyName
                    };
                    function _propertyGroup(val) {
                        val = val === void 0 ? 1 : val;
                        if (val <= 0) return interfaceFunction;
                        return propertyGroup(val - 1);
                    }
                    return _propertyGroup;
                };
            }();
            const EffectsExpressionInterface = function() {
                var ob = {
                    createEffectsInterface
                };
                function createEffectsInterface(elem, propertyGroup) {
                    if (elem.effectsManager) {
                        var effectElements = [];
                        var effectsData = elem.data.ef;
                        var i;
                        var len = elem.effectsManager.effectElements.length;
                        for (i = 0; i < len; i += 1) effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
                        var effects = elem.data.ef || [];
                        var groupInterface = function(name) {
                            i = 0;
                            len = effects.length;
                            while (i < len) {
                                if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) return effectElements[i];
                                i += 1;
                            }
                            return null;
                        };
                        Object.defineProperty(groupInterface, "numProperties", {
                            get: function() {
                                return effects.length;
                            }
                        });
                        return groupInterface;
                    }
                    return null;
                }
                function createGroupInterface(data, elements, propertyGroup, elem) {
                    function groupInterface(name) {
                        var effects = data.ef;
                        var i = 0;
                        var len = effects.length;
                        while (i < len) {
                            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                                if (effects[i].ty === 5) return effectElements[i];
                                return effectElements[i]();
                            }
                            i += 1;
                        }
                        throw new Error;
                    }
                    var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
                    var effectElements = [];
                    var i;
                    var len = data.ef.length;
                    for (i = 0; i < len; i += 1) if (data.ef[i].ty === 5) effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem)); else effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
                    if (data.mn === "ADBE Color Control") Object.defineProperty(groupInterface, "color", {
                        get: function() {
                            return effectElements[0]();
                        }
                    });
                    Object.defineProperties(groupInterface, {
                        numProperties: {
                            get: function() {
                                return data.np;
                            }
                        },
                        _name: {
                            value: data.nm
                        },
                        propertyGroup: {
                            value: _propertyGroup
                        }
                    });
                    groupInterface.enabled = data.en !== 0;
                    groupInterface.active = groupInterface.enabled;
                    return groupInterface;
                }
                function createValueInterface(element, type, elem, propertyGroup) {
                    var expressionProperty = ExpressionPropertyInterface(element.p);
                    function interfaceFunction() {
                        if (type === 10) return elem.comp.compInterface(element.p.v);
                        return expressionProperty();
                    }
                    if (element.p.setGroupProperty) element.p.setGroupProperty(PropertyInterface("", propertyGroup));
                    return interfaceFunction;
                }
                return ob;
            }();
            const ShapePathInterface = function() {
                return function pathInterfaceFactory(shape, view, propertyGroup) {
                    var prop = view.sh;
                    function interfaceFunction(val) {
                        if (val === "Shape" || val === "shape" || val === "Path" || val === "path" || val === "ADBE Vector Shape" || val === 2) return interfaceFunction.path;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
                    Object.defineProperties(interfaceFunction, {
                        path: {
                            get: function() {
                                if (prop.k) prop.getValue();
                                return prop;
                            }
                        },
                        shape: {
                            get: function() {
                                if (prop.k) prop.getValue();
                                return prop;
                            }
                        },
                        _name: {
                            value: shape.nm
                        },
                        ix: {
                            value: shape.ix
                        },
                        propertyIndex: {
                            value: shape.ix
                        },
                        mn: {
                            value: shape.mn
                        },
                        propertyGroup: {
                            value: propertyGroup
                        }
                    });
                    return interfaceFunction;
                };
            }();
            const ShapeExpressionInterface = function() {
                function iterateElements(shapes, view, propertyGroup) {
                    var arr = [];
                    var i;
                    var len = shapes ? shapes.length : 0;
                    for (i = 0; i < len; i += 1) if (shapes[i].ty === "gr") arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "fl") arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "st") arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "tm") arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "tr") ; else if (shapes[i].ty === "el") arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "sr") arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "sh") arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "rc") arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "rd") arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "rp") arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup)); else if (shapes[i].ty === "gf") arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup)); else arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
                    return arr;
                }
                function contentsInterfaceFactory(shape, view, propertyGroup) {
                    var interfaces;
                    var interfaceFunction = function _interfaceFunction(value) {
                        var i = 0;
                        var len = interfaces.length;
                        while (i < len) {
                            if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) return interfaces[i];
                            i += 1;
                        }
                        if (typeof value === "number") return interfaces[value - 1];
                        return null;
                    };
                    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
                    interfaceFunction.numProperties = interfaces.length;
                    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
                    interfaceFunction.transform = transformInterface;
                    interfaceFunction.propertyIndex = shape.cix;
                    interfaceFunction._name = shape.nm;
                    return interfaceFunction;
                }
                function groupInterfaceFactory(shape, view, propertyGroup) {
                    var interfaceFunction = function _interfaceFunction(value) {
                        switch (value) {
                          case "ADBE Vectors Group":
                          case "Contents":
                          case 2:
                            return interfaceFunction.content;

                          default:
                            return interfaceFunction.transform;
                        }
                    };
                    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
                    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
                    interfaceFunction.content = content;
                    interfaceFunction.transform = transformInterface;
                    Object.defineProperty(interfaceFunction, "_name", {
                        get: function() {
                            return shape.nm;
                        }
                    });
                    interfaceFunction.numProperties = shape.np;
                    interfaceFunction.propertyIndex = shape.ix;
                    interfaceFunction.nm = shape.nm;
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                function fillInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(val) {
                        if (val === "Color" || val === "color") return interfaceFunction.color;
                        if (val === "Opacity" || val === "opacity") return interfaceFunction.opacity;
                        return null;
                    }
                    Object.defineProperties(interfaceFunction, {
                        color: {
                            get: ExpressionPropertyInterface(view.c)
                        },
                        opacity: {
                            get: ExpressionPropertyInterface(view.o)
                        },
                        _name: {
                            value: shape.nm
                        },
                        mn: {
                            value: shape.mn
                        }
                    });
                    view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
                    view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
                    return interfaceFunction;
                }
                function gradientFillInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(val) {
                        if (val === "Start Point" || val === "start point") return interfaceFunction.startPoint;
                        if (val === "End Point" || val === "end point") return interfaceFunction.endPoint;
                        if (val === "Opacity" || val === "opacity") return interfaceFunction.opacity;
                        return null;
                    }
                    Object.defineProperties(interfaceFunction, {
                        startPoint: {
                            get: ExpressionPropertyInterface(view.s)
                        },
                        endPoint: {
                            get: ExpressionPropertyInterface(view.e)
                        },
                        opacity: {
                            get: ExpressionPropertyInterface(view.o)
                        },
                        type: {
                            get: function() {
                                return "a";
                            }
                        },
                        _name: {
                            value: shape.nm
                        },
                        mn: {
                            value: shape.mn
                        }
                    });
                    view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
                    view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
                    view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
                    return interfaceFunction;
                }
                function defaultInterfaceFactory() {
                    function interfaceFunction() {
                        return null;
                    }
                    return interfaceFunction;
                }
                function strokeInterfaceFactory(shape, view, propertyGroup) {
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
                    function addPropertyToDashOb(i) {
                        Object.defineProperty(dashOb, shape.d[i].nm, {
                            get: ExpressionPropertyInterface(view.d.dataProps[i].p)
                        });
                    }
                    var i;
                    var len = shape.d ? shape.d.length : 0;
                    var dashOb = {};
                    for (i = 0; i < len; i += 1) {
                        addPropertyToDashOb(i);
                        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
                    }
                    function interfaceFunction(val) {
                        if (val === "Color" || val === "color") return interfaceFunction.color;
                        if (val === "Opacity" || val === "opacity") return interfaceFunction.opacity;
                        if (val === "Stroke Width" || val === "stroke width") return interfaceFunction.strokeWidth;
                        return null;
                    }
                    Object.defineProperties(interfaceFunction, {
                        color: {
                            get: ExpressionPropertyInterface(view.c)
                        },
                        opacity: {
                            get: ExpressionPropertyInterface(view.o)
                        },
                        strokeWidth: {
                            get: ExpressionPropertyInterface(view.w)
                        },
                        dash: {
                            get: function() {
                                return dashOb;
                            }
                        },
                        _name: {
                            value: shape.nm
                        },
                        mn: {
                            value: shape.mn
                        }
                    });
                    view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
                    view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
                    view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
                    return interfaceFunction;
                }
                function trimInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(val) {
                        if (val === shape.e.ix || val === "End" || val === "end") return interfaceFunction.end;
                        if (val === shape.s.ix) return interfaceFunction.start;
                        if (val === shape.o.ix) return interfaceFunction.offset;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    interfaceFunction.propertyIndex = shape.ix;
                    view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
                    view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
                    view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
                    interfaceFunction.propertyIndex = shape.ix;
                    interfaceFunction.propertyGroup = propertyGroup;
                    Object.defineProperties(interfaceFunction, {
                        start: {
                            get: ExpressionPropertyInterface(view.s)
                        },
                        end: {
                            get: ExpressionPropertyInterface(view.e)
                        },
                        offset: {
                            get: ExpressionPropertyInterface(view.o)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                function transformInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(value) {
                        if (shape.a.ix === value || value === "Anchor Point") return interfaceFunction.anchorPoint;
                        if (shape.o.ix === value || value === "Opacity") return interfaceFunction.opacity;
                        if (shape.p.ix === value || value === "Position") return interfaceFunction.position;
                        if (shape.r.ix === value || value === "Rotation" || value === "ADBE Vector Rotation") return interfaceFunction.rotation;
                        if (shape.s.ix === value || value === "Scale") return interfaceFunction.scale;
                        if (shape.sk && shape.sk.ix === value || value === "Skew") return interfaceFunction.skew;
                        if (shape.sa && shape.sa.ix === value || value === "Skew Axis") return interfaceFunction.skewAxis;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
                    view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
                    view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
                    view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
                    view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
                    if (view.transform.mProps.sk) {
                        view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
                        view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
                    }
                    view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
                    Object.defineProperties(interfaceFunction, {
                        opacity: {
                            get: ExpressionPropertyInterface(view.transform.mProps.o)
                        },
                        position: {
                            get: ExpressionPropertyInterface(view.transform.mProps.p)
                        },
                        anchorPoint: {
                            get: ExpressionPropertyInterface(view.transform.mProps.a)
                        },
                        scale: {
                            get: ExpressionPropertyInterface(view.transform.mProps.s)
                        },
                        rotation: {
                            get: ExpressionPropertyInterface(view.transform.mProps.r)
                        },
                        skew: {
                            get: ExpressionPropertyInterface(view.transform.mProps.sk)
                        },
                        skewAxis: {
                            get: ExpressionPropertyInterface(view.transform.mProps.sa)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.ty = "tr";
                    interfaceFunction.mn = shape.mn;
                    interfaceFunction.propertyGroup = propertyGroup;
                    return interfaceFunction;
                }
                function ellipseInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(value) {
                        if (shape.p.ix === value) return interfaceFunction.position;
                        if (shape.s.ix === value) return interfaceFunction.size;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    interfaceFunction.propertyIndex = shape.ix;
                    var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
                    prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
                    prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
                    Object.defineProperties(interfaceFunction, {
                        size: {
                            get: ExpressionPropertyInterface(prop.s)
                        },
                        position: {
                            get: ExpressionPropertyInterface(prop.p)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                function starInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(value) {
                        if (shape.p.ix === value) return interfaceFunction.position;
                        if (shape.r.ix === value) return interfaceFunction.rotation;
                        if (shape.pt.ix === value) return interfaceFunction.points;
                        if (shape.or.ix === value || value === "ADBE Vector Star Outer Radius") return interfaceFunction.outerRadius;
                        if (shape.os.ix === value) return interfaceFunction.outerRoundness;
                        if (shape.ir && (shape.ir.ix === value || value === "ADBE Vector Star Inner Radius")) return interfaceFunction.innerRadius;
                        if (shape.is && shape.is.ix === value) return interfaceFunction.innerRoundness;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
                    interfaceFunction.propertyIndex = shape.ix;
                    prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
                    prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
                    prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
                    prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
                    prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
                    if (shape.ir) {
                        prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
                        prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
                    }
                    Object.defineProperties(interfaceFunction, {
                        position: {
                            get: ExpressionPropertyInterface(prop.p)
                        },
                        rotation: {
                            get: ExpressionPropertyInterface(prop.r)
                        },
                        points: {
                            get: ExpressionPropertyInterface(prop.pt)
                        },
                        outerRadius: {
                            get: ExpressionPropertyInterface(prop.or)
                        },
                        outerRoundness: {
                            get: ExpressionPropertyInterface(prop.os)
                        },
                        innerRadius: {
                            get: ExpressionPropertyInterface(prop.ir)
                        },
                        innerRoundness: {
                            get: ExpressionPropertyInterface(prop.is)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                function rectInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(value) {
                        if (shape.p.ix === value) return interfaceFunction.position;
                        if (shape.r.ix === value) return interfaceFunction.roundness;
                        if (shape.s.ix === value || value === "Size" || value === "ADBE Vector Rect Size") return interfaceFunction.size;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
                    interfaceFunction.propertyIndex = shape.ix;
                    prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
                    prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
                    prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
                    Object.defineProperties(interfaceFunction, {
                        position: {
                            get: ExpressionPropertyInterface(prop.p)
                        },
                        roundness: {
                            get: ExpressionPropertyInterface(prop.r)
                        },
                        size: {
                            get: ExpressionPropertyInterface(prop.s)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                function roundedInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(value) {
                        if (shape.r.ix === value || value === "Round Corners 1") return interfaceFunction.radius;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    var prop = view;
                    interfaceFunction.propertyIndex = shape.ix;
                    prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
                    Object.defineProperties(interfaceFunction, {
                        radius: {
                            get: ExpressionPropertyInterface(prop.rd)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                function repeaterInterfaceFactory(shape, view, propertyGroup) {
                    function interfaceFunction(value) {
                        if (shape.c.ix === value || value === "Copies") return interfaceFunction.copies;
                        if (shape.o.ix === value || value === "Offset") return interfaceFunction.offset;
                        return null;
                    }
                    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                    var prop = view;
                    interfaceFunction.propertyIndex = shape.ix;
                    prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
                    prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
                    Object.defineProperties(interfaceFunction, {
                        copies: {
                            get: ExpressionPropertyInterface(prop.c)
                        },
                        offset: {
                            get: ExpressionPropertyInterface(prop.o)
                        },
                        _name: {
                            value: shape.nm
                        }
                    });
                    interfaceFunction.mn = shape.mn;
                    return interfaceFunction;
                }
                return function(shapes, view, propertyGroup) {
                    var interfaces;
                    function _interfaceFunction(value) {
                        if (typeof value === "number") {
                            value = value === void 0 ? 1 : value;
                            if (value === 0) return propertyGroup;
                            return interfaces[value - 1];
                        }
                        var i = 0;
                        var len = interfaces.length;
                        while (i < len) {
                            if (interfaces[i]._name === value) return interfaces[i];
                            i += 1;
                        }
                        return null;
                    }
                    function parentGroupWrapper() {
                        return propertyGroup;
                    }
                    _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
                    interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
                    _interfaceFunction.numProperties = interfaces.length;
                    _interfaceFunction._name = "Contents";
                    return _interfaceFunction;
                };
            }();
            const TextExpressionInterface = function() {
                return function(elem) {
                    var _sourceText;
                    function _thisLayerFunction(name) {
                        switch (name) {
                          case "ADBE Text Document":
                            return _thisLayerFunction.sourceText;

                          default:
                            return null;
                        }
                    }
                    Object.defineProperty(_thisLayerFunction, "sourceText", {
                        get: function() {
                            elem.textProperty.getValue();
                            var stringValue = elem.textProperty.currentData.t;
                            if (!_sourceText || stringValue !== _sourceText.value) {
                                _sourceText = new String(stringValue);
                                _sourceText.value = stringValue || new String(stringValue);
                                Object.defineProperty(_sourceText, "style", {
                                    get: function() {
                                        return {
                                            fillColor: elem.textProperty.currentData.fc
                                        };
                                    }
                                });
                            }
                            return _sourceText;
                        }
                    });
                    return _thisLayerFunction;
                };
            }();
            const FootageInterface = function() {
                var outlineInterfaceFactory = function(elem) {
                    var currentPropertyName = "";
                    var currentProperty = elem.getFootageData();
                    function init() {
                        currentPropertyName = "";
                        currentProperty = elem.getFootageData();
                        return searchProperty;
                    }
                    function searchProperty(value) {
                        if (currentProperty[value]) {
                            currentPropertyName = value;
                            currentProperty = currentProperty[value];
                            if (typeof currentProperty === "object") return searchProperty;
                            return currentProperty;
                        }
                        var propertyNameIndex = value.indexOf(currentPropertyName);
                        if (propertyNameIndex !== -1) {
                            var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
                            currentProperty = currentProperty[index];
                            if (typeof currentProperty === "object") return searchProperty;
                            return currentProperty;
                        }
                        return "";
                    }
                    return init;
                };
                var dataInterfaceFactory = function(elem) {
                    function interfaceFunction(value) {
                        if (value === "Outline") return interfaceFunction.outlineInterface();
                        return null;
                    }
                    interfaceFunction._name = "Outline";
                    interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
                    return interfaceFunction;
                };
                return function(elem) {
                    function _interfaceFunction(value) {
                        if (value === "Data") return _interfaceFunction.dataInterface;
                        return null;
                    }
                    _interfaceFunction._name = "Data";
                    _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
                    return _interfaceFunction;
                };
            }();
            var interfaces = {
                layer: LayerExpressionInterface,
                effects: EffectsExpressionInterface,
                comp: CompExpressionInterface,
                shape: ShapeExpressionInterface,
                text: TextExpressionInterface,
                footage: FootageInterface
            };
            function getInterface(type) {
                return interfaces[type] || null;
            }
            const expressionHelpers = function() {
                function searchExpressions(elem, data, prop) {
                    if (data.x) {
                        prop.k = true;
                        prop.x = true;
                        prop.initiateExpression = ExpressionManager.initiateExpression;
                        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
                    }
                }
                function getValueAtTime(frameNum) {
                    frameNum *= this.elem.globalData.frameRate;
                    frameNum -= this.offsetTime;
                    if (frameNum !== this._cachingAtTime.lastFrame) {
                        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
                        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
                        this._cachingAtTime.lastFrame = frameNum;
                    }
                    return this._cachingAtTime.value;
                }
                function getSpeedAtTime(frameNum) {
                    var delta = -.01;
                    var v1 = this.getValueAtTime(frameNum);
                    var v2 = this.getValueAtTime(frameNum + delta);
                    var speed = 0;
                    if (v1.length) {
                        var i;
                        for (i = 0; i < v1.length; i += 1) speed += Math.pow(v2[i] - v1[i], 2);
                        speed = Math.sqrt(speed) * 100;
                    } else speed = 0;
                    return speed;
                }
                function getVelocityAtTime(frameNum) {
                    if (this.vel !== void 0) return this.vel;
                    var delta = -.001;
                    var v1 = this.getValueAtTime(frameNum);
                    var v2 = this.getValueAtTime(frameNum + delta);
                    var velocity;
                    if (v1.length) {
                        velocity = createTypedArray("float32", v1.length);
                        var i;
                        for (i = 0; i < v1.length; i += 1) velocity[i] = (v2[i] - v1[i]) / delta;
                    } else velocity = (v2 - v1) / delta;
                    return velocity;
                }
                function getStaticValueAtTime() {
                    return this.pv;
                }
                function setGroupProperty(propertyGroup) {
                    this.propertyGroup = propertyGroup;
                }
                return {
                    searchExpressions,
                    getSpeedAtTime,
                    getVelocityAtTime,
                    getValueAtTime,
                    getStaticValueAtTime,
                    setGroupProperty
                };
            }();
            function addPropertyDecorator() {
                function loopOut(type, duration, durationFlag) {
                    if (!this.k || !this.keyframes) return this.pv;
                    type = type ? type.toLowerCase() : "";
                    var currentFrame = this.comp.renderedFrame;
                    var keyframes = this.keyframes;
                    var lastKeyFrame = keyframes[keyframes.length - 1].t;
                    if (currentFrame <= lastKeyFrame) return this.pv;
                    var cycleDuration;
                    var firstKeyFrame;
                    if (!durationFlag) {
                        if (!duration || duration > keyframes.length - 1) duration = keyframes.length - 1;
                        firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
                        cycleDuration = lastKeyFrame - firstKeyFrame;
                    } else {
                        if (!duration) cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip); else cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
                        firstKeyFrame = lastKeyFrame - cycleDuration;
                    }
                    var i;
                    var len;
                    var ret;
                    if (type === "pingpong") {
                        var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                        if (iterations % 2 !== 0) return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                    } else if (type === "offset") {
                        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                        var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                        if (this.pv.length) {
                            ret = new Array(initV.length);
                            len = ret.length;
                            for (i = 0; i < len; i += 1) ret[i] = (endV[i] - initV[i]) * repeats + current[i];
                            return ret;
                        }
                        return (endV - initV) * repeats + current;
                    } else if (type === "continue") {
                        var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                        var nextLastValue = this.getValueAtTime((lastKeyFrame - .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            ret = new Array(lastValue.length);
                            len = ret.length;
                            for (i = 0; i < len; i += 1) ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
                            return ret;
                        }
                        return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / .001);
                    }
                    return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                }
                function loopIn(type, duration, durationFlag) {
                    if (!this.k) return this.pv;
                    type = type ? type.toLowerCase() : "";
                    var currentFrame = this.comp.renderedFrame;
                    var keyframes = this.keyframes;
                    var firstKeyFrame = keyframes[0].t;
                    if (currentFrame >= firstKeyFrame) return this.pv;
                    var cycleDuration;
                    var lastKeyFrame;
                    if (!durationFlag) {
                        if (!duration || duration > keyframes.length - 1) duration = keyframes.length - 1;
                        lastKeyFrame = keyframes[duration].t;
                        cycleDuration = lastKeyFrame - firstKeyFrame;
                    } else {
                        if (!duration) cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame); else cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
                        lastKeyFrame = firstKeyFrame + cycleDuration;
                    }
                    var i;
                    var len;
                    var ret;
                    if (type === "pingpong") {
                        var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
                        if (iterations % 2 === 0) return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                    } else if (type === "offset") {
                        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                        var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                        var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
                        if (this.pv.length) {
                            ret = new Array(initV.length);
                            len = ret.length;
                            for (i = 0; i < len; i += 1) ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
                            return ret;
                        }
                        return current - (endV - initV) * repeats;
                    } else if (type === "continue") {
                        var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                        var nextFirstValue = this.getValueAtTime((firstKeyFrame + .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            ret = new Array(firstValue.length);
                            len = ret.length;
                            for (i = 0; i < len; i += 1) ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / .001;
                            return ret;
                        }
                        return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / .001;
                    }
                    return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
                }
                function smooth(width, samples) {
                    if (!this.k) return this.pv;
                    width = (width || .4) * .5;
                    samples = Math.floor(samples || 5);
                    if (samples <= 1) return this.pv;
                    var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
                    var initFrame = currentTime - width;
                    var endFrame = currentTime + width;
                    var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
                    var i = 0;
                    var j = 0;
                    var value;
                    if (this.pv.length) value = createTypedArray("float32", this.pv.length); else value = 0;
                    var sampleValue;
                    while (i < samples) {
                        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
                        if (this.pv.length) for (j = 0; j < this.pv.length; j += 1) value[j] += sampleValue[j]; else value += sampleValue;
                        i += 1;
                    }
                    if (this.pv.length) for (j = 0; j < this.pv.length; j += 1) value[j] /= samples; else value /= samples;
                    return value;
                }
                function getTransformValueAtTime(time) {
                    if (!this._transformCachingAtTime) this._transformCachingAtTime = {
                        v: new Matrix
                    };
                    var matrix = this._transformCachingAtTime.v;
                    matrix.cloneFromProps(this.pre.props);
                    if (this.appliedTransformations < 1) {
                        var anchor = this.a.getValueAtTime(time);
                        matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
                    }
                    if (this.appliedTransformations < 2) {
                        var scale = this.s.getValueAtTime(time);
                        matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
                    }
                    if (this.sk && this.appliedTransformations < 3) {
                        var skew = this.sk.getValueAtTime(time);
                        var skewAxis = this.sa.getValueAtTime(time);
                        matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
                    }
                    if (this.r && this.appliedTransformations < 4) {
                        var rotation = this.r.getValueAtTime(time);
                        matrix.rotate(-rotation * this.r.mult);
                    } else if (!this.r && this.appliedTransformations < 4) {
                        var rotationZ = this.rz.getValueAtTime(time);
                        var rotationY = this.ry.getValueAtTime(time);
                        var rotationX = this.rx.getValueAtTime(time);
                        var orientation = this.or.getValueAtTime(time);
                        matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
                    }
                    if (this.data.p && this.data.p.s) {
                        var positionX = this.px.getValueAtTime(time);
                        var positionY = this.py.getValueAtTime(time);
                        if (this.data.p.z) {
                            var positionZ = this.pz.getValueAtTime(time);
                            matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
                        } else matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
                    } else {
                        var position = this.p.getValueAtTime(time);
                        matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
                    }
                    return matrix;
                }
                function getTransformStaticValueAtTime() {
                    return this.v.clone(new Matrix);
                }
                var getTransformProperty = TransformPropertyFactory.getTransformProperty;
                TransformPropertyFactory.getTransformProperty = function(elem, data, container) {
                    var prop = getTransformProperty(elem, data, container);
                    if (prop.dynamicProperties.length) prop.getValueAtTime = getTransformValueAtTime.bind(prop); else prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
                    prop.setGroupProperty = expressionHelpers.setGroupProperty;
                    return prop;
                };
                var propertyGetProp = PropertyFactory.getProp;
                PropertyFactory.getProp = function(elem, data, type, mult, container) {
                    var prop = propertyGetProp(elem, data, type, mult, container);
                    if (prop.kf) prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop); else prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
                    prop.setGroupProperty = expressionHelpers.setGroupProperty;
                    prop.loopOut = loopOut;
                    prop.loopIn = loopIn;
                    prop.smooth = smooth;
                    prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
                    prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
                    prop.numKeys = data.a === 1 ? data.k.length : 0;
                    prop.propertyIndex = data.ix;
                    var value = 0;
                    if (type !== 0) value = createTypedArray("float32", data.a === 1 ? data.k[0].s.length : data.k.length);
                    prop._cachingAtTime = {
                        lastFrame: initialDefaultFrame,
                        lastIndex: 0,
                        value
                    };
                    expressionHelpers.searchExpressions(elem, data, prop);
                    if (prop.k) container.addDynamicProperty(prop);
                    return prop;
                };
                function getShapeValueAtTime(frameNum) {
                    if (!this._cachingAtTime) this._cachingAtTime = {
                        shapeValue: shapePool.clone(this.pv),
                        lastIndex: 0,
                        lastTime: initialDefaultFrame
                    };
                    frameNum *= this.elem.globalData.frameRate;
                    frameNum -= this.offsetTime;
                    if (frameNum !== this._cachingAtTime.lastTime) {
                        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
                        this._cachingAtTime.lastTime = frameNum;
                        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
                    }
                    return this._cachingAtTime.shapeValue;
                }
                var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
                var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
                function ShapeExpressions() {}
                ShapeExpressions.prototype = {
                    vertices: function(prop, time) {
                        if (this.k) this.getValue();
                        var shapePath = this.v;
                        if (time !== void 0) shapePath = this.getValueAtTime(time, 0);
                        var i;
                        var len = shapePath._length;
                        var vertices = shapePath[prop];
                        var points = shapePath.v;
                        var arr = createSizedArray(len);
                        for (i = 0; i < len; i += 1) if (prop === "i" || prop === "o") arr[i] = [ vertices[i][0] - points[i][0], vertices[i][1] - points[i][1] ]; else arr[i] = [ vertices[i][0], vertices[i][1] ];
                        return arr;
                    },
                    points: function(time) {
                        return this.vertices("v", time);
                    },
                    inTangents: function(time) {
                        return this.vertices("i", time);
                    },
                    outTangents: function(time) {
                        return this.vertices("o", time);
                    },
                    isClosed: function() {
                        return this.v.c;
                    },
                    pointOnPath: function(perc, time) {
                        var shapePath = this.v;
                        if (time !== void 0) shapePath = this.getValueAtTime(time, 0);
                        if (!this._segmentsLength) this._segmentsLength = bez.getSegmentsLength(shapePath);
                        var segmentsLength = this._segmentsLength;
                        var lengths = segmentsLength.lengths;
                        var lengthPos = segmentsLength.totalLength * perc;
                        var i = 0;
                        var len = lengths.length;
                        var accumulatedLength = 0;
                        var pt;
                        while (i < len) {
                            if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                                var initIndex = i;
                                var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
                                var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
                                pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                                break;
                            } else accumulatedLength += lengths[i].addedLength;
                            i += 1;
                        }
                        if (!pt) pt = shapePath.c ? [ shapePath.v[0][0], shapePath.v[0][1] ] : [ shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1] ];
                        return pt;
                    },
                    vectorOnPath: function(perc, time, vectorType) {
                        if (perc == 1) perc = this.v.c; else if (perc == 0) perc = .999;
                        var pt1 = this.pointOnPath(perc, time);
                        var pt2 = this.pointOnPath(perc + .001, time);
                        var xLength = pt2[0] - pt1[0];
                        var yLength = pt2[1] - pt1[1];
                        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
                        if (magnitude === 0) return [ 0, 0 ];
                        var unitVector = vectorType === "tangent" ? [ xLength / magnitude, yLength / magnitude ] : [ -yLength / magnitude, xLength / magnitude ];
                        return unitVector;
                    },
                    tangentOnPath: function(perc, time) {
                        return this.vectorOnPath(perc, time, "tangent");
                    },
                    normalOnPath: function(perc, time) {
                        return this.vectorOnPath(perc, time, "normal");
                    },
                    setGroupProperty: expressionHelpers.setGroupProperty,
                    getValueAtTime: expressionHelpers.getStaticValueAtTime
                };
                extendPrototype([ ShapeExpressions ], ShapePropertyConstructorFunction);
                extendPrototype([ ShapeExpressions ], KeyframedShapePropertyConstructorFunction);
                KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
                KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
                var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
                ShapePropertyFactory.getShapeProp = function(elem, data, type, arr, trims) {
                    var prop = propertyGetShapeProp(elem, data, type, arr, trims);
                    prop.propertyIndex = data.ix;
                    prop.lock = false;
                    if (type === 3) expressionHelpers.searchExpressions(elem, data.pt, prop); else if (type === 4) expressionHelpers.searchExpressions(elem, data.ks, prop);
                    if (prop.k) elem.addDynamicProperty(prop);
                    return prop;
                };
            }
            function initialize$1() {
                addPropertyDecorator();
            }
            function addDecorator() {
                function searchExpressions() {
                    if (this.data.d.x) {
                        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
                        this.addEffect(this.getExpressionValue.bind(this));
                        return true;
                    }
                    return null;
                }
                TextProperty.prototype.getExpressionValue = function(currentValue, text) {
                    var newValue = this.calculateExpression(text);
                    if (currentValue.t !== newValue) {
                        var newData = {};
                        this.copyData(newData, currentValue);
                        newData.t = newValue.toString();
                        newData.__complete = false;
                        return newData;
                    }
                    return currentValue;
                };
                TextProperty.prototype.searchProperty = function() {
                    var isKeyframed = this.searchKeyframes();
                    var hasExpressions = this.searchExpressions();
                    this.kf = isKeyframed || hasExpressions;
                    return this.kf;
                };
                TextProperty.prototype.searchExpressions = searchExpressions;
            }
            function initialize() {
                addDecorator();
            }
            function SVGComposableEffect() {}
            SVGComposableEffect.prototype = {
                createMergeNode: (resultId, ins) => {
                    var feMerge = createNS("feMerge");
                    feMerge.setAttribute("result", resultId);
                    var feMergeNode;
                    var i;
                    for (i = 0; i < ins.length; i += 1) {
                        feMergeNode = createNS("feMergeNode");
                        feMergeNode.setAttribute("in", ins[i]);
                        feMerge.appendChild(feMergeNode);
                        feMerge.appendChild(feMergeNode);
                    }
                    return feMerge;
                }
            };
            var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
            function SVGTintFilter(filter, filterManager, elem, id, source) {
                this.filterManager = filterManager;
                var feColorMatrix = createNS("feColorMatrix");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
                feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
                this.linearFilter = feColorMatrix;
                feColorMatrix.setAttribute("result", id + "_tint_1");
                filter.appendChild(feColorMatrix);
                feColorMatrix = createNS("feColorMatrix");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
                feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
                feColorMatrix.setAttribute("result", id + "_tint_2");
                filter.appendChild(feColorMatrix);
                this.matrixFilter = feColorMatrix;
                var feMerge = this.createMergeNode(id, [ source, id + "_tint_1", id + "_tint_2" ]);
                filter.appendChild(feMerge);
            }
            extendPrototype([ SVGComposableEffect ], SVGTintFilter);
            SVGTintFilter.prototype.renderFrame = function(forceRender) {
                if (forceRender || this.filterManager._mdf) {
                    var colorBlack = this.filterManager.effectElements[0].p.v;
                    var colorWhite = this.filterManager.effectElements[1].p.v;
                    var opacity = this.filterManager.effectElements[2].p.v / 100;
                    this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
                    this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
                }
            };
            function SVGFillFilter(filter, filterManager, elem, id) {
                this.filterManager = filterManager;
                var feColorMatrix = createNS("feColorMatrix");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
                feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
                feColorMatrix.setAttribute("result", id);
                filter.appendChild(feColorMatrix);
                this.matrixFilter = feColorMatrix;
            }
            SVGFillFilter.prototype.renderFrame = function(forceRender) {
                if (forceRender || this.filterManager._mdf) {
                    var color = this.filterManager.effectElements[2].p.v;
                    var opacity = this.filterManager.effectElements[6].p.v;
                    this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
                }
            };
            function SVGStrokeEffect(fil, filterManager, elem) {
                this.initialized = false;
                this.filterManager = filterManager;
                this.elem = elem;
                this.paths = [];
            }
            SVGStrokeEffect.prototype.initialize = function() {
                var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                var path;
                var groupPath;
                var i;
                var len;
                if (this.filterManager.effectElements[1].p.v === 1) {
                    len = this.elem.maskManager.masksProperties.length;
                    i = 0;
                } else {
                    i = this.filterManager.effectElements[0].p.v - 1;
                    len = i + 1;
                }
                groupPath = createNS("g");
                groupPath.setAttribute("fill", "none");
                groupPath.setAttribute("stroke-linecap", "round");
                groupPath.setAttribute("stroke-dashoffset", 1);
                for (i; i < len; i += 1) {
                    path = createNS("path");
                    groupPath.appendChild(path);
                    this.paths.push({
                        p: path,
                        m: i
                    });
                }
                if (this.filterManager.effectElements[10].p.v === 3) {
                    var mask = createNS("mask");
                    var id = createElementID();
                    mask.setAttribute("id", id);
                    mask.setAttribute("mask-type", "alpha");
                    mask.appendChild(groupPath);
                    this.elem.globalData.defs.appendChild(mask);
                    var g = createNS("g");
                    g.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
                    while (elemChildren[0]) g.appendChild(elemChildren[0]);
                    this.elem.layerElement.appendChild(g);
                    this.masker = mask;
                    groupPath.setAttribute("stroke", "#fff");
                } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                    if (this.filterManager.effectElements[10].p.v === 2) {
                        elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                        while (elemChildren.length) this.elem.layerElement.removeChild(elemChildren[0]);
                    }
                    this.elem.layerElement.appendChild(groupPath);
                    this.elem.layerElement.removeAttribute("mask");
                    groupPath.setAttribute("stroke", "#fff");
                }
                this.initialized = true;
                this.pathMasker = groupPath;
            };
            SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
                if (!this.initialized) this.initialize();
                var i;
                var len = this.paths.length;
                var mask;
                var path;
                for (i = 0; i < len; i += 1) if (this.paths[i].m !== -1) {
                    mask = this.elem.maskManager.viewData[this.paths[i].m];
                    path = this.paths[i].p;
                    if (forceRender || this.filterManager._mdf || mask.prop._mdf) path.setAttribute("d", mask.lastPath);
                    if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
                        var dasharrayValue;
                        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                            var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01;
                            var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01;
                            var l = path.getTotalLength();
                            dasharrayValue = "0 0 0 " + l * s + " ";
                            var lineLength = l * (e - s);
                            var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                            var units = Math.floor(lineLength / segment);
                            var j;
                            for (j = 0; j < units; j += 1) dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
                            dasharrayValue += "0 " + l * 10 + " 0 0";
                        } else dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                        path.setAttribute("stroke-dasharray", dasharrayValue);
                    }
                }
                if (forceRender || this.filterManager.effectElements[4].p._mdf) this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
                if (forceRender || this.filterManager.effectElements[6].p._mdf) this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
                if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) if (forceRender || this.filterManager.effectElements[3].p._mdf) {
                    var color = this.filterManager.effectElements[3].p.v;
                    this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
                }
            };
            function SVGTritoneFilter(filter, filterManager, elem, id) {
                this.filterManager = filterManager;
                var feColorMatrix = createNS("feColorMatrix");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
                feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
                filter.appendChild(feColorMatrix);
                var feComponentTransfer = createNS("feComponentTransfer");
                feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
                feComponentTransfer.setAttribute("result", id);
                this.matrixFilter = feComponentTransfer;
                var feFuncR = createNS("feFuncR");
                feFuncR.setAttribute("type", "table");
                feComponentTransfer.appendChild(feFuncR);
                this.feFuncR = feFuncR;
                var feFuncG = createNS("feFuncG");
                feFuncG.setAttribute("type", "table");
                feComponentTransfer.appendChild(feFuncG);
                this.feFuncG = feFuncG;
                var feFuncB = createNS("feFuncB");
                feFuncB.setAttribute("type", "table");
                feComponentTransfer.appendChild(feFuncB);
                this.feFuncB = feFuncB;
                filter.appendChild(feComponentTransfer);
            }
            SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
                if (forceRender || this.filterManager._mdf) {
                    var color1 = this.filterManager.effectElements[0].p.v;
                    var color2 = this.filterManager.effectElements[1].p.v;
                    var color3 = this.filterManager.effectElements[2].p.v;
                    var tableR = color3[0] + " " + color2[0] + " " + color1[0];
                    var tableG = color3[1] + " " + color2[1] + " " + color1[1];
                    var tableB = color3[2] + " " + color2[2] + " " + color1[2];
                    this.feFuncR.setAttribute("tableValues", tableR);
                    this.feFuncG.setAttribute("tableValues", tableG);
                    this.feFuncB.setAttribute("tableValues", tableB);
                }
            };
            function SVGProLevelsFilter(filter, filterManager, elem, id) {
                this.filterManager = filterManager;
                var effectElements = this.filterManager.effectElements;
                var feComponentTransfer = createNS("feComponentTransfer");
                if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
                if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
                if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
                if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
                if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
                    feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
                    filter.appendChild(feComponentTransfer);
                }
                if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
                    feComponentTransfer = createNS("feComponentTransfer");
                    feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
                    feComponentTransfer.setAttribute("result", id);
                    filter.appendChild(feComponentTransfer);
                    this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
                    this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
                    this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
                }
            }
            SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
                var feFunc = createNS(type);
                feFunc.setAttribute("type", "table");
                feComponentTransfer.appendChild(feFunc);
                return feFunc;
            };
            SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
                var cnt = 0;
                var segments = 256;
                var perc;
                var min = Math.min(inputBlack, inputWhite);
                var max = Math.max(inputBlack, inputWhite);
                var table = Array.call(null, {
                    length: segments
                });
                var colorValue;
                var pos = 0;
                var outputDelta = outputWhite - outputBlack;
                var inputDelta = inputWhite - inputBlack;
                while (cnt <= 256) {
                    perc = cnt / 256;
                    if (perc <= min) colorValue = inputDelta < 0 ? outputWhite : outputBlack; else if (perc >= max) colorValue = inputDelta < 0 ? outputBlack : outputWhite; else colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
                    table[pos] = colorValue;
                    pos += 1;
                    cnt += 256 / (segments - 1);
                }
                return table.join(" ");
            };
            SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
                if (forceRender || this.filterManager._mdf) {
                    var val;
                    var effectElements = this.filterManager.effectElements;
                    if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
                        val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
                        this.feFuncRComposed.setAttribute("tableValues", val);
                        this.feFuncGComposed.setAttribute("tableValues", val);
                        this.feFuncBComposed.setAttribute("tableValues", val);
                    }
                    if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
                        val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
                        this.feFuncR.setAttribute("tableValues", val);
                    }
                    if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
                        val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
                        this.feFuncG.setAttribute("tableValues", val);
                    }
                    if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
                        val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
                        this.feFuncB.setAttribute("tableValues", val);
                    }
                    if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
                        val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
                        this.feFuncA.setAttribute("tableValues", val);
                    }
                }
            };
            function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
                var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
                var filterSize = filterManager.data.fs || globalFilterSize;
                filter.setAttribute("x", filterSize.x || globalFilterSize.x);
                filter.setAttribute("y", filterSize.y || globalFilterSize.y);
                filter.setAttribute("width", filterSize.width || globalFilterSize.width);
                filter.setAttribute("height", filterSize.height || globalFilterSize.height);
                this.filterManager = filterManager;
                var feGaussianBlur = createNS("feGaussianBlur");
                feGaussianBlur.setAttribute("in", "SourceAlpha");
                feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
                feGaussianBlur.setAttribute("stdDeviation", "0");
                this.feGaussianBlur = feGaussianBlur;
                filter.appendChild(feGaussianBlur);
                var feOffset = createNS("feOffset");
                feOffset.setAttribute("dx", "25");
                feOffset.setAttribute("dy", "0");
                feOffset.setAttribute("in", id + "_drop_shadow_1");
                feOffset.setAttribute("result", id + "_drop_shadow_2");
                this.feOffset = feOffset;
                filter.appendChild(feOffset);
                var feFlood = createNS("feFlood");
                feFlood.setAttribute("flood-color", "#00ff00");
                feFlood.setAttribute("flood-opacity", "1");
                feFlood.setAttribute("result", id + "_drop_shadow_3");
                this.feFlood = feFlood;
                filter.appendChild(feFlood);
                var feComposite = createNS("feComposite");
                feComposite.setAttribute("in", id + "_drop_shadow_3");
                feComposite.setAttribute("in2", id + "_drop_shadow_2");
                feComposite.setAttribute("operator", "in");
                feComposite.setAttribute("result", id + "_drop_shadow_4");
                filter.appendChild(feComposite);
                var feMerge = this.createMergeNode(id, [ id + "_drop_shadow_4", source ]);
                filter.appendChild(feMerge);
            }
            extendPrototype([ SVGComposableEffect ], SVGDropShadowEffect);
            SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
                if (forceRender || this.filterManager._mdf) {
                    if (forceRender || this.filterManager.effectElements[4].p._mdf) this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
                    if (forceRender || this.filterManager.effectElements[0].p._mdf) {
                        var col = this.filterManager.effectElements[0].p.v;
                        this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
                    }
                    if (forceRender || this.filterManager.effectElements[1].p._mdf) this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
                    if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                        var distance = this.filterManager.effectElements[3].p.v;
                        var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
                        var x = distance * Math.cos(angle);
                        var y = distance * Math.sin(angle);
                        this.feOffset.setAttribute("dx", x);
                        this.feOffset.setAttribute("dy", y);
                    }
                }
            };
            var _svgMatteSymbols = [];
            function SVGMatte3Effect(filterElem, filterManager, elem) {
                this.initialized = false;
                this.filterManager = filterManager;
                this.filterElem = filterElem;
                this.elem = elem;
                elem.matteElement = createNS("g");
                elem.matteElement.appendChild(elem.layerElement);
                elem.matteElement.appendChild(elem.transformedElement);
                elem.baseElement = elem.matteElement;
            }
            SVGMatte3Effect.prototype.findSymbol = function(mask) {
                var i = 0;
                var len = _svgMatteSymbols.length;
                while (i < len) {
                    if (_svgMatteSymbols[i] === mask) return _svgMatteSymbols[i];
                    i += 1;
                }
                return null;
            };
            SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
                var parentNode = mask.layerElement.parentNode;
                if (!parentNode) return;
                var children = parentNode.children;
                var i = 0;
                var len = children.length;
                while (i < len) {
                    if (children[i] === mask.layerElement) break;
                    i += 1;
                }
                var nextChild;
                if (i <= len - 2) nextChild = children[i + 1];
                var useElem = createNS("use");
                useElem.setAttribute("href", "#" + symbolId);
                if (nextChild) parentNode.insertBefore(useElem, nextChild); else parentNode.appendChild(useElem);
            };
            SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
                if (!this.findSymbol(mask)) {
                    var symbolId = createElementID();
                    var masker = createNS("mask");
                    masker.setAttribute("id", mask.layerId);
                    masker.setAttribute("mask-type", "alpha");
                    _svgMatteSymbols.push(mask);
                    var defs = elem.globalData.defs;
                    defs.appendChild(masker);
                    var symbol = createNS("symbol");
                    symbol.setAttribute("id", symbolId);
                    this.replaceInParent(mask, symbolId);
                    symbol.appendChild(mask.layerElement);
                    defs.appendChild(symbol);
                    var useElem = createNS("use");
                    useElem.setAttribute("href", "#" + symbolId);
                    masker.appendChild(useElem);
                    mask.data.hd = false;
                    mask.show();
                }
                elem.setMatte(mask.layerId);
            };
            SVGMatte3Effect.prototype.initialize = function() {
                var ind = this.filterManager.effectElements[0].p.v;
                var elements = this.elem.comp.elements;
                var i = 0;
                var len = elements.length;
                while (i < len) {
                    if (elements[i] && elements[i].data.ind === ind) this.setElementAsMask(this.elem, elements[i]);
                    i += 1;
                }
                this.initialized = true;
            };
            SVGMatte3Effect.prototype.renderFrame = function() {
                if (!this.initialized) this.initialize();
            };
            function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
                filter.setAttribute("x", "-100%");
                filter.setAttribute("y", "-100%");
                filter.setAttribute("width", "300%");
                filter.setAttribute("height", "300%");
                this.filterManager = filterManager;
                var feGaussianBlur = createNS("feGaussianBlur");
                feGaussianBlur.setAttribute("result", id);
                filter.appendChild(feGaussianBlur);
                this.feGaussianBlur = feGaussianBlur;
            }
            SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
                if (forceRender || this.filterManager._mdf) {
                    var kBlurrinessToSigma = .3;
                    var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
                    var dimensions = this.filterManager.effectElements[1].p.v;
                    var sigmaX = dimensions == 3 ? 0 : sigma;
                    var sigmaY = dimensions == 2 ? 0 : sigma;
                    this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
                    var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
                    this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
                }
            };
            function TransformEffect() {}
            TransformEffect.prototype.init = function(effectsManager) {
                this.effectsManager = effectsManager;
                this.type = effectTypes.TRANSFORM_EFFECT;
                this.matrix = new Matrix;
                this.opacity = -1;
                this._mdf = false;
                this._opMdf = false;
            };
            TransformEffect.prototype.renderFrame = function(forceFrame) {
                this._opMdf = false;
                this._mdf = false;
                if (forceFrame || this.effectsManager._mdf) {
                    var effectElements = this.effectsManager.effectElements;
                    var anchor = effectElements[0].p.v;
                    var position = effectElements[1].p.v;
                    var isUniformScale = effectElements[2].p.v === 1;
                    var scaleHeight = effectElements[3].p.v;
                    var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
                    var skew = effectElements[5].p.v;
                    var skewAxis = effectElements[6].p.v;
                    var rotation = effectElements[7].p.v;
                    this.matrix.reset();
                    this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
                    this.matrix.scale(scaleWidth * .01, scaleHeight * .01, 1);
                    this.matrix.rotate(-rotation * degToRads);
                    this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
                    this.matrix.translate(position[0], position[1], 0);
                    this._mdf = true;
                    if (this.opacity !== effectElements[8].p.v) {
                        this.opacity = effectElements[8].p.v;
                        this._opMdf = true;
                    }
                }
            };
            function SVGTransformEffect(_, filterManager) {
                this.init(filterManager);
            }
            extendPrototype([ TransformEffect ], SVGTransformEffect);
            function CVTransformEffect(effectsManager) {
                this.init(effectsManager);
            }
            extendPrototype([ TransformEffect ], CVTransformEffect);
            registerRenderer("canvas", CanvasRenderer);
            registerRenderer("html", HybridRenderer);
            registerRenderer("svg", SVGRenderer);
            ShapeModifiers.registerModifier("tm", TrimModifier);
            ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
            ShapeModifiers.registerModifier("rp", RepeaterModifier);
            ShapeModifiers.registerModifier("rd", RoundCornersModifier);
            ShapeModifiers.registerModifier("zz", ZigZagModifier);
            ShapeModifiers.registerModifier("op", OffsetPathModifier);
            setExpressionsPlugin(Expressions);
            setExpressionInterfaces(getInterface);
            initialize$1();
            initialize();
            registerEffect$1(20, SVGTintFilter, true);
            registerEffect$1(21, SVGFillFilter, true);
            registerEffect$1(22, SVGStrokeEffect, false);
            registerEffect$1(23, SVGTritoneFilter, true);
            registerEffect$1(24, SVGProLevelsFilter, true);
            registerEffect$1(25, SVGDropShadowEffect, true);
            registerEffect$1(28, SVGMatte3Effect, false);
            registerEffect$1(29, SVGGaussianBlurEffect, true);
            registerEffect$1(35, SVGTransformEffect, false);
            registerEffect(35, CVTransformEffect);
        },
        732: function(module) {
            !function(n, t) {
                true ? module.exports = t() : 0;
            }(0, (function() {
                "use strict";
                function n() {
                    return n = Object.assign || function(n) {
                        for (var t = 1; t < arguments.length; t++) {
                            var e = arguments[t];
                            for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]);
                        }
                        return n;
                    }, n.apply(this, arguments);
                }
                var t = "undefined" != typeof window, e = t && !("onscroll" in window) || "undefined" != typeof navigator && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent), i = t && "IntersectionObserver" in window, o = t && "classList" in document.createElement("p"), a = t && window.devicePixelRatio > 1, r = {
                    elements_selector: ".lazy",
                    container: e || t ? document : null,
                    threshold: 300,
                    thresholds: null,
                    data_src: "src",
                    data_srcset: "srcset",
                    data_sizes: "sizes",
                    data_bg: "bg",
                    data_bg_hidpi: "bg-hidpi",
                    data_bg_multi: "bg-multi",
                    data_bg_multi_hidpi: "bg-multi-hidpi",
                    data_bg_set: "bg-set",
                    data_poster: "poster",
                    class_applied: "applied",
                    class_loading: "loading",
                    class_loaded: "loaded",
                    class_error: "error",
                    class_entered: "entered",
                    class_exited: "exited",
                    unobserve_completed: !0,
                    unobserve_entered: !1,
                    cancel_on_exit: !0,
                    callback_enter: null,
                    callback_exit: null,
                    callback_applied: null,
                    callback_loading: null,
                    callback_loaded: null,
                    callback_error: null,
                    callback_finish: null,
                    callback_cancel: null,
                    use_native: !1,
                    restore_on_error: !1
                }, c = function(t) {
                    return n({}, r, t);
                }, l = function(n, t) {
                    var e, i = "LazyLoad::Initialized", o = new n(t);
                    try {
                        e = new CustomEvent(i, {
                            detail: {
                                instance: o
                            }
                        });
                    } catch (n) {
                        (e = document.createEvent("CustomEvent")).initCustomEvent(i, !1, !1, {
                            instance: o
                        });
                    }
                    window.dispatchEvent(e);
                }, u = "src", s = "srcset", d = "sizes", f = "poster", _ = "llOriginalAttrs", g = "data", v = "loading", b = "loaded", m = "applied", p = "error", h = "native", E = "data-", I = "ll-status", y = function(n, t) {
                    return n.getAttribute(E + t);
                }, k = function(n) {
                    return y(n, I);
                }, w = function(n, t) {
                    return function(n, t, e) {
                        var i = "data-ll-status";
                        null !== e ? n.setAttribute(i, e) : n.removeAttribute(i);
                    }(n, 0, t);
                }, A = function(n) {
                    return w(n, null);
                }, L = function(n) {
                    return null === k(n);
                }, O = function(n) {
                    return k(n) === h;
                }, x = [ v, b, m, p ], C = function(n, t, e, i) {
                    n && (void 0 === i ? void 0 === e ? n(t) : n(t, e) : n(t, e, i));
                }, N = function(n, t) {
                    o ? n.classList.add(t) : n.className += (n.className ? " " : "") + t;
                }, M = function(n, t) {
                    o ? n.classList.remove(t) : n.className = n.className.replace(new RegExp("(^|\\s+)" + t + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
                }, z = function(n) {
                    return n.llTempImage;
                }, T = function(n, t) {
                    if (t) {
                        var e = t._observer;
                        e && e.unobserve(n);
                    }
                }, R = function(n, t) {
                    n && (n.loadingCount += t);
                }, G = function(n, t) {
                    n && (n.toLoadCount = t);
                }, j = function(n) {
                    for (var t, e = [], i = 0; t = n.children[i]; i += 1) "SOURCE" === t.tagName && e.push(t);
                    return e;
                }, D = function(n, t) {
                    var e = n.parentNode;
                    e && "PICTURE" === e.tagName && j(e).forEach(t);
                }, H = function(n, t) {
                    j(n).forEach(t);
                }, V = [ u ], F = [ u, f ], B = [ u, s, d ], J = [ g ], P = function(n) {
                    return !!n[_];
                }, S = function(n) {
                    return n[_];
                }, U = function(n) {
                    return delete n[_];
                }, $ = function(n, t) {
                    if (!P(n)) {
                        var e = {};
                        t.forEach((function(t) {
                            e[t] = n.getAttribute(t);
                        })), n[_] = e;
                    }
                }, q = function(n, t) {
                    if (P(n)) {
                        var e = S(n);
                        t.forEach((function(t) {
                            !function(n, t, e) {
                                e ? n.setAttribute(t, e) : n.removeAttribute(t);
                            }(n, t, e[t]);
                        }));
                    }
                }, K = function(n, t, e) {
                    N(n, t.class_applied), w(n, m), e && (t.unobserve_completed && T(n, t), C(t.callback_applied, n, e));
                }, Q = function(n, t, e) {
                    N(n, t.class_loading), w(n, v), e && (R(e, 1), C(t.callback_loading, n, e));
                }, W = function(n, t, e) {
                    e && n.setAttribute(t, e);
                }, X = function(n, t) {
                    W(n, d, y(n, t.data_sizes)), W(n, s, y(n, t.data_srcset)), W(n, u, y(n, t.data_src));
                }, Y = {
                    IMG: function(n, t) {
                        D(n, (function(n) {
                            $(n, B), X(n, t);
                        })), $(n, B), X(n, t);
                    },
                    IFRAME: function(n, t) {
                        $(n, V), W(n, u, y(n, t.data_src));
                    },
                    VIDEO: function(n, t) {
                        H(n, (function(n) {
                            $(n, V), W(n, u, y(n, t.data_src));
                        })), $(n, F), W(n, f, y(n, t.data_poster)), W(n, u, y(n, t.data_src)), n.load();
                    },
                    OBJECT: function(n, t) {
                        $(n, J), W(n, g, y(n, t.data_src));
                    }
                }, Z = [ "IMG", "IFRAME", "VIDEO", "OBJECT" ], nn = function(n, t) {
                    !t || function(n) {
                        return n.loadingCount > 0;
                    }(t) || function(n) {
                        return n.toLoadCount > 0;
                    }(t) || C(n.callback_finish, t);
                }, tn = function(n, t, e) {
                    n.addEventListener(t, e), n.llEvLisnrs[t] = e;
                }, en = function(n, t, e) {
                    n.removeEventListener(t, e);
                }, on = function(n) {
                    return !!n.llEvLisnrs;
                }, an = function(n) {
                    if (on(n)) {
                        var t = n.llEvLisnrs;
                        for (var e in t) {
                            var i = t[e];
                            en(n, e, i);
                        }
                        delete n.llEvLisnrs;
                    }
                }, rn = function(n, t, e) {
                    !function(n) {
                        delete n.llTempImage;
                    }(n), R(e, -1), function(n) {
                        n && (n.toLoadCount -= 1);
                    }(e), M(n, t.class_loading), t.unobserve_completed && T(n, e);
                }, cn = function(n, t, e) {
                    var i = z(n) || n;
                    on(i) || function(n, t, e) {
                        on(n) || (n.llEvLisnrs = {});
                        var i = "VIDEO" === n.tagName ? "loadeddata" : "load";
                        tn(n, i, t), tn(n, "error", e);
                    }(i, (function(o) {
                        !function(n, t, e, i) {
                            var o = O(t);
                            rn(t, e, i), N(t, e.class_loaded), w(t, b), C(e.callback_loaded, t, i), o || nn(e, i);
                        }(0, n, t, e), an(i);
                    }), (function(o) {
                        !function(n, t, e, i) {
                            var o = O(t);
                            rn(t, e, i), N(t, e.class_error), w(t, p), C(e.callback_error, t, i), e.restore_on_error && q(t, B), 
                            o || nn(e, i);
                        }(0, n, t, e), an(i);
                    }));
                }, ln = function(n, t, e) {
                    !function(n) {
                        return Z.indexOf(n.tagName) > -1;
                    }(n) ? function(n, t, e) {
                        !function(n) {
                            n.llTempImage = document.createElement("IMG");
                        }(n), cn(n, t, e), function(n) {
                            P(n) || (n[_] = {
                                backgroundImage: n.style.backgroundImage
                            });
                        }(n), function(n, t, e) {
                            var i = y(n, t.data_bg), o = y(n, t.data_bg_hidpi), r = a && o ? o : i;
                            r && (n.style.backgroundImage = 'url("'.concat(r, '")'), z(n).setAttribute(u, r), 
                            Q(n, t, e));
                        }(n, t, e), function(n, t, e) {
                            var i = y(n, t.data_bg_multi), o = y(n, t.data_bg_multi_hidpi), r = a && o ? o : i;
                            r && (n.style.backgroundImage = r, K(n, t, e));
                        }(n, t, e), function(n, t, e) {
                            var i = y(n, t.data_bg_set);
                            if (i) {
                                var o = i.split("|"), a = o.map((function(n) {
                                    return "image-set(".concat(n, ")");
                                }));
                                n.style.backgroundImage = a.join(), "" === n.style.backgroundImage && (a = o.map((function(n) {
                                    return "-webkit-image-set(".concat(n, ")");
                                })), n.style.backgroundImage = a.join()), K(n, t, e);
                            }
                        }(n, t, e);
                    }(n, t, e) : function(n, t, e) {
                        cn(n, t, e), function(n, t, e) {
                            var i = Y[n.tagName];
                            i && (i(n, t), Q(n, t, e));
                        }(n, t, e);
                    }(n, t, e);
                }, un = function(n) {
                    n.removeAttribute(u), n.removeAttribute(s), n.removeAttribute(d);
                }, sn = function(n) {
                    D(n, (function(n) {
                        q(n, B);
                    })), q(n, B);
                }, dn = {
                    IMG: sn,
                    IFRAME: function(n) {
                        q(n, V);
                    },
                    VIDEO: function(n) {
                        H(n, (function(n) {
                            q(n, V);
                        })), q(n, F), n.load();
                    },
                    OBJECT: function(n) {
                        q(n, J);
                    }
                }, fn = function(n, t) {
                    (function(n) {
                        var t = dn[n.tagName];
                        t ? t(n) : function(n) {
                            if (P(n)) {
                                var t = S(n);
                                n.style.backgroundImage = t.backgroundImage;
                            }
                        }(n);
                    })(n), function(n, t) {
                        L(n) || O(n) || (M(n, t.class_entered), M(n, t.class_exited), M(n, t.class_applied), 
                        M(n, t.class_loading), M(n, t.class_loaded), M(n, t.class_error));
                    }(n, t), A(n), U(n);
                }, _n = [ "IMG", "IFRAME", "VIDEO" ], gn = function(n) {
                    return n.use_native && "loading" in HTMLImageElement.prototype;
                }, vn = function(n, t, e) {
                    n.forEach((function(n) {
                        return function(n) {
                            return n.isIntersecting || n.intersectionRatio > 0;
                        }(n) ? function(n, t, e, i) {
                            var o = function(n) {
                                return x.indexOf(k(n)) >= 0;
                            }(n);
                            w(n, "entered"), N(n, e.class_entered), M(n, e.class_exited), function(n, t, e) {
                                t.unobserve_entered && T(n, e);
                            }(n, e, i), C(e.callback_enter, n, t, i), o || ln(n, e, i);
                        }(n.target, n, t, e) : function(n, t, e, i) {
                            L(n) || (N(n, e.class_exited), function(n, t, e, i) {
                                e.cancel_on_exit && function(n) {
                                    return k(n) === v;
                                }(n) && "IMG" === n.tagName && (an(n), function(n) {
                                    D(n, (function(n) {
                                        un(n);
                                    })), un(n);
                                }(n), sn(n), M(n, e.class_loading), R(i, -1), A(n), C(e.callback_cancel, n, t, i));
                            }(n, t, e, i), C(e.callback_exit, n, t, i));
                        }(n.target, n, t, e);
                    }));
                }, bn = function(n) {
                    return Array.prototype.slice.call(n);
                }, mn = function(n) {
                    return n.container.querySelectorAll(n.elements_selector);
                }, pn = function(n) {
                    return function(n) {
                        return k(n) === p;
                    }(n);
                }, hn = function(n, t) {
                    return function(n) {
                        return bn(n).filter(L);
                    }(n || mn(t));
                }, En = function(n, e) {
                    var o = c(n);
                    this._settings = o, this.loadingCount = 0, function(n, t) {
                        i && !gn(n) && (t._observer = new IntersectionObserver((function(e) {
                            vn(e, n, t);
                        }), function(n) {
                            return {
                                root: n.container === document ? null : n.container,
                                rootMargin: n.thresholds || n.threshold + "px"
                            };
                        }(n)));
                    }(o, this), function(n, e) {
                        t && (e._onlineHandler = function() {
                            !function(n, t) {
                                var e;
                                (e = mn(n), bn(e).filter(pn)).forEach((function(t) {
                                    M(t, n.class_error), A(t);
                                })), t.update();
                            }(n, e);
                        }, window.addEventListener("online", e._onlineHandler));
                    }(o, this), this.update(e);
                };
                return En.prototype = {
                    update: function(n) {
                        var t, o, a = this._settings, r = hn(n, a);
                        G(this, r.length), !e && i ? gn(a) ? function(n, t, e) {
                            n.forEach((function(n) {
                                -1 !== _n.indexOf(n.tagName) && function(n, t, e) {
                                    n.setAttribute("loading", "lazy"), cn(n, t, e), function(n, t) {
                                        var e = Y[n.tagName];
                                        e && e(n, t);
                                    }(n, t), w(n, h);
                                }(n, t, e);
                            })), G(e, 0);
                        }(r, a, this) : (o = r, function(n) {
                            n.disconnect();
                        }(t = this._observer), function(n, t) {
                            t.forEach((function(t) {
                                n.observe(t);
                            }));
                        }(t, o)) : this.loadAll(r);
                    },
                    destroy: function() {
                        this._observer && this._observer.disconnect(), t && window.removeEventListener("online", this._onlineHandler), 
                        mn(this._settings).forEach((function(n) {
                            U(n);
                        })), delete this._observer, delete this._settings, delete this._onlineHandler, delete this.loadingCount, 
                        delete this.toLoadCount;
                    },
                    loadAll: function(n) {
                        var t = this, e = this._settings;
                        hn(n, e).forEach((function(n) {
                            T(n, t), ln(n, e, t);
                        }));
                    },
                    restoreAll: function() {
                        var n = this._settings;
                        mn(n).forEach((function(t) {
                            fn(t, n);
                        }));
                    }
                }, En.load = function(n, t) {
                    var e = c(t);
                    ln(n, e);
                }, En.resetStatus = function(n) {
                    A(n);
                }, t && function(n, t) {
                    if (t) if (t.length) for (var e, i = 0; e = t[i]; i += 1) l(n, e); else l(n, t);
                }(En, window.lazyLoadOptions), En;
            }));
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.amdO = {};
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    var __webpack_exports__ = {};
    (() => {
        "use strict";
        const flsModules = {};
        function isWebp() {
            function testWebP(callback) {
                let webP = new Image;
                webP.onload = webP.onerror = function() {
                    callback(webP.height == 2);
                };
                webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
            }
            testWebP((function(support) {
                let className = support === true ? "webp" : "no-webp";
                document.documentElement.classList.add(className);
            }));
        }
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    for (let index = 0; index < lock_padding.length; index++) {
                        const el = lock_padding[index];
                        el.style.paddingRight = "0px";
                    }
                    body.style.paddingRight = "0px";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                for (let index = 0; index < lock_padding.length; index++) {
                    const el = lock_padding[index];
                    el.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                }
                body.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function menuInit() {
            if (document.querySelector(".icon-menu")) document.addEventListener("click", (function(e) {
                if (bodyLockStatus && e.target.closest(".icon-menu")) {
                    bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function menuClose() {
            bodyUnlock();
            document.documentElement.classList.remove("menu-open");
        }
        function FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        class Popup {
            constructor(options) {
                let config = {
                    logging: true,
                    init: true,
                    attributeOpenButton: "data-popup",
                    attributeCloseButton: "data-close",
                    fixElementSelector: "[data-lp]",
                    youtubeAttribute: "data-popup-youtube",
                    youtubePlaceAttribute: "data-popup-youtube-place",
                    setAutoplayYoutube: true,
                    classes: {
                        popup: "popup",
                        popupContent: "popup__content",
                        popupActive: "popup_show",
                        bodyActive: "popup-show"
                    },
                    focusCatch: true,
                    closeEsc: true,
                    bodyLock: true,
                    hashSettings: {
                        location: true,
                        goHash: true
                    },
                    on: {
                        beforeOpen: function() {},
                        afterOpen: function() {},
                        beforeClose: function() {},
                        afterClose: function() {}
                    }
                };
                this.youTubeCode;
                this.isOpen = false;
                this.targetOpen = {
                    selector: false,
                    element: false
                };
                this.previousOpen = {
                    selector: false,
                    element: false
                };
                this.lastClosed = {
                    selector: false,
                    element: false
                };
                this._dataValue = false;
                this.hash = false;
                this._reopen = false;
                this._selectorOpen = false;
                this.lastFocusEl = false;
                this._focusEl = [ "a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])' ];
                this.options = {
                    ...config,
                    ...options,
                    classes: {
                        ...config.classes,
                        ...options?.classes
                    },
                    hashSettings: {
                        ...config.hashSettings,
                        ...options?.hashSettings
                    },
                    on: {
                        ...config.on,
                        ...options?.on
                    }
                };
                this.bodyLock = false;
                this.options.init ? this.initPopups() : null;
            }
            initPopups() {
                this.popupLogging(`Проснулся`);
                this.eventsPopup();
            }
            eventsPopup() {
                document.addEventListener("click", function(e) {
                    const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
                    if (buttonOpen) {
                        e.preventDefault();
                        this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
                        this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
                        if (this._dataValue !== "error") {
                            if (!this.isOpen) this.lastFocusEl = buttonOpen;
                            this.targetOpen.selector = `${this._dataValue}`;
                            this._selectorOpen = true;
                            this.open();
                            return;
                        } else this.popupLogging(`Ой ой, не заполнен атрибут у ${buttonOpen.classList}`);
                        return;
                    }
                    const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
                    if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("touchmove", function(e) {
                    if (!e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    if (this.options.closeEsc && e.which == 27 && e.code === "Escape" && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                    if (this.options.focusCatch && e.which == 9 && this.isOpen) {
                        this._focusCatch(e);
                        return;
                    }
                }.bind(this));
                if (this.options.hashSettings.goHash) {
                    window.addEventListener("hashchange", function() {
                        if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
                    }.bind(this));
                    window.addEventListener("load", function() {
                        if (window.location.hash) this._openToHash();
                    }.bind(this));
                }
            }
            open(selectorValue) {
                if (bodyLockStatus) {
                    this.bodyLock = document.documentElement.classList.contains("lock") && !this.isOpen ? true : false;
                    if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") {
                        this.targetOpen.selector = selectorValue;
                        this._selectorOpen = true;
                    }
                    if (this.isOpen) {
                        this._reopen = true;
                        this.close();
                    }
                    if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
                    if (!this._reopen) this.previousActiveElement = document.activeElement;
                    this.targetOpen.element = document.querySelector(this.targetOpen.selector);
                    if (this.targetOpen.element) {
                        if (this.youTubeCode) {
                            const codeVideo = this.youTubeCode;
                            const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                            const iframe = document.createElement("iframe");
                            iframe.setAttribute("allowfullscreen", "");
                            const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
                            iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
                            iframe.setAttribute("src", urlVideo);
                            if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
                                this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
                            }
                            this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
                        }
                        if (this.options.hashSettings.location) {
                            this._getHash();
                            this._setHash();
                        }
                        this.options.on.beforeOpen(this);
                        document.dispatchEvent(new CustomEvent("beforePopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.targetOpen.element.classList.add(this.options.classes.popupActive);
                        document.documentElement.classList.add(this.options.classes.bodyActive);
                        if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
                        this.targetOpen.element.setAttribute("aria-hidden", "false");
                        this.previousOpen.selector = this.targetOpen.selector;
                        this.previousOpen.element = this.targetOpen.element;
                        this._selectorOpen = false;
                        this.isOpen = true;
                        setTimeout((() => {
                            this._focusTrap();
                        }), 50);
                        this.options.on.afterOpen(this);
                        document.dispatchEvent(new CustomEvent("afterPopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.popupLogging(`Открыл попап`);
                    } else this.popupLogging(`Ой ой, такого попапа нет.Проверьте корректность ввода. `);
                }
            }
            close(selectorValue) {
                if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") this.previousOpen.selector = selectorValue;
                if (!this.isOpen || !bodyLockStatus) return;
                this.options.on.beforeClose(this);
                document.dispatchEvent(new CustomEvent("beforePopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
                this.previousOpen.element.classList.remove(this.options.classes.popupActive);
                this.previousOpen.element.setAttribute("aria-hidden", "true");
                if (!this._reopen) {
                    document.documentElement.classList.remove(this.options.classes.bodyActive);
                    !this.bodyLock ? bodyUnlock() : null;
                    this.isOpen = false;
                }
                this._removeHash();
                if (this._selectorOpen) {
                    this.lastClosed.selector = this.previousOpen.selector;
                    this.lastClosed.element = this.previousOpen.element;
                }
                this.options.on.afterClose(this);
                document.dispatchEvent(new CustomEvent("afterPopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                setTimeout((() => {
                    this._focusTrap();
                }), 50);
                this.popupLogging(`Закрыл попап`);
            }
            _getHash() {
                if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
            }
            _openToHash() {
                let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
                const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
                if (buttons && classInHash) this.open(classInHash);
            }
            _setHash() {
                history.pushState("", "", this.hash);
            }
            _removeHash() {
                history.pushState("", "", window.location.href.split("#")[0]);
            }
            _focusCatch(e) {
                const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
                const focusArray = Array.prototype.slice.call(focusable);
                const focusedIndex = focusArray.indexOf(document.activeElement);
                if (e.shiftKey && focusedIndex === 0) {
                    focusArray[focusArray.length - 1].focus();
                    e.preventDefault();
                }
                if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
                    focusArray[0].focus();
                    e.preventDefault();
                }
            }
            _focusTrap() {
                const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
                if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
            }
            popupLogging(message) {
                this.options.logging ? FLS(`[Попапос]: ${message}`) : null;
            }
        }
        flsModules.popup = new Popup({});
        let gotoblock_gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {
            const targetBlockElement = document.querySelector(targetBlock);
            if (targetBlockElement) {
                let headerItem = "";
                let headerItemHeight = 0;
                if (noHeader) {
                    headerItem = "header.header";
                    const headerElement = document.querySelector(headerItem);
                    if (!headerElement.classList.contains("_header-scroll")) {
                        headerElement.style.cssText = `transition-duration: 0s;`;
                        headerElement.classList.add("_header-scroll");
                        headerItemHeight = headerElement.offsetHeight;
                        headerElement.classList.remove("_header-scroll");
                        setTimeout((() => {
                            headerElement.style.cssText = ``;
                        }), 0);
                    } else headerItemHeight = headerElement.offsetHeight;
                }
                let options = {
                    speedAsDuration: true,
                    speed,
                    header: headerItem,
                    offset: offsetTop,
                    easing: "easeOutQuad"
                };
                document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                if (typeof SmoothScroll !== "undefined") (new SmoothScroll).animateScroll(targetBlockElement, "", options); else {
                    let targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;
                    targetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;
                    targetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;
                    window.scrollTo({
                        top: targetBlockElementPosition,
                        behavior: "smooth"
                    });
                }
                FLS(`[gotoBlock]: Юхуу...едем к ${targetBlock}`);
            } else FLS(`[gotoBlock]: Ой ой..Такого блока нет на странице: ${targetBlock}`);
        };
        function formFieldsInit(options = {
            viewPass: false,
            autoHeight: false
        }) {
            const formFields = document.querySelectorAll("input[placeholder],textarea[placeholder]");
            if (formFields.length) formFields.forEach((formField => {
                if (!formField.hasAttribute("data-placeholder-nohide")) formField.dataset.placeholder = formField.placeholder;
            }));
            document.body.addEventListener("focusin", (function(e) {
                const targetElement = e.target;
                if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
                    if (targetElement.dataset.placeholder) targetElement.placeholder = "";
                    if (!targetElement.hasAttribute("data-no-focus-classes")) {
                        targetElement.classList.add("_form-focus");
                        targetElement.parentElement.classList.add("_form-focus");
                    }
                    formValidate.removeError(targetElement);
                }
            }));
            document.body.addEventListener("focusout", (function(e) {
                const targetElement = e.target;
                if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
                    if (targetElement.dataset.placeholder) targetElement.placeholder = targetElement.dataset.placeholder;
                    if (!targetElement.hasAttribute("data-no-focus-classes")) {
                        targetElement.classList.remove("_form-focus");
                        targetElement.parentElement.classList.remove("_form-focus");
                    }
                    if (targetElement.hasAttribute("data-validate")) {
                        const error = formValidate.validateInput(targetElement);
                        if (error === 0) formValidate.addSuccess(targetElement); else formValidate.removeSuccess(targetElement);
                    }
                }
            }));
            if (options.viewPass) document.addEventListener("click", (function(e) {
                let targetElement = e.target;
                if (targetElement.closest('[class*="__viewpass"]')) {
                    let inputType = targetElement.classList.contains("_viewpass-active") ? "password" : "text";
                    targetElement.parentElement.querySelector("input").setAttribute("type", inputType);
                    targetElement.classList.toggle("_viewpass-active");
                }
            }));
            if (options.autoHeight) {
                const textareas = document.querySelectorAll("textarea[data-autoheight]");
                if (textareas.length) {
                    textareas.forEach((textarea => {
                        const startHeight = textarea.hasAttribute("data-autoheight-min") ? Number(textarea.dataset.autoheightMin) : Number(textarea.offsetHeight);
                        const maxHeight = textarea.hasAttribute("data-autoheight-max") ? Number(textarea.dataset.autoheightMax) : 1 / 0;
                        setHeight(textarea, Math.min(startHeight, maxHeight));
                        textarea.addEventListener("input", (() => {
                            if (textarea.scrollHeight > startHeight) {
                                textarea.style.height = `auto`;
                                setHeight(textarea, Math.min(Math.max(textarea.scrollHeight, startHeight), maxHeight));
                            }
                        }));
                    }));
                    function setHeight(textarea, height) {
                        textarea.style.height = `${height}px`;
                    }
                }
            }
        }
        let formValidate = {
            getErrors(form) {
                let error = 0;
                let formRequiredItems = form.querySelectorAll("*[data-required]");
                if (formRequiredItems.length) formRequiredItems.forEach((formRequiredItem => {
                    if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) error += this.validateInput(formRequiredItem);
                }));
                return error;
            },
            validateInput(formRequiredItem) {
                let error = 0;
                if (formRequiredItem.dataset.required === "email") {
                    formRequiredItem.value = formRequiredItem.value.replace(" ", "");
                    if (this.emailTest(formRequiredItem)) {
                        this.addError(formRequiredItem);
                        error++;
                    } else this.removeError(formRequiredItem);
                } else if (formRequiredItem.type === "checkbox" && !formRequiredItem.checked) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (!formRequiredItem.value.trim()) {
                    this.addError(formRequiredItem);
                    error++;
                } else this.removeError(formRequiredItem);
                return error;
            },
            addError(formRequiredItem) {
                formRequiredItem.classList.add("_form-error");
                formRequiredItem.parentElement.classList.add("_form-error");
                let inputError = formRequiredItem.parentElement.querySelector(".form__error");
                if (inputError) formRequiredItem.parentElement.removeChild(inputError);
                if (formRequiredItem.dataset.error) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${formRequiredItem.dataset.error}</div>`);
            },
            removeError(formRequiredItem) {
                formRequiredItem.classList.remove("_form-error");
                formRequiredItem.parentElement.classList.remove("_form-error");
                if (formRequiredItem.parentElement.querySelector(".form__error")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__error"));
            },
            addSuccess(formRequiredItem) {
                formRequiredItem.classList.add("_form-success");
                formRequiredItem.parentElement.classList.add("_form-success");
                let inputSuccess = formRequiredItem.parentElement.querySelector(".form__success");
                if (inputSuccess) formRequiredItem.parentElement.removeChild(inputSuccess);
                if (formRequiredItem.dataset.success) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__success">${formRequiredItem.dataset.success}</div>`);
            },
            removeSuccess(formRequiredItem) {
                formRequiredItem.classList.remove("_form-success");
                formRequiredItem.parentElement.classList.remove("_form-success");
                if (formRequiredItem.parentElement.querySelector(".form__success")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__success"));
            },
            formClean(form) {
                form.reset();
                setTimeout((() => {
                    let inputs = form.querySelectorAll("input,textarea");
                    for (let index = 0; index < inputs.length; index++) {
                        const el = inputs[index];
                        el.parentElement.classList.remove("_form-focus");
                        el.classList.remove("_form-focus");
                        formValidate.removeError(el);
                        formValidate.removeSuccess(el);
                    }
                    let checkboxes = form.querySelectorAll(".checkbox__input");
                    if (checkboxes.length > 0) for (let index = 0; index < checkboxes.length; index++) {
                        const checkbox = checkboxes[index];
                        checkbox.checked = false;
                    }
                    if (flsModules.select) {
                        let selects = form.querySelectorAll(".select");
                        if (selects.length) for (let index = 0; index < selects.length; index++) {
                            const select = selects[index].querySelector("select");
                            flsModules.select.selectBuild(select);
                        }
                    }
                }), 0);
            },
            emailTest(formRequiredItem) {
                return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
            }
        };
        function formSubmit() {
            const forms = document.forms;
            if (forms.length) for (const form of forms) {
                form.addEventListener("submit", (function(e) {
                    const form = e.target;
                    formSubmitAction(form, e);
                }));
                form.addEventListener("reset", (function(e) {
                    const form = e.target;
                    formValidate.formClean(form);
                }));
            }
            async function formSubmitAction(form, e) {
                const error = !form.hasAttribute("data-no-validate") ? formValidate.getErrors(form) : 0;
                if (error === 0) {
                    const ajax = form.hasAttribute("data-ajax");
                    if (ajax) {
                        e.preventDefault();
                        const formAction = form.getAttribute("action") ? form.getAttribute("action").trim() : "#";
                        const formMethod = form.getAttribute("method") ? form.getAttribute("method").trim() : "GET";
                        const formData = new FormData(form);
                        form.classList.add("_sending");
                        const response = await fetch(formAction, {
                            method: formMethod,
                            body: formData
                        });
                        if (response.ok) {
                            let responseResult = await response.json();
                            form.classList.remove("_sending");
                            formSent(form, responseResult);
                        } else {
                            alert("Ошибка");
                            form.classList.remove("_sending");
                        }
                    } else if (form.hasAttribute("data-dev")) {
                        e.preventDefault();
                        formSent(form);
                    }
                } else {
                    e.preventDefault();
                    if (form.querySelector("._form-error") && form.hasAttribute("data-goto-error")) {
                        const formGoToErrorClass = form.dataset.gotoError ? form.dataset.gotoError : "._form-error";
                        gotoblock_gotoBlock(formGoToErrorClass, true, 1e3);
                    }
                }
            }
            function formSent(form, responseResult = ``) {
                document.dispatchEvent(new CustomEvent("formSent", {
                    detail: {
                        form
                    }
                }));
                setTimeout((() => {
                    if (flsModules.popup) {
                        const popup = form.dataset.popupMessage;
                        popup ? flsModules.popup.open(popup) : null;
                    }
                }), 0);
                formValidate.formClean(form);
                formLogging(`Форма отправлена!`);
            }
            function formLogging(message) {
                FLS(`[Формы]: ${message}`);
            }
        }
        function ssr_window_esm_isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target = {}, src = {}) {
            Object.keys(src).forEach((key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay = 0) {
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis = "x") {
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function utils_extend(...args) {
            const to = Object(args[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < args.length; i += 1) {
                const nextSource = args[i];
                if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll({swiper, targetPosition, side}) {
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function utils_elementChildren(element, selector = "") {
            return [ ...element.children ].filter((el => el.matches(selector)));
        }
        function utils_createElement(tag, classes = []) {
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : [ classes ]);
            return el;
        }
        function elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function elementStyle(el, prop) {
            const window = ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function utils_elementOuterSize(el, size, includeMargins) {
            const window = ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice({userAgent} = {}) {
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides = {}) {
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            return {
                isSafari: needPerspectiveFix || isSafari(),
                needPerspectiveFix,
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize({swiper, on, emit}) {
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((({contentBoxSize, contentRect, target}) => {
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer({swiper, extendParams, on, emit}) {
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = (target, options = {}) => {
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: typeof options.childList === "undefined" ? true : options.childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = utils_elementParents(swiper.el);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.el, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        const events_emitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler(...args) {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit(...args) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionLabel(property) {
                if (swiper.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach((slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            }));
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slidesLength);
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
                if (slides[i] && elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? utils_elementOuterSize(slide, "width", true) : utils_elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).forEach((slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                }));
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize - swiperSize;
                snapGrid = snapGrid.map((snap => {
                    if (snap < 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                if (allSlidesSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        function updateSlidesProgress(translate = this && this.translate || 0) {
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideVisibleClass);
            }));
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides[i].classList.add(params.slideVisibleClass);
                }
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const getFilteredSlide = selector => utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            }));
            let activeSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else activeSlide = slides[activeIndex];
            if (activeSlide) {
                activeSlide.classList.add(params.slideActiveClass);
                let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !nextSlide) nextSlide = slides[0];
                if (nextSlide) nextSlide.classList.add(params.slideNextClass);
                let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
                if (prevSlide) prevSlide.classList.add(params.slidePrevClass);
            }
            swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (lazyEl) lazyEl.remove();
            }
        };
        const unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex !== activeIndex && realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            } else for (let i = Math.max(slideIndexLastInView - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && i > slideIndexLastInView) unlazy(swiper, i);
        };
        function getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (swiper.slides[activeIndex]) realIndex = parseInt(swiper.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10); else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit("slideChange");
        }
        function updateClickedSlide(e) {
            const swiper = this;
            const params = swiper.params;
            const slide = e.closest(`.${params.slideClass}, swiper-slide`);
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        const update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis = (this.isHorizontal() ? "x" : "y")) {
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        const translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit({swiper, runCallbacks, direction, step}) {
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === "reset") {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        const transition = {
            setTransition,
            transitionStart,
            transitionEnd
        };
        function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame((() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }));
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else newIndex = swiper.getSlideIndexByData(newIndex);
            return swiper.slideTo(newIndex, speed, runCallbacks, internal);
        }
        function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled) return swiper;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled) return swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = .5) {
            const swiper = this;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        const slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate(slideRealIndex) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            slides.forEach(((el, index) => {
                el.setAttribute("data-swiper-slide-index", index);
            }));
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next"
            });
        }
        function loopFix({slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel} = {}) {
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
            let loopedSlides = params.loopedSlides || slidesPerView;
            if (loopedSlides % params.slidesPerGroup !== 0) loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
            swiper.loopedSlides = loopedSlides;
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            let activeIndex = swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            if (activeSlideIndex < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
                    const index = i - Math.floor(i / slides.length) * slides.length;
                    prependSlidesIndexes.push(slides.length - index - 1);
                }
            } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {
                slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / slides.length) * slides.length;
                    appendSlidesIndexes.push(index);
                }
            }
            if (isPrev) prependSlidesIndexes.forEach((index => {
                swiper.slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(swiper.slides[index]);
                swiper.slides[index].swiperLoopMoveDOM = false;
            }));
            if (isNext) appendSlidesIndexes.forEach((index => {
                swiper.slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(swiper.slides[index]);
                swiper.slides[index].swiperLoopMoveDOM = false;
            }));
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides();
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff;
                    }
                } else if (setTranslate) swiper.slideToLoop(slideRealIndex, 0, false, true);
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff;
                }
            } else swiper.slideToLoop(slideRealIndex, 0, false, true);
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    slideTo: false,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c => {
                    if (!c.destroyed && c.params.loop) c.loopFix(loopParams);
                })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix(loopParams);
            }
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach((slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            }));
            swiper.slides.forEach((slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
            newSlidesOrder.forEach((slideEl => {
                slidesEl.append(slideEl);
            }));
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        const loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        const grab_cursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base = this) {
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const window = ssr_window_esm_getWindow();
            const data = swiper.touchEventsData;
            data.evCache.push(event);
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!swiper.wrapperEl.contains(targetEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = event.composedPath ? event.composedPath() : event.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if (edgeSwipeDetection === "prevent") event.preventDefault(); else return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pointerIndex = data.evCache.findIndex((cachedEv => cachedEv.pointerId === e.pointerId));
            if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
            const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        prevX: swiper.touches.currentX,
                        prevY: swiper.touches.currentY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            if (e.targetTouches && e.targetTouches.length > 1) return;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            if (!data.isMoved) {
                if (isLoop) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {
                swiper.loopFix({
                    direction: swiper.swipeDirection,
                    setTranslate: true
                });
                loopFixed = true;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            const pointerIndex = data.evCache.findIndex((cachedEv => cachedEv.pointerId === event.pointerId));
            if (pointerIndex >= 0) data.evCache.splice(pointerIndex, 1);
            if ([ "pointercancel", "pointerout", "pointerleave" ].includes(event.type)) {
                const proceed = event.type === "pointercancel" && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (swiper.params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout((() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }), 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function onLoad(e) {
            const swiper = this;
            processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        let dummyEventAttached = false;
        function dummyEventListener() {}
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function attachEvents() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            swiper.onLoad = onLoad.bind(swiper);
            if (!dummyEventAttached) {
                document.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        const core_events = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            }
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base = "window", containerEl) {
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        const breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if (typeof item === "object") Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if (typeof item === "string") resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function removeClasses_removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        const classes = {
            addClasses,
            removeClasses: removeClasses_removeClasses
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        const check_overflow = {
            checkOverflow
        };
        const defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopedSlides: null,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj = {}) {
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if ([ "navigation", "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) params[moduleParamName] = {
                    auto: true
                };
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter: events_emitter,
            update,
            translate,
            transition,
            slide,
            loop,
            grabCursor: grab_cursor,
            events: core_events,
            breakpoints,
            checkOverflow: check_overflow,
            classes
        };
        const extendedDefaults = {};
        class core_Swiper {
            constructor(...args) {
                let el;
                let params;
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        evCache: []
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = utils_elementIndex(slides[0]);
                return utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view = "current", exact = false) {
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex].swiperSlideSize;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl);
                }));
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                    setTranslate();
                    if (swiper.params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                        const slides = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate = true) {
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach((slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.shadowEl) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                        wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement ? el : wrapperEl,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
                    wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate();
                swiper.attachEvents();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e => {
                        processLazyPreloader(swiper, e.target);
                    }));
                }));
                preload(swiper);
                swiper.initialized = true;
                preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance = true, cleanStyles = true) {
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    el.removeAttribute("style");
                    wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach((slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    }));
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (deleteInstance !== false) {
                    swiper.el.swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!core_Swiper.prototype.__modules__) core_Swiper.prototype.__modules__ = [];
                const modules = core_Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => core_Swiper.installModule(m)));
                    return core_Swiper;
                }
                core_Swiper.installModule(module);
                return core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        core_Swiper.use([ Resize, Observer ]);
        const core = core_Swiper;
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && params.auto === true) {
                    let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                    if (!element) {
                        element = utils_createElement("div", checkProps[key]);
                        element.className = checkProps[key];
                        swiper.el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function Navigation({swiper, extendParams, on, emit}) {
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            });
            swiper.navigation = {
                nextEl: null,
                prevEl: null
            };
            const makeElementsArray = el => {
                if (!Array.isArray(el)) el = [ el ].filter((e => !!e));
                return el;
            };
            function getEl(el) {
                let res;
                if (el && typeof el === "string" && swiper.isElement) {
                    res = swiper.el.shadowRoot.querySelector(el);
                    if (res) return res;
                }
                if (el) {
                    if (typeof el === "string") res = [ ...document.querySelectorAll(el) ];
                    if (swiper.params.uniqueNavElements && typeof el === "string" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el);
                }
                if (el && !res) return el;
                return res;
            }
            function toggleEl(el, disabled) {
                const params = swiper.params.navigation;
                el = makeElementsArray(el);
                el.forEach((subEl => {
                    if (subEl) {
                        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                        if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                    }
                }));
            }
            function update() {
                const {nextEl, prevEl} = swiper.navigation;
                if (swiper.params.loop) {
                    toggleEl(prevEl, false);
                    toggleEl(nextEl, false);
                    return;
                }
                toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
                emit("navigationPrev");
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
                emit("navigationNext");
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                let nextEl = getEl(params.nextEl);
                let prevEl = getEl(params.prevEl);
                Object.assign(swiper.navigation, {
                    nextEl,
                    prevEl
                });
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                const initButton = (el, dir) => {
                    if (el) el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(" "));
                };
                nextEl.forEach((el => initButton(el, "next")));
                prevEl.forEach((el => initButton(el, "prev")));
            }
            function destroy() {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                const destroyButton = (el, dir) => {
                    el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
                };
                nextEl.forEach((el => destroyButton(el, "next")));
                prevEl.forEach((el => destroyButton(el, "prev")));
            }
            on("init", (() => {
                if (swiper.params.navigation.enabled === false) disable(); else {
                    init();
                    update();
                }
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList[swiper.enabled ? "remove" : "add"](swiper.params.navigation.lockClass)));
            }));
            on("click", ((_s, e) => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                const targetEl = e.target;
                if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass); else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                    if (isHidden === true) emit("navigationShow"); else emit("navigationHide");
                    [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.toggle(swiper.params.navigation.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
                init();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
                destroy();
            };
            Object.assign(swiper.navigation, {
                enable,
                disable,
                update,
                init,
                destroy
            });
        }
        function initSliders() {
            if (document.querySelector(".section-3__slider")) new core(".section-3__slider", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                slidesPerView: 3,
                spaceBetween: 14,
                speed: 800,
                navigation: {
                    prevEl: ".section-3__arrow-prev",
                    nextEl: ".section-3__arrow-next",
                    lockClass: "section-3__arrow-lock"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 13
                    },
                    480: {
                        slidesPerView: 1.3,
                        spaceBetween: 13
                    },
                    650: {
                        slidesPerView: 1.8,
                        spaceBetween: 13
                    },
                    768: {
                        slidesPerView: 2.2,
                        spaceBetween: 13
                    },
                    992: {
                        slidesPerView: 2.7,
                        spaceBetween: 13
                    },
                    1024: {
                        slidesPerView: 3,
                        spaceBetween: 13
                    },
                    1199.98: {
                        slidesPerView: 3,
                        spaceBetween: 14
                    }
                },
                on: {}
            });
            if (document.querySelector(".section-8__slider")) new core(".section-8__slider", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                slidesPerView: 3,
                spaceBetween: 34,
                speed: 800,
                navigation: {
                    prevEl: ".section-8__arrow-prev",
                    nextEl: ".section-8__arrow-next",
                    lockClass: "section-8__arrow-lock"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    480: {
                        slidesPerView: 1.3,
                        spaceBetween: 10
                    },
                    650: {
                        slidesPerView: 1.8,
                        spaceBetween: 10
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 24
                    },
                    1199.98: {
                        slidesPerView: 3,
                        spaceBetween: 34
                    }
                },
                on: {}
            });
            const retritSliders = document.querySelectorAll(".popup-retrit__slider");
            if (retritSliders) retritSliders.forEach(((retritSlider, index) => {
                retritSlider.classList.add(`slider-id-${index}`);
                retritSlider.querySelector(".swiper-wrapper").classList.add(`slider-wrapper-id-${index}`);
                new core(`.popup-retrit__slider.slider-id-${index}`, {
                    modules: [ Navigation ],
                    observer: true,
                    observeParents: true,
                    slidesPerView: 1,
                    spaceBetween: 0,
                    speed: 800,
                    navigation: {
                        prevEl: `.slider-id-${index} .popup-retrit__arrow-prev`,
                        nextEl: `.slider-id-${index} .popup-retrit__arrow-next`
                    },
                    on: {}
                });
            }));
            const cardSliders = document.querySelectorAll(".card-slider__img-slider");
            if (cardSliders) cardSliders.forEach(((cardSlider, index) => {
                cardSlider.classList.add(`slider-id-${index}`);
                cardSlider.querySelector(".swiper-wrapper").classList.add(`slider-wrapper-id-${index}`);
                new core(`.card-slider__img-slider.slider-id-${index}`, {
                    modules: [ Navigation ],
                    observer: true,
                    observeParents: true,
                    slidesPerView: 1,
                    spaceBetween: 0,
                    speed: 800,
                    navigation: {
                        prevEl: `.slider-id-${index} .card-slider__img-slider-arrow-prev`,
                        nextEl: `.slider-id-${index} .card-slider__img-slider-arrow-next`
                    },
                    on: {}
                });
            }));
        }
        window.addEventListener("load", (function(e) {
            initSliders();
        }));
        var lazyload_min = __webpack_require__(732);
        new lazyload_min({
            elements_selector: "[data-src],[data-srcset],[data-bg],[data-bg-hidpi]",
            class_loaded: "_lazy-loaded"
        });
        let addWindowScrollEvent = false;
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        function DynamicAdapt(type) {
            this.type = type;
        }
        DynamicAdapt.prototype.init = function() {
            const _this = this;
            this.оbjects = [];
            this.daClassname = "_dynamic_adapt_";
            this.nodes = document.querySelectorAll("[data-da]");
            for (let i = 0; i < this.nodes.length; i++) {
                const node = this.nodes[i];
                const data = node.dataset.da.trim();
                const dataArray = data.split(",");
                const оbject = {};
                оbject.element = node;
                оbject.parent = node.parentNode;
                оbject.destination = document.querySelector(dataArray[0].trim());
                оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
                оbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                оbject.index = this.indexInParent(оbject.parent, оbject.element);
                this.оbjects.push(оbject);
            }
            this.arraySort(this.оbjects);
            this.mediaQueries = Array.prototype.map.call(this.оbjects, (function(item) {
                return "(" + this.type + "-width: " + item.breakpoint + "px)," + item.breakpoint;
            }), this);
            this.mediaQueries = Array.prototype.filter.call(this.mediaQueries, (function(item, index, self) {
                return Array.prototype.indexOf.call(self, item) === index;
            }));
            for (let i = 0; i < this.mediaQueries.length; i++) {
                const media = this.mediaQueries[i];
                const mediaSplit = String.prototype.split.call(media, ",");
                const matchMedia = window.matchMedia(mediaSplit[0]);
                const mediaBreakpoint = mediaSplit[1];
                const оbjectsFilter = Array.prototype.filter.call(this.оbjects, (function(item) {
                    return item.breakpoint === mediaBreakpoint;
                }));
                matchMedia.addListener((function() {
                    _this.mediaHandler(matchMedia, оbjectsFilter);
                }));
                this.mediaHandler(matchMedia, оbjectsFilter);
            }
        };
        DynamicAdapt.prototype.mediaHandler = function(matchMedia, оbjects) {
            if (matchMedia.matches) for (let i = 0; i < оbjects.length; i++) {
                const оbject = оbjects[i];
                оbject.index = this.indexInParent(оbject.parent, оbject.element);
                this.moveTo(оbject.place, оbject.element, оbject.destination);
            } else for (let i = оbjects.length - 1; i >= 0; i--) {
                const оbject = оbjects[i];
                if (оbject.element.classList.contains(this.daClassname)) this.moveBack(оbject.parent, оbject.element, оbject.index);
            }
        };
        DynamicAdapt.prototype.moveTo = function(place, element, destination) {
            element.classList.add(this.daClassname);
            if (place === "last" || place >= destination.children.length) {
                destination.insertAdjacentElement("beforeend", element);
                return;
            }
            if (place === "first") {
                destination.insertAdjacentElement("afterbegin", element);
                return;
            }
            destination.children[place].insertAdjacentElement("beforebegin", element);
        };
        DynamicAdapt.prototype.moveBack = function(parent, element, index) {
            element.classList.remove(this.daClassname);
            if (parent.children[index] !== void 0) parent.children[index].insertAdjacentElement("beforebegin", element); else parent.insertAdjacentElement("beforeend", element);
        };
        DynamicAdapt.prototype.indexInParent = function(parent, element) {
            const array = Array.prototype.slice.call(parent.children);
            return Array.prototype.indexOf.call(array, element);
        };
        DynamicAdapt.prototype.arraySort = function(arr) {
            if (this.type === "min") Array.prototype.sort.call(arr, (function(a, b) {
                if (a.breakpoint === b.breakpoint) {
                    if (a.place === b.place) return 0;
                    if (a.place === "first" || b.place === "last") return -1;
                    if (a.place === "last" || b.place === "first") return 1;
                    return a.place - b.place;
                }
                return a.breakpoint - b.breakpoint;
            })); else {
                Array.prototype.sort.call(arr, (function(a, b) {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return 1;
                        if (a.place === "last" || b.place === "first") return -1;
                        return b.place - a.place;
                    }
                    return b.breakpoint - a.breakpoint;
                }));
                return;
            }
        };
        const da = new DynamicAdapt("max");
        da.init();
        function _assertThisInitialized(self) {
            if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
        }
        /*!
 * GSAP 3.12.0
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/        var _suppressOverwrites, _reverting, _context, _globalTimeline, _win, _coreInitted, _doc, _coreReady, _lastRenderedFrame, _quickTween, _tickerActive, _config = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, _defaults = {
            duration: .5,
            overwrite: false,
            delay: 0
        }, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString(value) {
            return typeof value === "string";
        }, _isFunction = function _isFunction(value) {
            return typeof value === "function";
        }, _isNumber = function _isNumber(value) {
            return typeof value === "number";
        }, _isUndefined = function _isUndefined(value) {
            return typeof value === "undefined";
        }, _isObject = function _isObject(value) {
            return typeof value === "object";
        }, _isNotFalse = function _isNotFalse(value) {
            return value !== false;
        }, _windowExists = function _windowExists() {
            return typeof window !== "undefined";
        }, _isFuncOrString = function _isFuncOrString(value) {
            return _isFunction(value) || _isString(value);
        }, _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {}, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globals = {}, _installScope = {}, _install = function _install(scope) {
            return (_installScope = _merge(scope, _globals)) && gsap;
        }, _missingPlugin = function _missingPlugin(property, value) {
            return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
        }, _warn = function _warn(message, suppress) {
            return !suppress && console.warn(message);
        }, _addGlobal = function _addGlobal(name, obj) {
            return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
        }, _emptyFunc = function _emptyFunc() {
            return 0;
        }, _startAtRevertConfig = {
            suppressEvents: true,
            isStart: true,
            kill: false
        }, _revertConfigNoKill = {
            suppressEvents: true,
            kill: false
        }, _revertConfig = {
            suppressEvents: true
        }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function _harness(targets) {
            var harnessPlugin, i, target = targets[0];
            _isObject(target) || _isFunction(target) || (targets = [ targets ]);
            if (!(harnessPlugin = (target._gsap || {}).harness)) {
                i = _harnessPlugins.length;
                while (i-- && !_harnessPlugins[i].targetTest(target)) ;
                harnessPlugin = _harnessPlugins[i];
            }
            i = targets.length;
            while (i--) targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
            return targets;
        }, _getCache = function _getCache(target) {
            return target._gsap || _harness(toArray(target))[0]._gsap;
        }, _getProperty = function _getProperty(target, property, v) {
            return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
        }, _forEachName = function _forEachName(names, func) {
            return (names = names.split(",")).forEach(func) || names;
        }, _round = function _round(value) {
            return Math.round(value * 1e5) / 1e5 || 0;
        }, _roundPrecise = function _roundPrecise(value) {
            return Math.round(value * 1e7) / 1e7 || 0;
        }, _parseRelative = function _parseRelative(start, value) {
            var operator = value.charAt(0), end = parseFloat(value.substr(2));
            start = parseFloat(start);
            return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
        }, _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
            var l = toFind.length, i = 0;
            for (;toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) ;
            return i < l;
        }, _lazyRender = function _lazyRender() {
            var i, tween, l = _lazyTweens.length, a = _lazyTweens.slice(0);
            _lazyLookup = {};
            _lazyTweens.length = 0;
            for (i = 0; i < l; i++) {
                tween = a[i];
                tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
            }
        }, _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
            _lazyTweens.length && !_reverting && _lazyRender();
            animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
            _lazyTweens.length && !_reverting && _lazyRender();
        }, _numericIfPossible = function _numericIfPossible(value) {
            var n = parseFloat(value);
            return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
        }, _passThrough = function _passThrough(p) {
            return p;
        }, _setDefaults = function _setDefaults(obj, defaults) {
            for (var p in defaults) p in obj || (obj[p] = defaults[p]);
            return obj;
        }, _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
            return function(obj, defaults) {
                for (var p in defaults) p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
            };
        }, _merge = function _merge(base, toMerge) {
            for (var p in toMerge) base[p] = toMerge[p];
            return base;
        }, _mergeDeep = function _mergeDeep(base, toMerge) {
            for (var p in toMerge) p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
            return base;
        }, _copyExcluding = function _copyExcluding(obj, excluding) {
            var p, copy = {};
            for (p in obj) p in excluding || (copy[p] = obj[p]);
            return copy;
        }, _inheritDefaults = function _inheritDefaults(vars) {
            var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
            if (_isNotFalse(vars.inherit)) while (parent) {
                func(vars, parent.vars.defaults);
                parent = parent.parent || parent._dp;
            }
            return vars;
        }, _arraysMatch = function _arraysMatch(a1, a2) {
            var i = a1.length, match = i === a2.length;
            while (match && i-- && a1[i] === a2[i]) ;
            return i < 0;
        }, _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
            if (firstProp === void 0) firstProp = "_first";
            if (lastProp === void 0) lastProp = "_last";
            var t, prev = parent[lastProp];
            if (sortBy) {
                t = child[sortBy];
                while (prev && prev[sortBy] > t) prev = prev._prev;
            }
            if (prev) {
                child._next = prev._next;
                prev._next = child;
            } else {
                child._next = parent[firstProp];
                parent[firstProp] = child;
            }
            if (child._next) child._next._prev = child; else parent[lastProp] = child;
            child._prev = prev;
            child.parent = child._dp = parent;
            return child;
        }, _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
            if (firstProp === void 0) firstProp = "_first";
            if (lastProp === void 0) lastProp = "_last";
            var prev = child._prev, next = child._next;
            if (prev) prev._next = next; else if (parent[firstProp] === child) parent[firstProp] = next;
            if (next) next._prev = prev; else if (parent[lastProp] === child) parent[lastProp] = prev;
            child._next = child._prev = child.parent = null;
        }, _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
            child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
            child._act = 0;
        }, _uncache = function _uncache(animation, child) {
            if (animation && (!child || child._end > animation._dur || child._start < 0)) {
                var a = animation;
                while (a) {
                    a._dirty = 1;
                    a = a.parent;
                }
            }
            return animation;
        }, _recacheAncestors = function _recacheAncestors(animation) {
            var parent = animation.parent;
            while (parent && parent.parent) {
                parent._dirty = 1;
                parent.totalDuration();
                parent = parent.parent;
            }
            return animation;
        }, _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
            return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
        }, _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
            return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
        }, _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
            return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
        }, _animationCycle = function _animationCycle(tTime, cycleDuration) {
            var whole = Math.floor(tTime /= cycleDuration);
            return tTime && whole === tTime ? whole - 1 : whole;
        }, _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
            return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
        }, _setEnd = function _setEnd(animation) {
            return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
        }, _alignPlayhead = function _alignPlayhead(animation, totalTime) {
            var parent = animation._dp;
            if (parent && parent.smoothChildTiming && animation._ts) {
                animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
                _setEnd(animation);
                parent._dirty || _uncache(parent, animation);
            }
            return animation;
        }, _postAddChecks = function _postAddChecks(timeline, child) {
            var t;
            if (child._time || child._initted && !child._dur) {
                t = _parentToChildTotalTime(timeline.rawTime(), child);
                if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) child.render(t, true);
            }
            if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
                if (timeline._dur < timeline.duration()) {
                    t = timeline;
                    while (t._dp) {
                        t.rawTime() >= 0 && t.totalTime(t._tTime);
                        t = t._dp;
                    }
                }
                timeline._zTime = -_tinyNum;
            }
        }, _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
            child.parent && _removeFromParent(child);
            child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
            child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
            _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
            _isFromOrFromStart(child) || (timeline._recent = child);
            skipChecks || _postAddChecks(timeline, child);
            timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
            return timeline;
        }, _scrollTrigger = function _scrollTrigger(animation, trigger) {
            return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
        }, _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
            _initTween(tween, time, tTime);
            if (!tween._initted) return 1;
            if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
                _lazyTweens.push(tween);
                tween._lazy = [ tTime, suppressEvents ];
                return 1;
            }
        }, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
            var parent = _ref.parent;
            return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
        }, _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
            var data = _ref2.data;
            return data === "isFromStart" || data === "isStart";
        }, _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
            var pt, iteration, prevIteration, prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0;
            if (repeatDelay && tween._repeat) {
                tTime = _clamp(0, tween._tDur, totalTime);
                iteration = _animationCycle(tTime, repeatDelay);
                tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
                if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
                    prevRatio = 1 - ratio;
                    tween.vars.repeatRefresh && tween._initted && tween.invalidate();
                }
            }
            if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
                if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) return;
                prevIteration = tween._zTime;
                tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
                suppressEvents || (suppressEvents = totalTime && !prevIteration);
                tween.ratio = ratio;
                tween._from && (ratio = 1 - ratio);
                tween._time = 0;
                tween._tTime = tTime;
                pt = tween._pt;
                while (pt) {
                    pt.r(ratio, pt.d);
                    pt = pt._next;
                }
                totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
                tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
                tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
                if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
                    ratio && _removeFromParent(tween, 1);
                    if (!suppressEvents && !_reverting) {
                        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
                        tween._prom && tween._prom();
                    }
                }
            } else if (!tween._zTime) tween._zTime = totalTime;
        }, _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
            var child;
            if (time > prevTime) {
                child = animation._first;
                while (child && child._start <= time) {
                    if (child.data === "isPause" && child._start > prevTime) return child;
                    child = child._next;
                }
            } else {
                child = animation._last;
                while (child && child._start >= time) {
                    if (child.data === "isPause" && child._start < prevTime) return child;
                    child = child._prev;
                }
            }
        }, _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
            var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
            totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
            animation._dur = dur;
            animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
            totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
            animation.parent && _setEnd(animation);
            skipUncache || _uncache(animation.parent, animation);
            return animation;
        }, _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
            return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
        }, _zeroPosition = {
            _start: 0,
            endTime: _emptyFunc,
            totalDuration: _emptyFunc
        }, _parsePosition = function _parsePosition(animation, position, percentAnimation) {
            var i, offset, isPercent, labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur;
            if (_isString(position) && (isNaN(position) || position in labels)) {
                offset = position.charAt(0);
                isPercent = position.substr(-1) === "%";
                i = position.indexOf("=");
                if (offset === "<" || offset === ">") {
                    i >= 0 && (position = position.replace(/=/, ""));
                    return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
                }
                if (i < 0) {
                    position in labels || (labels[position] = clippedDuration);
                    return labels[position];
                }
                offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
                if (isPercent && percentAnimation) offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
                return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
            }
            return position == null ? clippedDuration : +position;
        }, _createTweenType = function _createTweenType(type, params, timeline) {
            var irVars, parent, isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex];
            isLegacy && (vars.duration = params[1]);
            vars.parent = timeline;
            if (type) {
                irVars = vars;
                parent = timeline;
                while (parent && !("immediateRender" in irVars)) {
                    irVars = parent.vars.defaults || {};
                    parent = _isNotFalse(parent.vars.inherit) && parent.parent;
                }
                vars.immediateRender = _isNotFalse(irVars.immediateRender);
                type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
            }
            return new Tween(params[0], vars, params[varsIndex + 1]);
        }, _conditionalReturn = function _conditionalReturn(value, func) {
            return value || value === 0 ? func(value) : func;
        }, _clamp = function _clamp(min, max, value) {
            return value < min ? min : value > max ? max : value;
        }, getUnit = function getUnit(value, v) {
            return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
        }, clamp = function clamp(min, max, value) {
            return _conditionalReturn(value, (function(v) {
                return _clamp(min, max, v);
            }));
        }, _slice = [].slice, _isArrayLike = function _isArrayLike(value, nonEmpty) {
            return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
        }, _flatten = function _flatten(ar, leaveStrings, accumulator) {
            if (accumulator === void 0) accumulator = [];
            return ar.forEach((function(value) {
                var _accumulator;
                return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
            })) || accumulator;
        }, toArray = function toArray(value, scope, leaveStrings) {
            return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [ value ] : [];
        }, selector = function selector(value) {
            value = toArray(value)[0] || _warn("Invalid scope") || {};
            return function(v) {
                var el = value.current || value.nativeElement || value;
                return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
            };
        }, shuffle = function shuffle(a) {
            return a.sort((function() {
                return .5 - Math.random();
            }));
        }, distribute = function distribute(v) {
            if (_isFunction(v)) return v;
            var vars = _isObject(v) ? v : {
                each: v
            }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
            if (_isString(from)) ratioX = ratioY = {
                center: .5,
                edges: .5,
                end: 1
            }[from] || 0; else if (!isDecimal && ratios) {
                ratioX = from[0];
                ratioY = from[1];
            }
            return function(i, target, a) {
                var originX, originY, x, y, d, j, max, min, wrapAt, l = (a || vars).length, distances = cache[l];
                if (!distances) {
                    wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [ 1, _bigNum ])[1];
                    if (!wrapAt) {
                        max = -_bigNum;
                        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) ;
                        wrapAt--;
                    }
                    distances = cache[l] = [];
                    originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
                    originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
                    max = 0;
                    min = _bigNum;
                    for (j = 0; j < l; j++) {
                        x = j % wrapAt - originX;
                        y = originY - (j / wrapAt | 0);
                        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
                        d > max && (max = d);
                        d < min && (min = d);
                    }
                    from === "random" && shuffle(distances);
                    distances.max = max - min;
                    distances.min = min;
                    distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
                    distances.b = l < 0 ? base - l : base;
                    distances.u = getUnit(vars.amount || vars.each) || 0;
                    ease = ease && l < 0 ? _invertEase(ease) : ease;
                }
                l = (distances[i] - distances.min) / distances.max || 0;
                return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
            };
        }, _roundModifier = function _roundModifier(v) {
            var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
            return function(raw) {
                var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
                return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
            };
        }, snap = function snap(snapTo, value) {
            var radius, is2D, isArray = _isArray(snapTo);
            if (!isArray && _isObject(snapTo)) {
                radius = isArray = snapTo.radius || _bigNum;
                if (snapTo.values) {
                    snapTo = toArray(snapTo.values);
                    if (is2D = !_isNumber(snapTo[0])) radius *= radius;
                } else snapTo = _roundModifier(snapTo.increment);
            }
            return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
                is2D = snapTo(raw);
                return Math.abs(is2D - raw) <= radius ? is2D : raw;
            } : function(raw) {
                var dx, dy, x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length;
                while (i--) {
                    if (is2D) {
                        dx = snapTo[i].x - x;
                        dy = snapTo[i].y - y;
                        dx = dx * dx + dy * dy;
                    } else dx = Math.abs(snapTo[i] - x);
                    if (dx < min) {
                        min = dx;
                        closest = i;
                    }
                }
                closest = !radius || min <= radius ? snapTo[closest] : raw;
                return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
            });
        }, random = function random(min, max, roundingIncrement, returnFunction) {
            return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, (function() {
                return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
            }));
        }, pipe = function pipe() {
            for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) functions[_key] = arguments[_key];
            return function(value) {
                return functions.reduce((function(v, f) {
                    return f(v);
                }), value);
            };
        }, unitize = function unitize(func, unit) {
            return function(value) {
                return func(parseFloat(value)) + (unit || getUnit(value));
            };
        }, normalize = function normalize(min, max, value) {
            return mapRange(min, max, 0, 1, value);
        }, _wrapArray = function _wrapArray(a, wrapper, value) {
            return _conditionalReturn(value, (function(index) {
                return a[~~wrapper(index)];
            }));
        }, wrap = function wrap(min, max, value) {
            var range = max - min;
            return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, (function(value) {
                return (range + (value - min) % range) % range + min;
            }));
        }, wrapYoyo = function wrapYoyo(min, max, value) {
            var range = max - min, total = range * 2;
            return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, (function(value) {
                value = (total + (value - min) % total) % total || 0;
                return min + (value > range ? total - value : value);
            }));
        }, _replaceRandom = function _replaceRandom(value) {
            var i, nums, end, isArray, prev = 0, s = "";
            while (~(i = value.indexOf("random(", prev))) {
                end = value.indexOf(")", i);
                isArray = value.charAt(i + 7) === "[";
                nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
                s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
                prev = end + 1;
            }
            return s + value.substr(prev, value.length - prev);
        }, mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
            var inRange = inMax - inMin, outRange = outMax - outMin;
            return _conditionalReturn(value, (function(value) {
                return outMin + ((value - inMin) / inRange * outRange || 0);
            }));
        }, interpolate = function interpolate(start, end, progress, mutate) {
            var func = isNaN(start + end) ? 0 : function(p) {
                return (1 - p) * start + p * end;
            };
            if (!func) {
                var p, i, interpolators, l, il, isString = _isString(start), master = {};
                progress === true && (mutate = 1) && (progress = null);
                if (isString) {
                    start = {
                        p: start
                    };
                    end = {
                        p: end
                    };
                } else if (_isArray(start) && !_isArray(end)) {
                    interpolators = [];
                    l = start.length;
                    il = l - 2;
                    for (i = 1; i < l; i++) interpolators.push(interpolate(start[i - 1], start[i]));
                    l--;
                    func = function func(p) {
                        p *= l;
                        var i = Math.min(il, ~~p);
                        return interpolators[i](p - i);
                    };
                    progress = end;
                } else if (!mutate) start = _merge(_isArray(start) ? [] : {}, start);
                if (!interpolators) {
                    for (p in end) _addPropTween.call(master, start, p, "get", end[p]);
                    func = function func(p) {
                        return _renderPropTweens(p, master) || (isString ? start.p : start);
                    };
                }
            }
            return _conditionalReturn(progress, func);
        }, _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
            var p, distance, label, labels = timeline.labels, min = _bigNum;
            for (p in labels) {
                distance = labels[p] - fromTime;
                if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
                    label = p;
                    min = distance;
                }
            }
            return label;
        }, _callback = function _callback(animation, type, executeLazyFirst) {
            var params, scope, result, v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx;
            if (!callback) return;
            params = v[type + "Params"];
            scope = v.callbackScope || animation;
            executeLazyFirst && _lazyTweens.length && _lazyRender();
            context && (_context = context);
            result = params ? callback.apply(scope, params) : callback.call(scope);
            _context = prevContext;
            return result;
        }, _interrupt = function _interrupt(animation) {
            _removeFromParent(animation);
            animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
            animation.progress() < 1 && _callback(animation, "onInterrupt");
            return animation;
        }, _registerPluginQueue = [], _createPlugin = function _createPlugin(config) {
            if (_windowExists() && config) {
                config = !config.name && config["default"] || config;
                var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function() {
                    this._props = [];
                } : config, instanceDefaults = {
                    init: _emptyFunc,
                    render: _renderPropTweens,
                    add: _addPropTween,
                    kill: _killPropTweensOf,
                    modifier: _addPluginModifier,
                    rawVars: 0
                }, statics = {
                    targetTest: 0,
                    get: 0,
                    getSetter: _getSetter,
                    aliases: {},
                    register: 0
                };
                _wake();
                if (config !== Plugin) {
                    if (_plugins[name]) return;
                    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
                    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
                    _plugins[Plugin.prop = name] = Plugin;
                    if (config.targetTest) {
                        _harnessPlugins.push(Plugin);
                        _reservedProps[name] = 1;
                    }
                    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
                }
                _addGlobal(name, Plugin);
                config.register && config.register(gsap, Plugin, PropTween);
            } else config && _registerPluginQueue.push(config);
        }, _255 = 255, _colorLookup = {
            aqua: [ 0, _255, _255 ],
            lime: [ 0, _255, 0 ],
            silver: [ 192, 192, 192 ],
            black: [ 0, 0, 0 ],
            maroon: [ 128, 0, 0 ],
            teal: [ 0, 128, 128 ],
            blue: [ 0, 0, _255 ],
            navy: [ 0, 0, 128 ],
            white: [ _255, _255, _255 ],
            olive: [ 128, 128, 0 ],
            yellow: [ _255, _255, 0 ],
            orange: [ _255, 165, 0 ],
            gray: [ 128, 128, 128 ],
            purple: [ 128, 0, 128 ],
            green: [ 0, 128, 0 ],
            red: [ _255, 0, 0 ],
            pink: [ _255, 192, 203 ],
            cyan: [ 0, _255, _255 ],
            transparent: [ _255, _255, _255, 0 ]
        }, _hue = function _hue(h, m1, m2) {
            h += h < 0 ? 1 : h > 1 ? -1 : 0;
            return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
        }, splitColor = function splitColor(v, toHSL, forceAlpha) {
            var r, g, b, h, s, l, max, min, d, wasHSL, a = !v ? _colorLookup.black : _isNumber(v) ? [ v >> 16, v >> 8 & _255, v & _255 ] : 0;
            if (!a) {
                if (v.substr(-1) === ",") v = v.substr(0, v.length - 1);
                if (_colorLookup[v]) a = _colorLookup[v]; else if (v.charAt(0) === "#") {
                    if (v.length < 6) {
                        r = v.charAt(1);
                        g = v.charAt(2);
                        b = v.charAt(3);
                        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
                    }
                    if (v.length === 9) {
                        a = parseInt(v.substr(1, 6), 16);
                        return [ a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255 ];
                    }
                    v = parseInt(v.substr(1), 16);
                    a = [ v >> 16, v >> 8 & _255, v & _255 ];
                } else if (v.substr(0, 3) === "hsl") {
                    a = wasHSL = v.match(_strictNumExp);
                    if (!toHSL) {
                        h = +a[0] % 360 / 360;
                        s = +a[1] / 100;
                        l = +a[2] / 100;
                        g = l <= .5 ? l * (s + 1) : l + s - l * s;
                        r = l * 2 - g;
                        a.length > 3 && (a[3] *= 1);
                        a[0] = _hue(h + 1 / 3, r, g);
                        a[1] = _hue(h, r, g);
                        a[2] = _hue(h - 1 / 3, r, g);
                    } else if (~v.indexOf("=")) {
                        a = v.match(_numExp);
                        forceAlpha && a.length < 4 && (a[3] = 1);
                        return a;
                    }
                } else a = v.match(_strictNumExp) || _colorLookup.transparent;
                a = a.map(Number);
            }
            if (toHSL && !wasHSL) {
                r = a[0] / _255;
                g = a[1] / _255;
                b = a[2] / _255;
                max = Math.max(r, g, b);
                min = Math.min(r, g, b);
                l = (max + min) / 2;
                if (max === min) h = s = 0; else {
                    d = max - min;
                    s = l > .5 ? d / (2 - max - min) : d / (max + min);
                    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
                    h *= 60;
                }
                a[0] = ~~(h + .5);
                a[1] = ~~(s * 100 + .5);
                a[2] = ~~(l * 100 + .5);
            }
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
        }, _colorOrderData = function _colorOrderData(v) {
            var values = [], c = [], i = -1;
            v.split(_colorExp).forEach((function(v) {
                var a = v.match(_numWithUnitExp) || [];
                values.push.apply(values, a);
                c.push(i += a.length + 1);
            }));
            values.c = c;
            return values;
        }, _formatColors = function _formatColors(s, toHSL, orderMatchData) {
            var c, shell, d, l, result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0;
            if (!colors) return s;
            colors = colors.map((function(color) {
                return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
            }));
            if (orderMatchData) {
                d = _colorOrderData(s);
                c = orderMatchData.c;
                if (c.join(result) !== d.c.join(result)) {
                    shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
                    l = shell.length - 1;
                    for (;i < l; i++) result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
                }
            }
            if (!shell) {
                shell = s.split(_colorExp);
                l = shell.length - 1;
                for (;i < l; i++) result += shell[i] + colors[i];
            }
            return result + shell[l];
        }, _colorExp = function() {
            var p, s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (p in _colorLookup) s += "|" + p + "\\b";
            return new RegExp(s + ")", "gi");
        }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function _colorStringFilter(a) {
            var toHSL, combined = a.join(" ");
            _colorExp.lastIndex = 0;
            if (_colorExp.test(combined)) {
                toHSL = _hslExp.test(combined);
                a[1] = _formatColors(a[1], toHSL);
                a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
                return true;
            }
        }, _ticker = function() {
            var _id, _req, _raf, _self, _delta, _i, _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners = [], _tick = function _tick(v) {
                var overlap, dispatch, time, frame, elapsed = _getTime() - _lastUpdate, manual = v === true;
                elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
                _lastUpdate += elapsed;
                time = _lastUpdate - _startTime;
                overlap = time - _nextTime;
                if (overlap > 0 || manual) {
                    frame = ++_self.frame;
                    _delta = time - _self.time * 1e3;
                    _self.time = time /= 1e3;
                    _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
                    dispatch = 1;
                }
                manual || (_id = _req(_tick));
                if (dispatch) for (_i = 0; _i < _listeners.length; _i++) _listeners[_i](time, _delta, frame, v);
            };
            _self = {
                time: 0,
                frame: 0,
                tick: function tick() {
                    _tick(true);
                },
                deltaRatio: function deltaRatio(fps) {
                    return _delta / (1e3 / (fps || 60));
                },
                wake: function wake() {
                    if (_coreReady) {
                        if (!_coreInitted && _windowExists()) {
                            _win = _coreInitted = window;
                            _doc = _win.document || {};
                            _globals.gsap = gsap;
                            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                            _raf = _win.requestAnimationFrame;
                            _registerPluginQueue.forEach(_createPlugin);
                        }
                        _id && _self.sleep();
                        _req = _raf || function(f) {
                            return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
                        };
                        _tickerActive = 1;
                        _tick(2);
                    }
                },
                sleep: function sleep() {
                    (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
                    _tickerActive = 0;
                    _req = _emptyFunc;
                },
                lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                    _lagThreshold = threshold || 1 / 0;
                    _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
                },
                fps: function fps(_fps) {
                    _gap = 1e3 / (_fps || 240);
                    _nextTime = _self.time * 1e3 + _gap;
                },
                add: function add(callback, once, prioritize) {
                    var func = once ? function(t, d, f, v) {
                        callback(t, d, f, v);
                        _self.remove(func);
                    } : callback;
                    _self.remove(callback);
                    _listeners[prioritize ? "unshift" : "push"](func);
                    _wake();
                    return func;
                },
                remove: function remove(callback, i) {
                    ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
                },
                _listeners
            };
            return _self;
        }(), _wake = function _wake() {
            return !_tickerActive && _ticker.wake();
        }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function _parseObjectInString(value) {
            var index, val, parsedVal, obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length;
            for (;i < l; i++) {
                val = split[i];
                index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
                parsedVal = val.substr(0, index);
                obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
                key = val.substr(index + 1).trim();
            }
            return obj;
        }, _valueInParentheses = function _valueInParentheses(value) {
            var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
            return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
        }, _configEaseFromString = function _configEaseFromString(name) {
            var split = (name + "").split("("), ease = _easeMap[split[0]];
            return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [ _parseObjectInString(split[1]) ] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
        }, _invertEase = function _invertEase(ease) {
            return function(p) {
                return 1 - ease(1 - p);
            };
        }, _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
            var ease, child = timeline._first;
            while (child) {
                if (child instanceof Timeline) _propagateYoyoEase(child, isYoyo); else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) if (child.timeline) _propagateYoyoEase(child.timeline, isYoyo); else {
                    ease = child._ease;
                    child._ease = child._yEase;
                    child._yEase = ease;
                    child._yoyo = isYoyo;
                }
                child = child._next;
            }
        }, _parseEase = function _parseEase(ease, defaultEase) {
            return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
        }, _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
            if (easeOut === void 0) easeOut = function easeOut(p) {
                return 1 - easeIn(1 - p);
            };
            if (easeInOut === void 0) easeInOut = function easeInOut(p) {
                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
            };
            var lowercaseName, ease = {
                easeIn,
                easeOut,
                easeInOut
            };
            _forEachName(names, (function(name) {
                _easeMap[name] = _globals[name] = ease;
                _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
                for (var p in ease) _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
            }));
            return ease;
        }, _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
            return function(p) {
                return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
            };
        }, _configElastic = function _configElastic(type, amplitude, period) {
            var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut(p) {
                return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
            }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
                return 1 - easeOut(1 - p);
            } : _easeInOutFromOut(easeOut);
            p2 = _2PI / p2;
            ease.config = function(amplitude, period) {
                return _configElastic(type, amplitude, period);
            };
            return ease;
        }, _configBack = function _configBack(type, overshoot) {
            if (overshoot === void 0) overshoot = 1.70158;
            var easeOut = function easeOut(p) {
                return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
            }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
                return 1 - easeOut(1 - p);
            } : _easeInOutFromOut(easeOut);
            ease.config = function(overshoot) {
                return _configBack(type, overshoot);
            };
            return ease;
        };
        _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", (function(name, i) {
            var power = i < 5 ? i + 1 : i;
            _insertEase(name + ",Power" + (power - 1), i ? function(p) {
                return Math.pow(p, power);
            } : function(p) {
                return p;
            }, (function(p) {
                return 1 - Math.pow(1 - p, power);
            }), (function(p) {
                return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
            }));
        }));
        _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
        _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
        (function(n, c) {
            var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut(p) {
                return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
            };
            _insertEase("Bounce", (function(p) {
                return 1 - easeOut(1 - p);
            }), easeOut);
        })(7.5625, 2.75);
        _insertEase("Expo", (function(p) {
            return p ? Math.pow(2, 10 * (p - 1)) : 0;
        }));
        _insertEase("Circ", (function(p) {
            return -(_sqrt(1 - p * p) - 1);
        }));
        _insertEase("Sine", (function(p) {
            return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
        }));
        _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
        _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
            config: function config(steps, immediateStart) {
                if (steps === void 0) steps = 1;
                var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
                return function(p) {
                    return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
                };
            }
        };
        _defaults.ease = _easeMap["quad.out"];
        _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(name) {
            return _callbackNames += name + "," + name + "Params,";
        }));
        var GSCache = function GSCache(target, harness) {
            this.id = _gsID++;
            target._gsap = this;
            this.target = target;
            this.harness = harness;
            this.get = harness ? harness.get : _getProperty;
            this.set = harness ? harness.getSetter : _getSetter;
        };
        var Animation = function() {
            function Animation(vars) {
                this.vars = vars;
                this._delay = +vars.delay || 0;
                if (this._repeat = vars.repeat === 1 / 0 ? -2 : vars.repeat || 0) {
                    this._rDelay = vars.repeatDelay || 0;
                    this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
                }
                this._ts = 1;
                _setDuration(this, +vars.duration, 1, 1);
                this.data = vars.data;
                if (_context) {
                    this._ctx = _context;
                    _context.data.push(this);
                }
                _tickerActive || _ticker.wake();
            }
            var _proto = Animation.prototype;
            _proto.delay = function delay(value) {
                if (value || value === 0) {
                    this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
                    this._delay = value;
                    return this;
                }
                return this._delay;
            };
            _proto.duration = function duration(value) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
            };
            _proto.totalDuration = function totalDuration(value) {
                if (!arguments.length) return this._tDur;
                this._dirty = 0;
                return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
            };
            _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
                _wake();
                if (!arguments.length) return this._tTime;
                var parent = this._dp;
                if (parent && parent.smoothChildTiming && this._ts) {
                    _alignPlayhead(this, _totalTime);
                    !parent._dp || parent.parent || _postAddChecks(parent, this);
                    while (parent && parent.parent) {
                        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) parent.totalTime(parent._tTime, true);
                        parent = parent.parent;
                    }
                    if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) _addToTimeline(this._dp, this, this._start - this._delay);
                }
                if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
                    this._ts || (this._pTime = _totalTime);
                    _lazySafeRender(this, _totalTime, suppressEvents);
                }
                return this;
            };
            _proto.time = function time(value, suppressEvents) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
            };
            _proto.totalProgress = function totalProgress(value, suppressEvents) {
                return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
            };
            _proto.progress = function progress(value, suppressEvents) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
            };
            _proto.iteration = function iteration(value, suppressEvents) {
                var cycleDuration = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
            };
            _proto.timeScale = function timeScale(value) {
                if (!arguments.length) return this._rts === -_tinyNum ? 0 : this._rts;
                if (this._rts === value) return this;
                var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
                this._rts = +value || 0;
                this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
                this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), true);
                _setEnd(this);
                return _recacheAncestors(this);
            };
            _proto.paused = function paused(value) {
                if (!arguments.length) return this._ps;
                if (this._ps !== value) {
                    this._ps = value;
                    if (value) {
                        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
                        this._ts = this._act = 0;
                    } else {
                        _wake();
                        this._ts = this._rts;
                        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
                    }
                }
                return this;
            };
            _proto.startTime = function startTime(value) {
                if (arguments.length) {
                    this._start = value;
                    var parent = this.parent || this._dp;
                    parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
                    return this;
                }
                return this._start;
            };
            _proto.endTime = function endTime(includeRepeats) {
                return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
            };
            _proto.rawTime = function rawTime(wrapRepeats) {
                var parent = this.parent || this._dp;
                return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
            };
            _proto.revert = function revert(config) {
                if (config === void 0) config = _revertConfig;
                var prevIsReverting = _reverting;
                _reverting = config;
                if (this._initted || this._startAt) {
                    this.timeline && this.timeline.revert(config);
                    this.totalTime(-.01, config.suppressEvents);
                }
                this.data !== "nested" && config.kill !== false && this.kill();
                _reverting = prevIsReverting;
                return this;
            };
            _proto.globalTime = function globalTime(rawTime) {
                var animation = this, time = arguments.length ? rawTime : animation.rawTime();
                while (animation) {
                    time = animation._start + time / (animation._ts || 1);
                    animation = animation._dp;
                }
                return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(rawTime) : time;
            };
            _proto.repeat = function repeat(value) {
                if (arguments.length) {
                    this._repeat = value === 1 / 0 ? -2 : value;
                    return _onUpdateTotalDuration(this);
                }
                return this._repeat === -2 ? 1 / 0 : this._repeat;
            };
            _proto.repeatDelay = function repeatDelay(value) {
                if (arguments.length) {
                    var time = this._time;
                    this._rDelay = value;
                    _onUpdateTotalDuration(this);
                    return time ? this.time(time) : this;
                }
                return this._rDelay;
            };
            _proto.yoyo = function yoyo(value) {
                if (arguments.length) {
                    this._yoyo = value;
                    return this;
                }
                return this._yoyo;
            };
            _proto.seek = function seek(position, suppressEvents) {
                return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
            };
            _proto.restart = function restart(includeDelay, suppressEvents) {
                return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
            };
            _proto.play = function play(from, suppressEvents) {
                from != null && this.seek(from, suppressEvents);
                return this.reversed(false).paused(false);
            };
            _proto.reverse = function reverse(from, suppressEvents) {
                from != null && this.seek(from || this.totalDuration(), suppressEvents);
                return this.reversed(true).paused(false);
            };
            _proto.pause = function pause(atTime, suppressEvents) {
                atTime != null && this.seek(atTime, suppressEvents);
                return this.paused(true);
            };
            _proto.resume = function resume() {
                return this.paused(false);
            };
            _proto.reversed = function reversed(value) {
                if (arguments.length) {
                    !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
                    return this;
                }
                return this._rts < 0;
            };
            _proto.invalidate = function invalidate() {
                this._initted = this._act = 0;
                this._zTime = -_tinyNum;
                return this;
            };
            _proto.isActive = function isActive() {
                var rawTime, parent = this.parent || this._dp, start = this._start;
                return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
            };
            _proto.eventCallback = function eventCallback(type, callback, params) {
                var vars = this.vars;
                if (arguments.length > 1) {
                    if (!callback) delete vars[type]; else {
                        vars[type] = callback;
                        params && (vars[type + "Params"] = params);
                        type === "onUpdate" && (this._onUpdate = callback);
                    }
                    return this;
                }
                return vars[type];
            };
            _proto.then = function then(onFulfilled) {
                var self = this;
                return new Promise((function(resolve) {
                    var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve() {
                        var _then = self.then;
                        self.then = null;
                        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
                        resolve(f);
                        self.then = _then;
                    };
                    if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) _resolve(); else self._prom = _resolve;
                }));
            };
            _proto.kill = function kill() {
                _interrupt(this);
            };
            return Animation;
        }();
        _setDefaults(Animation.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: false,
            parent: null,
            _initted: false,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -_tinyNum,
            _prom: 0,
            _ps: false,
            _rts: 1
        });
        var Timeline = function(_Animation) {
            _inheritsLoose(Timeline, _Animation);
            function Timeline(vars, position) {
                var _this;
                if (vars === void 0) vars = {};
                _this = _Animation.call(this, vars) || this;
                _this.labels = {};
                _this.smoothChildTiming = !!vars.smoothChildTiming;
                _this.autoRemoveChildren = !!vars.autoRemoveChildren;
                _this._sort = _isNotFalse(vars.sortChildren);
                _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
                vars.reversed && _this.reverse();
                vars.paused && _this.paused(true);
                vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
                return _this;
            }
            var _proto2 = Timeline.prototype;
            _proto2.to = function to(targets, vars, position) {
                _createTweenType(0, arguments, this);
                return this;
            };
            _proto2.from = function from(targets, vars, position) {
                _createTweenType(1, arguments, this);
                return this;
            };
            _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
                _createTweenType(2, arguments, this);
                return this;
            };
            _proto2.set = function set(targets, vars, position) {
                vars.duration = 0;
                vars.parent = this;
                _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
                vars.immediateRender = !!vars.immediateRender;
                new Tween(targets, vars, _parsePosition(this, position), 1);
                return this;
            };
            _proto2.call = function call(callback, params, position) {
                return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
            };
            _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                vars.duration = duration;
                vars.stagger = vars.stagger || stagger;
                vars.onComplete = onCompleteAll;
                vars.onCompleteParams = onCompleteAllParams;
                vars.parent = this;
                new Tween(targets, vars, _parsePosition(this, position));
                return this;
            };
            _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                vars.runBackwards = 1;
                _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
                return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
            };
            _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
                toVars.startAt = fromVars;
                _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
                return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
            };
            _proto2.render = function render(totalTime, suppressEvents, force) {
                var time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo, prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur);
                this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
                if (tTime !== this._tTime || force || crossingStart) {
                    if (prevTime !== this._time && dur) {
                        tTime += this._time - prevTime;
                        totalTime += this._time - prevTime;
                    }
                    time = tTime;
                    prevStart = this._start;
                    timeScale = this._ts;
                    prevPaused = !timeScale;
                    if (crossingStart) {
                        dur || (prevTime = this._zTime);
                        (totalTime || !suppressEvents) && (this._zTime = totalTime);
                    }
                    if (this._repeat) {
                        yoyo = this._yoyo;
                        cycleDuration = dur + this._rDelay;
                        if (this._repeat < -1 && totalTime < 0) return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
                        time = _roundPrecise(tTime % cycleDuration);
                        if (tTime === tDur) {
                            iteration = this._repeat;
                            time = dur;
                        } else {
                            iteration = ~~(tTime / cycleDuration);
                            if (iteration && iteration === tTime / cycleDuration) {
                                time = dur;
                                iteration--;
                            }
                            time > dur && (time = dur);
                        }
                        prevIteration = _animationCycle(this._tTime, cycleDuration);
                        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
                        if (yoyo && iteration & 1) {
                            time = dur - time;
                            isYoyo = 1;
                        }
                        if (iteration !== prevIteration && !this._lock) {
                            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
                            iteration < prevIteration && (rewinding = !rewinding);
                            prevTime = rewinding ? 0 : dur;
                            this._lock = 1;
                            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                            this._tTime = tTime;
                            !suppressEvents && this.parent && _callback(this, "onRepeat");
                            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            dur = this._dur;
                            tDur = this._tDur;
                            if (doesWrap) {
                                this._lock = 2;
                                prevTime = rewinding ? dur : -1e-4;
                                this.render(prevTime, true);
                                this.vars.repeatRefresh && !isYoyo && this.invalidate();
                            }
                            this._lock = 0;
                            if (!this._ts && !prevPaused) return this;
                            _propagateYoyoEase(this, isYoyo);
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2) {
                        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
                        if (pauseTween) tTime -= time - (time = pauseTween._start);
                    }
                    this._tTime = tTime;
                    this._time = time;
                    this._act = !timeScale;
                    if (!this._initted) {
                        this._onUpdate = this.vars.onUpdate;
                        this._initted = 1;
                        this._zTime = totalTime;
                        prevTime = 0;
                    }
                    if (!prevTime && time && !suppressEvents && !iteration) {
                        _callback(this, "onStart");
                        if (this._tTime !== tTime) return this;
                    }
                    if (time >= prevTime && totalTime >= 0) {
                        child = this._first;
                        while (child) {
                            next = child._next;
                            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                                if (child.parent !== this) return this.render(totalTime, suppressEvents, force);
                                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                                if (time !== this._time || !this._ts && !prevPaused) {
                                    pauseTween = 0;
                                    next && (tTime += this._zTime = -_tinyNum);
                                    break;
                                }
                            }
                            child = next;
                        }
                    } else {
                        child = this._last;
                        var adjustedTime = totalTime < 0 ? totalTime : time;
                        while (child) {
                            next = child._prev;
                            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                                if (child.parent !== this) return this.render(totalTime, suppressEvents, force);
                                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
                                if (time !== this._time || !this._ts && !prevPaused) {
                                    pauseTween = 0;
                                    next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                                    break;
                                }
                            }
                            child = next;
                        }
                    }
                    if (pauseTween && !suppressEvents) {
                        this.pause();
                        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
                        if (this._ts) {
                            this._start = prevStart;
                            _setEnd(this);
                            return this.render(totalTime, suppressEvents, force);
                        }
                    }
                    this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
                    if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                            _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                        }
                    }
                }
                return this;
            };
            _proto2.add = function add(child, position) {
                var _this2 = this;
                _isNumber(position) || (position = _parsePosition(this, position, child));
                if (!(child instanceof Animation)) {
                    if (_isArray(child)) {
                        child.forEach((function(obj) {
                            return _this2.add(obj, position);
                        }));
                        return this;
                    }
                    if (_isString(child)) return this.addLabel(child, position);
                    if (_isFunction(child)) child = Tween.delayedCall(0, child); else return this;
                }
                return this !== child ? _addToTimeline(this, child, position) : this;
            };
            _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
                if (nested === void 0) nested = true;
                if (tweens === void 0) tweens = true;
                if (timelines === void 0) timelines = true;
                if (ignoreBeforeTime === void 0) ignoreBeforeTime = -_bigNum;
                var a = [], child = this._first;
                while (child) {
                    if (child._start >= ignoreBeforeTime) if (child instanceof Tween) tweens && a.push(child); else {
                        timelines && a.push(child);
                        nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
                    }
                    child = child._next;
                }
                return a;
            };
            _proto2.getById = function getById(id) {
                var animations = this.getChildren(1, 1, 1), i = animations.length;
                while (i--) if (animations[i].vars.id === id) return animations[i];
            };
            _proto2.remove = function remove(child) {
                if (_isString(child)) return this.removeLabel(child);
                if (_isFunction(child)) return this.killTweensOf(child);
                _removeLinkedListItem(this, child);
                if (child === this._recent) this._recent = this._last;
                return _uncache(this);
            };
            _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
                if (!arguments.length) return this._tTime;
                this._forcing = 1;
                if (!this._dp && this._ts) this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
                _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
                this._forcing = 0;
                return this;
            };
            _proto2.addLabel = function addLabel(label, position) {
                this.labels[label] = _parsePosition(this, position);
                return this;
            };
            _proto2.removeLabel = function removeLabel(label) {
                delete this.labels[label];
                return this;
            };
            _proto2.addPause = function addPause(position, callback, params) {
                var t = Tween.delayedCall(0, callback || _emptyFunc, params);
                t.data = "isPause";
                this._hasPause = 1;
                return _addToTimeline(this, t, _parsePosition(this, position));
            };
            _proto2.removePause = function removePause(position) {
                var child = this._first;
                position = _parsePosition(this, position);
                while (child) {
                    if (child._start === position && child.data === "isPause") _removeFromParent(child);
                    child = child._next;
                }
            };
            _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
                while (i--) _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
                return this;
            };
            _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
                var children, a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive);
                while (child) {
                    if (child instanceof Tween) {
                        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) a.push(child);
                    } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) a.push.apply(a, children);
                    child = child._next;
                }
                return a;
            };
            _proto2.tweenTo = function tweenTo(position, vars) {
                vars = vars || {};
                var initted, tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, tween = Tween.to(tl, _setDefaults({
                    ease: vars.ease || "none",
                    lazy: false,
                    immediateRender: false,
                    time: endTime,
                    overwrite: "auto",
                    duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
                    onStart: function onStart() {
                        tl.pause();
                        if (!initted) {
                            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                            initted = 1;
                        }
                        _onStart && _onStart.apply(tween, onStartParams || []);
                    }
                }, vars));
                return immediateRender ? tween.render(0) : tween;
            };
            _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
                return this.tweenTo(toPosition, _setDefaults({
                    startAt: {
                        time: _parsePosition(this, fromPosition)
                    }
                }, vars));
            };
            _proto2.recent = function recent() {
                return this._recent;
            };
            _proto2.nextLabel = function nextLabel(afterTime) {
                if (afterTime === void 0) afterTime = this._time;
                return _getLabelInDirection(this, _parsePosition(this, afterTime));
            };
            _proto2.previousLabel = function previousLabel(beforeTime) {
                if (beforeTime === void 0) beforeTime = this._time;
                return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
            };
            _proto2.currentLabel = function currentLabel(value) {
                return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
            };
            _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
                if (ignoreBeforeTime === void 0) ignoreBeforeTime = 0;
                var p, child = this._first, labels = this.labels;
                while (child) {
                    if (child._start >= ignoreBeforeTime) {
                        child._start += amount;
                        child._end += amount;
                    }
                    child = child._next;
                }
                if (adjustLabels) for (p in labels) if (labels[p] >= ignoreBeforeTime) labels[p] += amount;
                return _uncache(this);
            };
            _proto2.invalidate = function invalidate(soft) {
                var child = this._first;
                this._lock = 0;
                while (child) {
                    child.invalidate(soft);
                    child = child._next;
                }
                return _Animation.prototype.invalidate.call(this, soft);
            };
            _proto2.clear = function clear(includeLabels) {
                if (includeLabels === void 0) includeLabels = true;
                var next, child = this._first;
                while (child) {
                    next = child._next;
                    this.remove(child);
                    child = next;
                }
                this._dp && (this._time = this._tTime = this._pTime = 0);
                includeLabels && (this.labels = {});
                return _uncache(this);
            };
            _proto2.totalDuration = function totalDuration(value) {
                var prev, start, parent, max = 0, self = this, child = self._last, prevStart = _bigNum;
                if (arguments.length) return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
                if (self._dirty) {
                    parent = self.parent;
                    while (child) {
                        prev = child._prev;
                        child._dirty && child.totalDuration();
                        start = child._start;
                        if (start > prevStart && self._sort && child._ts && !self._lock) {
                            self._lock = 1;
                            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
                        } else prevStart = start;
                        if (start < 0 && child._ts) {
                            max -= start;
                            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                                self._start += start / self._ts;
                                self._time -= start;
                                self._tTime -= start;
                            }
                            self.shiftChildren(-start, false, -Infinity);
                            prevStart = 0;
                        }
                        child._end > max && child._ts && (max = child._end);
                        child = prev;
                    }
                    _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
                    self._dirty = 0;
                }
                return self._tDur;
            };
            Timeline.updateRoot = function updateRoot(time) {
                if (_globalTimeline._ts) {
                    _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
                    _lastRenderedFrame = _ticker.frame;
                }
                if (_ticker.frame >= _nextGCFrame) {
                    _nextGCFrame += _config.autoSleep || 120;
                    var child = _globalTimeline._first;
                    if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
                        while (child && !child._ts) child = child._next;
                        child || _ticker.sleep();
                    }
                }
            };
            return Timeline;
        }(Animation);
        _setDefaults(Timeline.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var _overwritingTween, _forceAllPropTweens, _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
            var result, startNums, color, endNum, chunk, startNum, hasRandom, a, pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0;
            pt.b = start;
            pt.e = end;
            start += "";
            end += "";
            if (hasRandom = ~end.indexOf("random(")) end = _replaceRandom(end);
            if (stringFilter) {
                a = [ start, end ];
                stringFilter(a, target, prop);
                start = a[0];
                end = a[1];
            }
            startNums = start.match(_complexStringNumExp) || [];
            while (result = _complexStringNumExp.exec(end)) {
                endNum = result[0];
                chunk = end.substring(index, result.index);
                if (color) color = (color + 1) % 5; else if (chunk.substr(-5) === "rgba(") color = 1;
                if (endNum !== startNums[matchIndex++]) {
                    startNum = parseFloat(startNums[matchIndex - 1]) || 0;
                    pt._pt = {
                        _next: pt._pt,
                        p: chunk || matchIndex === 1 ? chunk : ",",
                        s: startNum,
                        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
                        m: color && color < 4 ? Math.round : 0
                    };
                    index = _complexStringNumExp.lastIndex;
                }
            }
            pt.c = index < end.length ? end.substring(index, end.length) : "";
            pt.fp = funcParam;
            if (_relExp.test(end) || hasRandom) pt.e = 0;
            this._pt = pt;
            return pt;
        }, _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
            _isFunction(end) && (end = end(index || 0, target, targets));
            var pt, currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc;
            if (_isString(end)) {
                if (~end.indexOf("random(")) end = _replaceRandom(end);
                if (end.charAt(1) === "=") {
                    pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
                    if (pt || pt === 0) end = pt;
                }
            }
            if (!optional || parsedStart !== end || _forceAllPropTweens) {
                if (!isNaN(parsedStart * end) && end !== "") {
                    pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
                    funcParam && (pt.fp = funcParam);
                    modifier && pt.modifier(modifier, this, target);
                    return this._pt = pt;
                }
                !currentValue && !(prop in target) && _missingPlugin(prop, end);
                return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
            }
        }, _processVars = function _processVars(vars, index, target, targets, tween) {
            _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
            if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
            var p, copy = {};
            for (p in vars) copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
            return copy;
        }, _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
            var plugin, pt, ptLookup, i;
            if (_plugins[property] && (plugin = new _plugins[property]).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
                tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
                if (tween !== _quickTween) {
                    ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
                    i = plugin._props.length;
                    while (i--) ptLookup[plugin._props[i]] = pt;
                }
            }
            return plugin;
        }, _initTween = function _initTween(tween, time, tTime) {
            var cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten, vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline;
            tl && (!keyframes || !ease) && (ease = "none");
            tween._ease = _parseEase(ease, _defaults.ease);
            tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
            if (yoyoEase && tween._yoyo && !tween._repeat) {
                yoyoEase = tween._yEase;
                tween._yEase = tween._ease;
                tween._ease = yoyoEase;
            }
            tween._from = !tl && !!vars.runBackwards;
            if (!tl || keyframes && !vars.stagger) {
                harness = targets[0] ? _getCache(targets[0]).harness : 0;
                harnessVars = harness && vars[harness.prop];
                cleanVars = _copyExcluding(vars, _reservedProps);
                if (prevStartAt) {
                    prevStartAt._zTime < 0 && prevStartAt.progress(1);
                    time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
                    prevStartAt._lazy = 0;
                }
                if (startAt) {
                    _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
                        data: "isStart",
                        overwrite: false,
                        parent,
                        immediateRender: true,
                        lazy: !prevStartAt && _isNotFalse(lazy),
                        startAt: null,
                        delay: 0,
                        onUpdate,
                        onUpdateParams,
                        callbackScope,
                        stagger: 0
                    }, startAt)));
                    tween._startAt._dp = 0;
                    tween._startAt._sat = tween;
                    time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
                    if (immediateRender) if (dur && time <= 0 && tTime <= 0) {
                        time && (tween._zTime = time);
                        return;
                    }
                } else if (runBackwards && dur) if (!prevStartAt) {
                    time && (immediateRender = false);
                    p = _setDefaults({
                        overwrite: false,
                        data: "isFromStart",
                        lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
                        immediateRender,
                        stagger: 0,
                        parent
                    }, cleanVars);
                    harnessVars && (p[harness.prop] = harnessVars);
                    _removeFromParent(tween._startAt = Tween.set(targets, p));
                    tween._startAt._dp = 0;
                    tween._startAt._sat = tween;
                    time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
                    tween._zTime = time;
                    if (!immediateRender) _initTween(tween._startAt, _tinyNum, _tinyNum); else if (!time) return;
                }
                tween._pt = tween._ptCache = 0;
                lazy = dur && _isNotFalse(lazy) || lazy && !dur;
                for (i = 0; i < targets.length; i++) {
                    target = targets[i];
                    gsData = target._gsap || _harness(targets)[i]._gsap;
                    tween._ptLookup[i] = ptLookup = {};
                    _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
                    index = fullTargets === targets ? i : fullTargets.indexOf(target);
                    if (harness && (plugin = new harness).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
                        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
                        plugin._props.forEach((function(name) {
                            ptLookup[name] = pt;
                        }));
                        plugin.priority && (hasPriority = 1);
                    }
                    if (!harness || harnessVars) for (p in cleanVars) if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) plugin.priority && (hasPriority = 1); else ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
                    tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
                    if (autoOverwrite && tween._pt) {
                        _overwritingTween = tween;
                        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
                        overwritten = !tween.parent;
                        _overwritingTween = 0;
                    }
                    tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
                }
                hasPriority && _sortPropTweensByPriority(tween);
                tween._onInit && tween._onInit(tween);
            }
            tween._onUpdate = onUpdate;
            tween._initted = (!tween._op || tween._pt) && !overwritten;
            keyframes && time <= 0 && tl.render(_bigNum, true, true);
        }, _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
            var pt, rootPT, lookup, i, ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property];
            if (!ptCache) {
                ptCache = tween._ptCache[property] = [];
                lookup = tween._ptLookup;
                i = tween._targets.length;
                while (i--) {
                    pt = lookup[i][property];
                    if (pt && pt.d && pt.d._pt) {
                        pt = pt.d._pt;
                        while (pt && pt.p !== property && pt.fp !== property) pt = pt._next;
                    }
                    if (!pt) {
                        _forceAllPropTweens = 1;
                        tween.vars[property] = "+=0";
                        _initTween(tween, time);
                        _forceAllPropTweens = 0;
                        return 1;
                    }
                    ptCache.push(pt);
                }
            }
            i = ptCache.length;
            while (i--) {
                rootPT = ptCache[i];
                pt = rootPT._pt || rootPT;
                pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
                pt.c = value - pt.s;
                rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
                rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
            }
        }, _addAliasesToVars = function _addAliasesToVars(targets, vars) {
            var copy, p, i, aliases, harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases;
            if (!propertyAliases) return vars;
            copy = _merge({}, vars);
            for (p in propertyAliases) if (p in copy) {
                aliases = propertyAliases[p].split(",");
                i = aliases.length;
                while (i--) copy[aliases[i]] = copy[p];
            }
            return copy;
        }, _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
            var p, a, ease = obj.ease || easeEach || "power1.inOut";
            if (_isArray(obj)) {
                a = allProps[prop] || (allProps[prop] = []);
                obj.forEach((function(value, i) {
                    return a.push({
                        t: i / (obj.length - 1) * 100,
                        v: value,
                        e: ease
                    });
                }));
            } else for (p in obj) {
                a = allProps[p] || (allProps[p] = []);
                p === "ease" || a.push({
                    t: parseFloat(prop),
                    v: obj[p],
                    e: ease
                });
            }
        }, _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
            return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
        }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
        _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", (function(name) {
            return _staggerPropsToSkip[name] = 1;
        }));
        var Tween = function(_Animation2) {
            _inheritsLoose(Tween, _Animation2);
            function Tween(targets, vars, position, skipInherit) {
                var _this3;
                if (typeof vars === "number") {
                    position.duration = vars;
                    vars = position;
                    position = null;
                }
                _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
                var tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge, _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [ targets ] : toArray(targets);
                _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
                _this3._ptLookup = [];
                _this3._overwrite = overwrite;
                if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                    vars = _this3.vars;
                    tl = _this3.timeline = new Timeline({
                        data: "nested",
                        defaults: defaults || {},
                        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
                    });
                    tl.kill();
                    tl.parent = tl._dp = _assertThisInitialized(_this3);
                    tl._start = 0;
                    if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                        l = parsedTargets.length;
                        staggerFunc = stagger && distribute(stagger);
                        if (_isObject(stagger)) for (p in stagger) if (~_staggerTweenProps.indexOf(p)) {
                            staggerVarsToMerge || (staggerVarsToMerge = {});
                            staggerVarsToMerge[p] = stagger[p];
                        }
                        for (i = 0; i < l; i++) {
                            copy = _copyExcluding(vars, _staggerPropsToSkip);
                            copy.stagger = 0;
                            yoyoEase && (copy.yoyoEase = yoyoEase);
                            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                            curTarget = parsedTargets[i];
                            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
                            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
                            if (!stagger && l === 1 && copy.delay) {
                                _this3._delay = delay = copy.delay;
                                _this3._start += delay;
                                copy.delay = 0;
                            }
                            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
                            tl._ease = _easeMap.none;
                        }
                        tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
                    } else if (keyframes) {
                        _inheritDefaults(_setDefaults(tl.vars.defaults, {
                            ease: "none"
                        }));
                        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
                        var a, kf, v, time = 0;
                        if (_isArray(keyframes)) {
                            keyframes.forEach((function(frame) {
                                return tl.to(parsedTargets, frame, ">");
                            }));
                            tl.duration();
                        } else {
                            copy = {};
                            for (p in keyframes) p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
                            for (p in copy) {
                                a = copy[p].sort((function(a, b) {
                                    return a.t - b.t;
                                }));
                                time = 0;
                                for (i = 0; i < a.length; i++) {
                                    kf = a[i];
                                    v = {
                                        ease: kf.e,
                                        duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                                    };
                                    v[p] = kf.v;
                                    tl.to(parsedTargets, v, time);
                                    time += v.duration;
                                }
                            }
                            tl.duration() < duration && tl.to({}, {
                                duration: duration - tl.duration()
                            });
                        }
                    }
                    duration || _this3.duration(duration = tl.duration());
                } else _this3.timeline = 0;
                if (overwrite === true && !_suppressOverwrites) {
                    _overwritingTween = _assertThisInitialized(_this3);
                    _globalTimeline.killTweensOf(parsedTargets);
                    _overwritingTween = 0;
                }
                _addToTimeline(parent, _assertThisInitialized(_this3), position);
                vars.reversed && _this3.reverse();
                vars.paused && _this3.paused(true);
                if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
                    _this3._tTime = -_tinyNum;
                    _this3.render(Math.max(0, -delay) || 0);
                }
                scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
                return _this3;
            }
            var _proto3 = Tween.prototype;
            _proto3.render = function render(totalTime, suppressEvents, force) {
                var time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase, prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime;
                if (!dur) _renderZeroDurationTween(this, totalTime, suppressEvents, force); else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
                    time = tTime;
                    timeline = this.timeline;
                    if (this._repeat) {
                        cycleDuration = dur + this._rDelay;
                        if (this._repeat < -1 && isNegative) return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
                        time = _roundPrecise(tTime % cycleDuration);
                        if (tTime === tDur) {
                            iteration = this._repeat;
                            time = dur;
                        } else {
                            iteration = ~~(tTime / cycleDuration);
                            if (iteration && iteration === tTime / cycleDuration) {
                                time = dur;
                                iteration--;
                            }
                            time > dur && (time = dur);
                        }
                        isYoyo = this._yoyo && iteration & 1;
                        if (isYoyo) {
                            yoyoEase = this._yEase;
                            time = dur - time;
                        }
                        prevIteration = _animationCycle(this._tTime, cycleDuration);
                        if (time === prevTime && !force && this._initted) {
                            this._tTime = tTime;
                            return this;
                        }
                        if (iteration !== prevIteration) {
                            timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
                            if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                                this._lock = force = 1;
                                this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
                            }
                        }
                    }
                    if (!this._initted) {
                        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
                            this._tTime = 0;
                            return this;
                        }
                        if (prevTime !== this._time) return this;
                        if (dur !== this._dur) return this.render(totalTime, suppressEvents, force);
                    }
                    this._tTime = tTime;
                    this._time = time;
                    if (!this._act && this._ts) {
                        this._act = 1;
                        this._lazy = 0;
                    }
                    this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
                    if (this._from) this.ratio = ratio = 1 - ratio;
                    if (time && !prevTime && !suppressEvents && !iteration) {
                        _callback(this, "onStart");
                        if (this._tTime !== tTime) return this;
                    }
                    pt = this._pt;
                    while (pt) {
                        pt.r(ratio, pt.d);
                        pt = pt._next;
                    }
                    timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
                    if (this._onUpdate && !suppressEvents) {
                        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
                        _callback(this, "onUpdate");
                    }
                    this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
                    if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
                        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
                        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
                            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                        }
                    }
                }
                return this;
            };
            _proto3.targets = function targets() {
                return this._targets;
            };
            _proto3.invalidate = function invalidate(soft) {
                (!soft || !this.vars.runBackwards) && (this._startAt = 0);
                this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
                this._ptLookup = [];
                this.timeline && this.timeline.invalidate(soft);
                return _Animation2.prototype.invalidate.call(this, soft);
            };
            _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
                _tickerActive || _ticker.wake();
                this._ts || this.play();
                var ratio, time = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                this._initted || _initTween(this, time);
                ratio = this._ease(time / this._dur);
                if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) return this.resetTo(property, value, start, startIsRelative);
                _alignPlayhead(this, 0);
                this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
                return this.render(0);
            };
            _proto3.kill = function kill(targets, vars) {
                if (vars === void 0) vars = "all";
                if (!targets && (!vars || vars === "all")) {
                    this._lazy = this._pt = 0;
                    return this.parent ? _interrupt(this) : this;
                }
                if (this.timeline) {
                    var tDur = this.timeline.totalDuration();
                    this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
                    this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
                    return this;
                }
                var overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i, parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt;
                if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
                    vars === "all" && (this._pt = 0);
                    return _interrupt(this);
                }
                overwrittenProps = this._op = this._op || [];
                if (vars !== "all") {
                    if (_isString(vars)) {
                        p = {};
                        _forEachName(vars, (function(name) {
                            return p[name] = 1;
                        }));
                        vars = p;
                    }
                    vars = _addAliasesToVars(parsedTargets, vars);
                }
                i = parsedTargets.length;
                while (i--) if (~killingTargets.indexOf(parsedTargets[i])) {
                    curLookup = propTweenLookup[i];
                    if (vars === "all") {
                        overwrittenProps[i] = vars;
                        props = curLookup;
                        curOverwriteProps = {};
                    } else {
                        curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
                        props = vars;
                    }
                    for (p in props) {
                        pt = curLookup && curLookup[p];
                        if (pt) {
                            if (!("kill" in pt.d) || pt.d.kill(p) === true) _removeLinkedListItem(this, pt, "_pt");
                            delete curLookup[p];
                        }
                        if (curOverwriteProps !== "all") curOverwriteProps[p] = 1;
                    }
                }
                this._initted && !this._pt && firstPT && _interrupt(this);
                return this;
            };
            Tween.to = function to(targets, vars) {
                return new Tween(targets, vars, arguments[2]);
            };
            Tween.from = function from(targets, vars) {
                return _createTweenType(1, arguments);
            };
            Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
                return new Tween(callback, 0, {
                    immediateRender: false,
                    lazy: false,
                    overwrite: false,
                    delay,
                    onComplete: callback,
                    onReverseComplete: callback,
                    onCompleteParams: params,
                    onReverseCompleteParams: params,
                    callbackScope: scope
                });
            };
            Tween.fromTo = function fromTo(targets, fromVars, toVars) {
                return _createTweenType(2, arguments);
            };
            Tween.set = function set(targets, vars) {
                vars.duration = 0;
                vars.repeatDelay || (vars.repeat = 0);
                return new Tween(targets, vars);
            };
            Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                return _globalTimeline.killTweensOf(targets, props, onlyActive);
            };
            return Tween;
        }(Animation);
        _setDefaults(Tween.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        });
        _forEachName("staggerTo,staggerFrom,staggerFromTo", (function(name) {
            Tween[name] = function() {
                var tl = new Timeline, params = _slice.call(arguments, 0);
                params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
                return tl[name].apply(tl, params);
            };
        }));
        var _setterPlain = function _setterPlain(target, property, value) {
            return target[property] = value;
        }, _setterFunc = function _setterFunc(target, property, value) {
            return target[property](value);
        }, _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
            return target[property](data.fp, value);
        }, _setterAttribute = function _setterAttribute(target, property, value) {
            return target.setAttribute(property, value);
        }, _getSetter = function _getSetter(target, property) {
            return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
        }, _renderPlain = function _renderPlain(ratio, data) {
            return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
        }, _renderBoolean = function _renderBoolean(ratio, data) {
            return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
        }, _renderComplexString = function _renderComplexString(ratio, data) {
            var pt = data._pt, s = "";
            if (!ratio && data.b) s = data.b; else if (ratio === 1 && data.e) s = data.e; else {
                while (pt) {
                    s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
                    pt = pt._next;
                }
                s += data.c;
            }
            data.set(data.t, data.p, s, data);
        }, _renderPropTweens = function _renderPropTweens(ratio, data) {
            var pt = data._pt;
            while (pt) {
                pt.r(ratio, pt.d);
                pt = pt._next;
            }
        }, _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
            var next, pt = this._pt;
            while (pt) {
                next = pt._next;
                pt.p === property && pt.modifier(modifier, tween, target);
                pt = next;
            }
        }, _killPropTweensOf = function _killPropTweensOf(property) {
            var hasNonDependentRemaining, next, pt = this._pt;
            while (pt) {
                next = pt._next;
                if (pt.p === property && !pt.op || pt.op === property) _removeLinkedListItem(this, pt, "_pt"); else if (!pt.dep) hasNonDependentRemaining = 1;
                pt = next;
            }
            return !hasNonDependentRemaining;
        }, _setterWithModifier = function _setterWithModifier(target, property, value, data) {
            data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
        }, _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
            var next, pt2, first, last, pt = parent._pt;
            while (pt) {
                next = pt._next;
                pt2 = first;
                while (pt2 && pt2.pr > pt.pr) pt2 = pt2._next;
                if (pt._prev = pt2 ? pt2._prev : last) pt._prev._next = pt; else first = pt;
                if (pt._next = pt2) pt2._prev = pt; else last = pt;
                pt = next;
            }
            parent._pt = first;
        };
        var PropTween = function() {
            function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
                this.t = target;
                this.s = start;
                this.c = change;
                this.p = prop;
                this.r = renderer || _renderPlain;
                this.d = data || this;
                this.set = setter || _setterPlain;
                this.pr = priority || 0;
                this._next = next;
                if (next) next._prev = this;
            }
            var _proto4 = PropTween.prototype;
            _proto4.modifier = function modifier(func, tween, target) {
                this.mSet = this.mSet || this.set;
                this.set = _setterWithModifier;
                this.m = func;
                this.mt = target;
                this.tween = tween;
            };
            return PropTween;
        }();
        _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(name) {
            return _reservedProps[name] = 1;
        }));
        _globals.TweenMax = _globals.TweenLite = Tween;
        _globals.TimelineLite = _globals.TimelineMax = Timeline;
        _globalTimeline = new Timeline({
            sortChildren: false,
            defaults: _defaults,
            autoRemoveChildren: true,
            id: "root",
            smoothChildTiming: true
        });
        _config.stringFilter = _colorStringFilter;
        var _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch(type) {
            return (_listeners[type] || _emptyArray).map((function(f) {
                return f();
            }));
        }, _onMediaChange = function _onMediaChange() {
            var time = Date.now(), matches = [];
            if (time - _lastMediaTime > 2) {
                _dispatch("matchMediaInit");
                _media.forEach((function(c) {
                    var match, p, anyMatch, toggled, queries = c.queries, conditions = c.conditions;
                    for (p in queries) {
                        match = _win.matchMedia(queries[p]).matches;
                        match && (anyMatch = 1);
                        if (match !== conditions[p]) {
                            conditions[p] = match;
                            toggled = 1;
                        }
                    }
                    if (toggled) {
                        c.revert();
                        anyMatch && matches.push(c);
                    }
                }));
                _dispatch("matchMediaRevert");
                matches.forEach((function(c) {
                    return c.onMatch(c);
                }));
                _lastMediaTime = time;
                _dispatch("matchMedia");
            }
        };
        var Context = function() {
            function Context(func, scope) {
                this.selector = scope && selector(scope);
                this.data = [];
                this._r = [];
                this.isReverted = false;
                this.id = _contextID++;
                func && this.add(func);
            }
            var _proto5 = Context.prototype;
            _proto5.add = function add(name, func, scope) {
                if (_isFunction(name)) {
                    scope = func;
                    func = name;
                    name = _isFunction;
                }
                var self = this, f = function f() {
                    var result, prev = _context, prevSelector = self.selector;
                    prev && prev !== self && prev.data.push(self);
                    scope && (self.selector = selector(scope));
                    _context = self;
                    result = func.apply(self, arguments);
                    _isFunction(result) && self._r.push(result);
                    _context = prev;
                    self.selector = prevSelector;
                    self.isReverted = false;
                    return result;
                };
                self.last = f;
                return name === _isFunction ? f(self) : name ? self[name] = f : f;
            };
            _proto5.ignore = function ignore(func) {
                var prev = _context;
                _context = null;
                func(this);
                _context = prev;
            };
            _proto5.getTweens = function getTweens() {
                var a = [];
                this.data.forEach((function(e) {
                    return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
                }));
                return a;
            };
            _proto5.clear = function clear() {
                this._r.length = this.data.length = 0;
            };
            _proto5.kill = function kill(revert, matchMedia) {
                var _this4 = this;
                if (revert) {
                    var tweens = this.getTweens();
                    this.data.forEach((function(t) {
                        if (t.data === "isFlip") {
                            t.revert();
                            t.getChildren(true, true, false).forEach((function(tween) {
                                return tweens.splice(tweens.indexOf(tween), 1);
                            }));
                        }
                    }));
                    tweens.map((function(t) {
                        return {
                            g: t.globalTime(0),
                            t
                        };
                    })).sort((function(a, b) {
                        return b.g - a.g || -1;
                    })).forEach((function(o) {
                        return o.t.revert(revert);
                    }));
                    this.data.forEach((function(e) {
                        return e instanceof Timeline ? e.data !== "nested" && e.kill() : !(e instanceof Tween) && e.revert && e.revert(revert);
                    }));
                    this._r.forEach((function(f) {
                        return f(revert, _this4);
                    }));
                    this.isReverted = true;
                } else this.data.forEach((function(e) {
                    return e.kill && e.kill();
                }));
                this.clear();
                if (matchMedia) {
                    var i = _media.length;
                    while (i--) _media[i].id === this.id && _media.splice(i, 1);
                }
            };
            _proto5.revert = function revert(config) {
                this.kill(config || {});
            };
            return Context;
        }();
        var MatchMedia = function() {
            function MatchMedia(scope) {
                this.contexts = [];
                this.scope = scope;
            }
            var _proto6 = MatchMedia.prototype;
            _proto6.add = function add(conditions, func, scope) {
                _isObject(conditions) || (conditions = {
                    matches: conditions
                });
                var mq, p, active, context = new Context(0, scope || this.scope), cond = context.conditions = {};
                _context && !context.selector && (context.selector = _context.selector);
                this.contexts.push(context);
                func = context.add("onMatch", func);
                context.queries = conditions;
                for (p in conditions) if (p === "all") active = 1; else {
                    mq = _win.matchMedia(conditions[p]);
                    if (mq) {
                        _media.indexOf(context) < 0 && _media.push(context);
                        (cond[p] = mq.matches) && (active = 1);
                        mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
                    }
                }
                active && func(context);
                return this;
            };
            _proto6.revert = function revert(config) {
                this.kill(config || {});
            };
            _proto6.kill = function kill(revert) {
                this.contexts.forEach((function(c) {
                    return c.kill(revert, true);
                }));
            };
            return MatchMedia;
        }();
        var _gsap = {
            registerPlugin: function registerPlugin() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                args.forEach((function(config) {
                    return _createPlugin(config);
                }));
            },
            timeline: function timeline(vars) {
                return new Timeline(vars);
            },
            getTweensOf: function getTweensOf(targets, onlyActive) {
                return _globalTimeline.getTweensOf(targets, onlyActive);
            },
            getProperty: function getProperty(target, property, unit, uncache) {
                _isString(target) && (target = toArray(target)[0]);
                var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
                unit === "native" && (unit = "");
                return !target ? target : !property ? function(property, unit, uncache) {
                    return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
                } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
            },
            quickSetter: function quickSetter(target, property, unit) {
                target = toArray(target);
                if (target.length > 1) {
                    var setters = target.map((function(t) {
                        return gsap.quickSetter(t, property, unit);
                    })), l = setters.length;
                    return function(value) {
                        var i = l;
                        while (i--) setters[i](value);
                    };
                }
                target = target[0] || {};
                var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
                    var p = new Plugin;
                    _quickTween._pt = 0;
                    p.init(target, unit ? value + unit : value, _quickTween, 0, [ target ]);
                    p.render(1, p);
                    _quickTween._pt && _renderPropTweens(1, _quickTween);
                } : cache.set(target, p);
                return Plugin ? setter : function(value) {
                    return setter(target, p, unit ? value + unit : value, cache, 1);
                };
            },
            quickTo: function quickTo(target, property, vars) {
                var _merge2;
                var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, 
                _merge2), vars || {})), func = function func(value, start, startIsRelative) {
                    return tween.resetTo(property, value, start, startIsRelative);
                };
                func.tween = tween;
                return func;
            },
            isTweening: function isTweening(targets) {
                return _globalTimeline.getTweensOf(targets, true).length > 0;
            },
            defaults: function defaults(value) {
                value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
                return _mergeDeep(_defaults, value || {});
            },
            config: function config(value) {
                return _mergeDeep(_config, value || {});
            },
            registerEffect: function registerEffect(_ref3) {
                var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
                (plugins || "").split(",").forEach((function(pluginName) {
                    return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
                }));
                _effects[name] = function(targets, vars, tl) {
                    return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
                };
                if (extendTimeline) Timeline.prototype[name] = function(targets, vars, position) {
                    return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
                };
            },
            registerEase: function registerEase(name, ease) {
                _easeMap[name] = _parseEase(ease);
            },
            parseEase: function parseEase(ease, defaultEase) {
                return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
            },
            getById: function getById(id) {
                return _globalTimeline.getById(id);
            },
            exportRoot: function exportRoot(vars, includeDelayedCalls) {
                if (vars === void 0) vars = {};
                var child, next, tl = new Timeline(vars);
                tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
                _globalTimeline.remove(tl);
                tl._dp = 0;
                tl._time = tl._tTime = _globalTimeline._time;
                child = _globalTimeline._first;
                while (child) {
                    next = child._next;
                    if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) _addToTimeline(tl, child, child._start - child._delay);
                    child = next;
                }
                _addToTimeline(_globalTimeline, tl, 0);
                return tl;
            },
            context: function context(func, scope) {
                return func ? new Context(func, scope) : _context;
            },
            matchMedia: function matchMedia(scope) {
                return new MatchMedia(scope);
            },
            matchMediaRefresh: function matchMediaRefresh() {
                return _media.forEach((function(c) {
                    var found, p, cond = c.conditions;
                    for (p in cond) if (cond[p]) {
                        cond[p] = false;
                        found = 1;
                    }
                    found && c.revert();
                })) || _onMediaChange();
            },
            addEventListener: function addEventListener(type, callback) {
                var a = _listeners[type] || (_listeners[type] = []);
                ~a.indexOf(callback) || a.push(callback);
            },
            removeEventListener: function removeEventListener(type, callback) {
                var a = _listeners[type], i = a && a.indexOf(callback);
                i >= 0 && a.splice(i, 1);
            },
            utils: {
                wrap,
                wrapYoyo,
                distribute,
                random,
                snap,
                normalize,
                getUnit,
                clamp,
                splitColor,
                toArray,
                selector,
                mapRange,
                pipe,
                unitize,
                interpolate,
                shuffle
            },
            install: _install,
            effects: _effects,
            ticker: _ticker,
            updateRoot: Timeline.updateRoot,
            plugins: _plugins,
            globalTimeline: _globalTimeline,
            core: {
                PropTween,
                globals: _addGlobal,
                Tween,
                Timeline,
                Animation,
                getCache: _getCache,
                _removeLinkedListItem,
                reverting: function reverting() {
                    return _reverting;
                },
                context: function context(toAdd) {
                    if (toAdd && _context) {
                        _context.data.push(toAdd);
                        toAdd._ctx = _context;
                    }
                    return _context;
                },
                suppressOverwrites: function suppressOverwrites(value) {
                    return _suppressOverwrites = value;
                }
            }
        };
        _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", (function(name) {
            return _gsap[name] = Tween[name];
        }));
        _ticker.add(Timeline.updateRoot);
        _quickTween = _gsap.to({}, {
            duration: 0
        });
        var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
            var pt = plugin._pt;
            while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) pt = pt._next;
            return pt;
        }, _addModifiers = function _addModifiers(tween, modifiers) {
            var p, i, pt, targets = tween._targets;
            for (p in modifiers) {
                i = targets.length;
                while (i--) {
                    pt = tween._ptLookup[i][p];
                    if (pt && (pt = pt.d)) {
                        if (pt._pt) pt = _getPluginPropTween(pt, p);
                        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
                    }
                }
            }
        }, _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
            return {
                name,
                rawVars: 1,
                init: function init(target, vars, tween) {
                    tween._onInit = function(tween) {
                        var temp, p;
                        if (_isString(vars)) {
                            temp = {};
                            _forEachName(vars, (function(name) {
                                return temp[name] = 1;
                            }));
                            vars = temp;
                        }
                        if (modifier) {
                            temp = {};
                            for (p in vars) temp[p] = modifier(vars[p]);
                            vars = temp;
                        }
                        _addModifiers(tween, vars);
                    };
                }
            };
        };
        var gsap = _gsap.registerPlugin({
            name: "attr",
            init: function init(target, vars, tween, index, targets) {
                var p, pt, v;
                this.tween = tween;
                for (p in vars) {
                    v = target.getAttribute(p) || "";
                    pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
                    pt.op = p;
                    pt.b = v;
                    this._props.push(p);
                }
            },
            render: function render(ratio, data) {
                var pt = data._pt;
                while (pt) {
                    _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
                    pt = pt._next;
                }
            }
        }, {
            name: "endArray",
            init: function init(target, value) {
                var i = value.length;
                while (i--) this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
            }
        }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
        Tween.version = Timeline.version = gsap.version = "3.12.0";
        _coreReady = 1;
        _windowExists() && _wake();
        _easeMap.Power0, _easeMap.Power1, _easeMap.Power2, _easeMap.Power3, _easeMap.Power4, 
        _easeMap.Linear, _easeMap.Quad, _easeMap.Cubic, _easeMap.Quart, _easeMap.Quint, 
        _easeMap.Strong, _easeMap.Elastic, _easeMap.Back, _easeMap.SteppedEase, _easeMap.Bounce, 
        _easeMap.Sine, _easeMap.Expo, _easeMap.Circ;
        /*!
 * CSSPlugin 3.12.0
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var CSSPlugin_win, CSSPlugin_doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, CSSPlugin_reverting, _supports3D, CSSPlugin_windowExists = function _windowExists() {
            return typeof window !== "undefined";
        }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, CSSPlugin_bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, _renderCSSProp = function _renderCSSProp(ratio, data) {
            return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
        }, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
            return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
        }, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
            return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
        }, _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
            var value = data.s + data.c * ratio;
            data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
        }, _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
            return data.set(data.t, data.p, ratio ? data.e : data.b, data);
        }, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
            return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
        }, _setterCSSStyle = function _setterCSSStyle(target, property, value) {
            return target.style[property] = value;
        }, _setterCSSProp = function _setterCSSProp(target, property, value) {
            return target.style.setProperty(property, value);
        }, _setterTransform = function _setterTransform(target, property, value) {
            return target._gsap[property] = value;
        }, _setterScale = function _setterScale(target, property, value) {
            return target._gsap.scaleX = target._gsap.scaleY = value;
        }, _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
            var cache = target._gsap;
            cache.scaleX = cache.scaleY = value;
            cache.renderTransform(ratio, cache);
        }, _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
            var cache = target._gsap;
            cache[property] = value;
            cache.renderTransform(ratio, cache);
        }, _transformProp = "transform", _transformOriginProp = _transformProp + "Origin", _saveStyle = function _saveStyle(property, isNotCSS) {
            var _this = this;
            var target = this.target, style = target.style;
            if (property in _transformProps && style) {
                this.tfm = this.tfm || {};
                if (property !== "transform") {
                    property = _propertyAliases[property] || property;
                    ~property.indexOf(",") ? property.split(",").forEach((function(a) {
                        return _this.tfm[a] = _get(target, a);
                    })) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
                } else return _propertyAliases.transform.split(",").forEach((function(p) {
                    return _saveStyle.call(_this, p, isNotCSS);
                }));
                if (this.props.indexOf(_transformProp) >= 0) return;
                if (target._gsap.svg) {
                    this.svgo = target.getAttribute("data-svg-origin");
                    this.props.push(_transformOriginProp, isNotCSS, "");
                }
                property = _transformProp;
            }
            (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
        }, _removeIndependentTransforms = function _removeIndependentTransforms(style) {
            if (style.translate) {
                style.removeProperty("translate");
                style.removeProperty("scale");
                style.removeProperty("rotate");
            }
        }, _revertStyle = function _revertStyle() {
            var i, p, props = this.props, target = this.target, style = target.style, cache = target._gsap;
            for (i = 0; i < props.length; i += 3) props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
            if (this.tfm) {
                for (p in this.tfm) cache[p] = this.tfm[p];
                if (cache.svg) {
                    cache.renderTransform();
                    target.setAttribute("data-svg-origin", this.svgo || "");
                }
                i = CSSPlugin_reverting();
                if ((!i || !i.isStart) && !style[_transformProp]) {
                    _removeIndependentTransforms(style);
                    cache.uncache = 1;
                }
            }
        }, _getStyleSaver = function _getStyleSaver(target, properties) {
            var saver = {
                target,
                props: [],
                revert: _revertStyle,
                save: _saveStyle
            };
            target._gsap || gsap.core.getCache(target);
            properties && properties.split(",").forEach((function(p) {
                return saver.save(p);
            }));
            return saver;
        }, _createElement = function _createElement(type, ns) {
            var e = CSSPlugin_doc.createElementNS ? CSSPlugin_doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : CSSPlugin_doc.createElement(type);
            return e.style ? e : CSSPlugin_doc.createElement(type);
        }, _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
            var cs = getComputedStyle(target);
            return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || "";
        }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
            var e = element || _tempDiv, s = e.style, i = 5;
            if (property in s && !preferPrefix) return property;
            property = property.charAt(0).toUpperCase() + property.substr(1);
            while (i-- && !(_prefixes[i] + property in s)) ;
            return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
        }, _initCore = function _initCore() {
            if (CSSPlugin_windowExists() && window.document) {
                CSSPlugin_win = window;
                CSSPlugin_doc = CSSPlugin_win.document;
                _docElement = CSSPlugin_doc.documentElement;
                _tempDiv = _createElement("div") || {
                    style: {}
                };
                _createElement("div");
                _transformProp = _checkPropPrefix(_transformProp);
                _transformOriginProp = _transformProp + "Origin";
                _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
                _supports3D = !!_checkPropPrefix("perspective");
                CSSPlugin_reverting = gsap.core.reverting;
                _pluginInitted = 1;
            }
        }, _getBBoxHack = function _getBBoxHack(swapIfPossible) {
            var bbox, svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText;
            _docElement.appendChild(svg);
            svg.appendChild(this);
            this.style.display = "block";
            if (swapIfPossible) try {
                bbox = this.getBBox();
                this._gsapBBox = this.getBBox;
                this.getBBox = _getBBoxHack;
            } catch (e) {} else if (this._gsapBBox) bbox = this._gsapBBox();
            if (oldParent) if (oldSibling) oldParent.insertBefore(this, oldSibling); else oldParent.appendChild(this);
            _docElement.removeChild(svg);
            this.style.cssText = oldCSS;
            return bbox;
        }, _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
            var i = attributesArray.length;
            while (i--) if (target.hasAttribute(attributesArray[i])) return target.getAttribute(attributesArray[i]);
        }, _getBBox = function _getBBox(target) {
            var bounds;
            try {
                bounds = target.getBBox();
            } catch (error) {
                bounds = _getBBoxHack.call(target, true);
            }
            bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
            return bounds && !bounds.width && !bounds.x && !bounds.y ? {
                x: +_getAttributeFallbacks(target, [ "x", "cx", "x1" ]) || 0,
                y: +_getAttributeFallbacks(target, [ "y", "cy", "y1" ]) || 0,
                width: 0,
                height: 0
            } : bounds;
        }, _isSVG = function _isSVG(e) {
            return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
        }, _removeProperty = function _removeProperty(target, property) {
            if (property) {
                var style = target.style;
                if (property in _transformProps && property !== _transformOriginProp) property = _transformProp;
                if (style.removeProperty) {
                    if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") property = "-" + property;
                    style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
                } else style.removeAttribute(property);
            }
        }, _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
            var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
            plugin._pt = pt;
            pt.b = beginning;
            pt.e = end;
            plugin._props.push(property);
            return pt;
        }, _nonConvertibleUnits = {
            deg: 1,
            rad: 1,
            turn: 1
        }, _nonStandardLayouts = {
            grid: 1,
            flex: 1
        }, _convertToUnit = function _convertToUnit(target, property, value, unit) {
            var px, parent, cache, isSVG, curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%";
            if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) return curValue;
            curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
            isSVG = target.getCTM && _isSVG(target);
            if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
                px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
                return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
            }
            style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
            parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
            if (isSVG) parent = (target.ownerSVGElement || {}).parentNode;
            if (!parent || parent === CSSPlugin_doc || !parent.appendChild) parent = CSSPlugin_doc.body;
            cache = parent._gsap;
            if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) return _round(curValue / cache.width * amount); else {
                (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
                parent === target && (style.position = "static");
                parent.appendChild(_tempDiv);
                px = _tempDiv[measureProperty];
                parent.removeChild(_tempDiv);
                style.position = "absolute";
                if (horizontal && toPercent) {
                    cache = _getCache(parent);
                    cache.time = _ticker.time;
                    cache.width = parent[measureProperty];
                }
            }
            return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
        }, _get = function _get(target, property, unit, uncache) {
            var value;
            _pluginInitted || _initCore();
            if (property in _propertyAliases && property !== "transform") {
                property = _propertyAliases[property];
                if (~property.indexOf(",")) property = property.split(",")[0];
            }
            if (_transformProps[property] && property !== "transform") {
                value = _parseTransform(target, uncache);
                value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
            } else {
                value = target.style[property];
                if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
            }
            return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
        }, _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
            if (!start || start === "none") {
                var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
                if (s && s !== start) {
                    prop = p;
                    start = s;
                } else if (prop === "borderColor") start = _getComputedProperty(target, "borderTopColor");
            }
            var a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues, pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0;
            pt.b = start;
            pt.e = end;
            start += "";
            end += "";
            if (end === "auto") {
                target.style[prop] = end;
                end = _getComputedProperty(target, prop) || end;
                target.style[prop] = start;
            }
            a = [ start, end ];
            _colorStringFilter(a);
            start = a[0];
            end = a[1];
            startValues = start.match(_numWithUnitExp) || [];
            endValues = end.match(_numWithUnitExp) || [];
            if (endValues.length) {
                while (result = _numWithUnitExp.exec(end)) {
                    endValue = result[0];
                    chunk = end.substring(index, result.index);
                    if (color) color = (color + 1) % 5; else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") color = 1;
                    if (endValue !== (startValue = startValues[matchIndex++] || "")) {
                        startNum = parseFloat(startValue) || 0;
                        startUnit = startValue.substr((startNum + "").length);
                        endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
                        endNum = parseFloat(endValue);
                        endUnit = endValue.substr((endNum + "").length);
                        index = _numWithUnitExp.lastIndex - endUnit.length;
                        if (!endUnit) {
                            endUnit = endUnit || _config.units[prop] || startUnit;
                            if (index === end.length) {
                                end += endUnit;
                                pt.e += endUnit;
                            }
                        }
                        if (startUnit !== endUnit) startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
                        pt._pt = {
                            _next: pt._pt,
                            p: chunk || matchIndex === 1 ? chunk : ",",
                            s: startNum,
                            c: endNum - startNum,
                            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
                        };
                    }
                }
                pt.c = index < end.length ? end.substring(index, end.length) : "";
            } else pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
            _relExp.test(end) && (pt.e = 0);
            this._pt = pt;
            return pt;
        }, _keywordToPercent = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
            var split = value.split(" "), x = split[0], y = split[1] || "50%";
            if (x === "top" || x === "bottom" || y === "left" || y === "right") {
                value = x;
                x = y;
                y = value;
            }
            split[0] = _keywordToPercent[x] || x;
            split[1] = _keywordToPercent[y] || y;
            return split.join(" ");
        }, _renderClearProps = function _renderClearProps(ratio, data) {
            if (data.tween && data.tween._time === data.tween._dur) {
                var prop, clearTransforms, i, target = data.t, style = target.style, props = data.u, cache = target._gsap;
                if (props === "all" || props === true) {
                    style.cssText = "";
                    clearTransforms = 1;
                } else {
                    props = props.split(",");
                    i = props.length;
                    while (--i > -1) {
                        prop = props[i];
                        if (_transformProps[prop]) {
                            clearTransforms = 1;
                            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
                        }
                        _removeProperty(target, prop);
                    }
                }
                if (clearTransforms) {
                    _removeProperty(target, _transformProp);
                    if (cache) {
                        cache.svg && target.removeAttribute("transform");
                        _parseTransform(target, 1);
                        cache.uncache = 1;
                        _removeIndependentTransforms(style);
                    }
                }
            }
        }, _specialProps = {
            clearProps: function clearProps(plugin, target, property, endValue, tween) {
                if (tween.data !== "isFromStart") {
                    var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
                    pt.u = endValue;
                    pt.pr = -10;
                    pt.tween = tween;
                    plugin._props.push(property);
                    return 1;
                }
            }
        }, _identity2DMatrix = [ 1, 0, 0, 1, 0, 0 ], _rotationalProperties = {}, _isNullTransform = function _isNullTransform(value) {
            return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
        }, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
            var matrixString = _getComputedProperty(target, _transformProp);
            return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
        }, _getMatrix = function _getMatrix(target, force2D) {
            var parent, nextSibling, temp, addedToDOM, cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target);
            if (cache.svg && target.getAttribute("transform")) {
                temp = target.transform.baseVal.consolidate().matrix;
                matrix = [ temp.a, temp.b, temp.c, temp.d, temp.e, temp.f ];
                return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
            } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
                temp = style.display;
                style.display = "block";
                parent = target.parentNode;
                if (!parent || !target.offsetParent) {
                    addedToDOM = 1;
                    nextSibling = target.nextElementSibling;
                    _docElement.appendChild(target);
                }
                matrix = _getComputedTransformMatrixAsArray(target);
                temp ? style.display = temp : _removeProperty(target, "display");
                if (addedToDOM) nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
            }
            return force2D && matrix.length > 6 ? [ matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13] ] : matrix;
        }, _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
            var bounds, determinant, x, y, cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0;
            if (!originIsAbsolute) {
                bounds = _getBBox(target);
                xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
                yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
            } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
                x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
                y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
                xOrigin = x;
                yOrigin = y;
            }
            if (smooth || smooth !== false && cache.smooth) {
                tx = xOrigin - xOriginOld;
                ty = yOrigin - yOriginOld;
                cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
                cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
            } else cache.xOffset = cache.yOffset = 0;
            cache.xOrigin = xOrigin;
            cache.yOrigin = yOrigin;
            cache.smooth = !!smooth;
            cache.origin = origin;
            cache.originIsAbsolute = !!originIsAbsolute;
            target.style[_transformOriginProp] = "0px 0px";
            if (pluginToAddPropTweensTo) {
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
                _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
            }
            target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
        }, _parseTransform = function _parseTransform(target, uncache) {
            var cache = target._gsap || new GSCache(target);
            if ("x" in cache && !uncache && !cache.uncache) return cache;
            var x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32, style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0";
            x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
            scaleX = scaleY = 1;
            cache.svg = !!(target.getCTM && _isSVG(target));
            if (cs.translate) {
                if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
                style.scale = style.rotate = style.translate = "none";
            }
            matrix = _getMatrix(target, cache.svg);
            if (cache.svg) {
                if (cache.uncache) {
                    t2 = target.getBBox();
                    origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
                    t1 = "";
                } else t1 = !uncache && target.getAttribute("data-svg-origin");
                _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
            }
            xOrigin = cache.xOrigin || 0;
            yOrigin = cache.yOrigin || 0;
            if (matrix !== _identity2DMatrix) {
                a = matrix[0];
                b = matrix[1];
                c = matrix[2];
                d = matrix[3];
                x = a12 = matrix[4];
                y = a22 = matrix[5];
                if (matrix.length === 6) {
                    scaleX = Math.sqrt(a * a + b * b);
                    scaleY = Math.sqrt(d * d + c * c);
                    rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
                    skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
                    skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
                    if (cache.svg) {
                        x -= xOrigin - (xOrigin * a + yOrigin * c);
                        y -= yOrigin - (xOrigin * b + yOrigin * d);
                    }
                } else {
                    a32 = matrix[6];
                    a42 = matrix[7];
                    a13 = matrix[8];
                    a23 = matrix[9];
                    a33 = matrix[10];
                    a43 = matrix[11];
                    x = matrix[12];
                    y = matrix[13];
                    z = matrix[14];
                    angle = _atan2(a32, a33);
                    rotationX = angle * _RAD2DEG;
                    if (angle) {
                        cos = Math.cos(-angle);
                        sin = Math.sin(-angle);
                        t1 = a12 * cos + a13 * sin;
                        t2 = a22 * cos + a23 * sin;
                        t3 = a32 * cos + a33 * sin;
                        a13 = a12 * -sin + a13 * cos;
                        a23 = a22 * -sin + a23 * cos;
                        a33 = a32 * -sin + a33 * cos;
                        a43 = a42 * -sin + a43 * cos;
                        a12 = t1;
                        a22 = t2;
                        a32 = t3;
                    }
                    angle = _atan2(-c, a33);
                    rotationY = angle * _RAD2DEG;
                    if (angle) {
                        cos = Math.cos(-angle);
                        sin = Math.sin(-angle);
                        t1 = a * cos - a13 * sin;
                        t2 = b * cos - a23 * sin;
                        t3 = c * cos - a33 * sin;
                        a43 = d * sin + a43 * cos;
                        a = t1;
                        b = t2;
                        c = t3;
                    }
                    angle = _atan2(b, a);
                    rotation = angle * _RAD2DEG;
                    if (angle) {
                        cos = Math.cos(angle);
                        sin = Math.sin(angle);
                        t1 = a * cos + b * sin;
                        t2 = a12 * cos + a22 * sin;
                        b = b * cos - a * sin;
                        a22 = a22 * cos - a12 * sin;
                        a = t1;
                        a12 = t2;
                    }
                    if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
                        rotationX = rotation = 0;
                        rotationY = 180 - rotationY;
                    }
                    scaleX = _round(Math.sqrt(a * a + b * b + c * c));
                    scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
                    angle = _atan2(a12, a22);
                    skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
                    perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
                }
                if (cache.svg) {
                    t1 = target.getAttribute("transform");
                    cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
                    t1 && target.setAttribute("transform", t1);
                }
            }
            if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) if (invertedScaleX) {
                scaleX *= -1;
                skewX += rotation <= 0 ? 180 : -180;
                rotation += rotation <= 0 ? 180 : -180;
            } else {
                scaleY *= -1;
                skewX += skewX <= 0 ? 180 : -180;
            }
            uncache = uncache || cache.uncache;
            cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
            cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
            cache.z = z + px;
            cache.scaleX = _round(scaleX);
            cache.scaleY = _round(scaleY);
            cache.rotation = _round(rotation) + deg;
            cache.rotationX = _round(rotationX) + deg;
            cache.rotationY = _round(rotationY) + deg;
            cache.skewX = skewX + deg;
            cache.skewY = skewY + deg;
            cache.transformPerspective = perspective + px;
            if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) style[_transformOriginProp] = _firstTwoOnly(origin);
            cache.xOffset = cache.yOffset = 0;
            cache.force3D = _config.force3D;
            cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
            cache.uncache = 0;
            return cache;
        }, _firstTwoOnly = function _firstTwoOnly(value) {
            return (value = value.split(" "))[0] + " " + value[1];
        }, _addPxTranslate = function _addPxTranslate(target, start, value) {
            var unit = getUnit(start);
            return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
        }, _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
            cache.z = "0px";
            cache.rotationY = cache.rotationX = "0deg";
            cache.force3D = 0;
            _renderCSSTransforms(ratio, cache);
        }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
            var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
            if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
                var cos, angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle);
                angle = parseFloat(rotationX) * _DEG2RAD;
                cos = Math.cos(angle);
                x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
                y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
                z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
            }
            if (transformPerspective !== _zeroPx) transforms += "perspective(" + transformPerspective + _endParenthesis;
            if (xPercent || yPercent) transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
            if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
            if (rotation !== _zeroDeg) transforms += "rotate(" + rotation + _endParenthesis;
            if (rotationY !== _zeroDeg) transforms += "rotateY(" + rotationY + _endParenthesis;
            if (rotationX !== _zeroDeg) transforms += "rotateX(" + rotationX + _endParenthesis;
            if (skewX !== _zeroDeg || skewY !== _zeroDeg) transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
            if (scaleX !== 1 || scaleY !== 1) transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
            target.style[_transformProp] = transforms || "translate(0, 0)";
        }, _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
            var a11, a21, a12, a22, temp, _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y);
            rotation = parseFloat(rotation);
            skewX = parseFloat(skewX);
            skewY = parseFloat(skewY);
            if (skewY) {
                skewY = parseFloat(skewY);
                skewX += skewY;
                rotation += skewY;
            }
            if (rotation || skewX) {
                rotation *= _DEG2RAD;
                skewX *= _DEG2RAD;
                a11 = Math.cos(rotation) * scaleX;
                a21 = Math.sin(rotation) * scaleX;
                a12 = Math.sin(rotation - skewX) * -scaleY;
                a22 = Math.cos(rotation - skewX) * scaleY;
                if (skewX) {
                    skewY *= _DEG2RAD;
                    temp = Math.tan(skewX - skewY);
                    temp = Math.sqrt(1 + temp * temp);
                    a12 *= temp;
                    a22 *= temp;
                    if (skewY) {
                        temp = Math.tan(skewY);
                        temp = Math.sqrt(1 + temp * temp);
                        a11 *= temp;
                        a21 *= temp;
                    }
                }
                a11 = _round(a11);
                a21 = _round(a21);
                a12 = _round(a12);
                a22 = _round(a22);
            } else {
                a11 = scaleX;
                a22 = scaleY;
                a21 = a12 = 0;
            }
            if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
                tx = _convertToUnit(target, "x", x, "px");
                ty = _convertToUnit(target, "y", y, "px");
            }
            if (xOrigin || yOrigin || xOffset || yOffset) {
                tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
                ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
            }
            if (xPercent || yPercent) {
                temp = target.getBBox();
                tx = _round(tx + xPercent / 100 * temp.width);
                ty = _round(ty + yPercent / 100 * temp.height);
            }
            temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
            target.setAttribute("transform", temp);
            forceCSS && (target.style[_transformProp] = temp);
        }, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
            var direction, pt, cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg";
            if (isString) {
                direction = endValue.split("_")[1];
                if (direction === "short") {
                    change %= cap;
                    if (change !== change % (cap / 2)) change += change < 0 ? cap : -cap;
                }
                if (direction === "cw" && change < 0) change = (change + cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap; else if (direction === "ccw" && change > 0) change = (change - cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;
            }
            plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
            pt.e = finalValue;
            pt.u = "deg";
            plugin._props.push(property);
            return pt;
        }, _assign = function _assign(target, source) {
            for (var p in source) target[p] = source[p];
            return target;
        }, _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
            var endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit, startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style;
            if (startCache.svg) {
                startValue = target.getAttribute("transform");
                target.setAttribute("transform", "");
                style[_transformProp] = transforms;
                endCache = _parseTransform(target, 1);
                _removeProperty(target, _transformProp);
                target.setAttribute("transform", startValue);
            } else {
                startValue = getComputedStyle(target)[_transformProp];
                style[_transformProp] = transforms;
                endCache = _parseTransform(target, 1);
                style[_transformProp] = startValue;
            }
            for (p in _transformProps) {
                startValue = startCache[p];
                endValue = endCache[p];
                if (startValue !== endValue && exclude.indexOf(p) < 0) {
                    startUnit = getUnit(startValue);
                    endUnit = getUnit(endValue);
                    startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
                    endNum = parseFloat(endValue);
                    plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
                    plugin._pt.u = endUnit || 0;
                    plugin._props.push(p);
                }
            }
            _assign(endCache, startCache);
        };
        _forEachName("padding,margin,Width,Radius", (function(name, index) {
            var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [ t, r, b, l ] : [ t + l, t + r, b + r, b + l ]).map((function(side) {
                return index < 2 ? name + side : "border" + side + name;
            }));
            _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
                var a, vars;
                if (arguments.length < 4) {
                    a = props.map((function(prop) {
                        return _get(plugin, prop, property);
                    }));
                    vars = a.join(" ");
                    return vars.split(a[0]).length === 5 ? a[0] : vars;
                }
                a = (endValue + "").split(" ");
                vars = {};
                props.forEach((function(prop, i) {
                    return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
                }));
                plugin.init(target, vars, tween);
            };
        }));
        var CSSPlugin = {
            name: "css",
            register: _initCore,
            targetTest: function targetTest(target) {
                return target.style && target.nodeType;
            },
            init: function init(target, vars, tween, index, targets) {
                var startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps, props = this._props, style = target.style, startAt = tween.vars.startAt;
                _pluginInitted || _initCore();
                this.styles = this.styles || _getStyleSaver(target);
                inlineProps = this.styles.props;
                this.tween = tween;
                for (p in vars) {
                    if (p === "autoRound") continue;
                    endValue = vars[p];
                    if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) continue;
                    type = typeof endValue;
                    specialProp = _specialProps[p];
                    if (type === "function") {
                        endValue = endValue.call(tween, index, target, targets);
                        type = typeof endValue;
                    }
                    if (type === "string" && ~endValue.indexOf("random(")) endValue = _replaceRandom(endValue);
                    if (specialProp) specialProp(this, target, p, endValue, tween) && (hasPriority = 1); else if (p.substr(0, 2) === "--") {
                        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
                        endValue += "";
                        _colorExp.lastIndex = 0;
                        if (!_colorExp.test(startValue)) {
                            startUnit = getUnit(startValue);
                            endUnit = getUnit(endValue);
                        }
                        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
                        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
                        props.push(p);
                        inlineProps.push(p, 0, style[p]);
                    } else if (type !== "undefined") {
                        if (startAt && p in startAt) {
                            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
                            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
                            getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
                            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
                        } else startValue = _get(target, p);
                        startNum = parseFloat(startValue);
                        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
                        relative && (endValue = endValue.substr(2));
                        endNum = parseFloat(endValue);
                        if (p in _propertyAliases) {
                            if (p === "autoAlpha") {
                                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) startNum = 0;
                                inlineProps.push("visibility", 0, style.visibility);
                                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                            }
                            if (p !== "scale" && p !== "transform") {
                                p = _propertyAliases[p];
                                ~p.indexOf(",") && (p = p.split(",")[0]);
                            }
                        }
                        isTransformRelated = p in _transformProps;
                        if (isTransformRelated) {
                            this.styles.save(p);
                            if (!transformPropTween) {
                                cache = target._gsap;
                                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                                smooth = vars.smoothOrigin !== false && cache.smooth;
                                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                                transformPropTween.dep = 1;
                            }
                            if (p === "scale") {
                                this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                                this._pt.u = 0;
                                props.push("scaleY", p);
                                p += "X";
                            } else if (p === "transformOrigin") {
                                inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                                endValue = _convertKeywordsToPercentages(endValue);
                                if (cache.svg) _applySVGOrigin(target, endValue, 0, smooth, 0, this); else {
                                    endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                                    endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                                    _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                                }
                                continue;
                            } else if (p === "svgOrigin") {
                                _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                                continue;
                            } else if (p in _rotationalProperties) {
                                _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
                                continue;
                            } else if (p === "smoothOrigin") {
                                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                                continue;
                            } else if (p === "force3D") {
                                cache[p] = endValue;
                                continue;
                            } else if (p === "transform") {
                                _addRawTransformPTs(this, endValue, target);
                                continue;
                            }
                        } else if (!(p in style)) p = _checkPropPrefix(p) || p;
                        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                            startUnit = (startValue + "").substr((startNum + "").length);
                            endNum || (endNum = 0);
                            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
                            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                            this._pt.u = endUnit || 0;
                            if (startUnit !== endUnit && endUnit !== "%") {
                                this._pt.b = startValue;
                                this._pt.r = _renderCSSPropWithBeginning;
                            }
                        } else if (!(p in style)) {
                            if (p in target) this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets); else if (p !== "parseTransform") {
                                _missingPlugin(p, endValue);
                                continue;
                            }
                        } else _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
                        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
                        props.push(p);
                    }
                }
                hasPriority && _sortPropTweensByPriority(this);
            },
            render: function render(ratio, data) {
                if (data.tween._time || !CSSPlugin_reverting()) {
                    var pt = data._pt;
                    while (pt) {
                        pt.r(ratio, pt.d);
                        pt = pt._next;
                    }
                } else data.styles.revert();
            },
            get: _get,
            aliases: _propertyAliases,
            getSetter: function getSetter(target, property, plugin) {
                var p = _propertyAliases[property];
                p && p.indexOf(",") < 0 && (property = p);
                return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
            },
            core: {
                _removeProperty,
                _getMatrix
            }
        };
        gsap.utils.checkPrefix = _checkPropPrefix;
        gsap.core.getStyleSaver = _getStyleSaver;
        (function(positionAndScale, rotation, others, aliases) {
            var all = _forEachName(positionAndScale + "," + rotation + "," + others, (function(name) {
                _transformProps[name] = 1;
            }));
            _forEachName(rotation, (function(name) {
                _config.units[name] = "deg";
                _rotationalProperties[name] = 1;
            }));
            _propertyAliases[all[13]] = positionAndScale + "," + rotation;
            _forEachName(aliases, (function(name) {
                var split = name.split(":");
                _propertyAliases[split[1]] = all[split[0]];
            }));
        })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
        _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(name) {
            _config.units[name] = "px";
        }));
        gsap.registerPlugin(CSSPlugin);
        var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
        gsapWithCSS.core.Tween;
        /*!
 * paths 3.12.0
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi, _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i, paths_DEG2RAD = Math.PI / 180, paths_RAD2DEG = 180 / Math.PI, paths_sin = Math.sin, paths_cos = Math.cos, _abs = Math.abs, paths_sqrt = Math.sqrt, paths_atan2 = Math.atan2, _largeNum = 1e8, paths_isString = function _isString(value) {
            return typeof value === "string";
        }, paths_isNumber = function _isNumber(value) {
            return typeof value === "number";
        }, paths_isUndefined = function _isUndefined(value) {
            return typeof value === "undefined";
        }, _temp = {}, _temp2 = {}, _roundingNum = 1e5, _wrapProgress = function _wrapProgress(progress) {
            return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);
        }, paths_round = function _round(value) {
            return Math.round(value * _roundingNum) / _roundingNum || 0;
        }, paths_roundPrecise = function _roundPrecise(value) {
            return Math.round(value * 1e10) / 1e10 || 0;
        }, _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {
            var segment = rawPath[segIndex], shift = t === 1 ? 6 : subdivideSegment(segment, i, t);
            if (shift && shift + i + 2 < segment.length) {
                rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));
                segment.splice(0, i + shift);
                return 1;
            }
        }, _getSampleIndex = function _getSampleIndex(samples, length, progress) {
            var l = samples.length, i = ~~(progress * l);
            if (samples[i] > length) {
                while (--i && samples[i] > length) ;
                i < 0 && (i = 0);
            } else while (samples[++i] < length && i < l) ;
            return i < l ? i : l - 1;
        }, _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {
            var i = rawPath.length;
            skipOuter || rawPath.reverse();
            while (i--) rawPath[i].reversed || reverseSegment(rawPath[i]);
        }, _copyMetaData = function _copyMetaData(source, copy) {
            copy.totalLength = source.totalLength;
            if (source.samples) {
                copy.samples = source.samples.slice(0);
                copy.lookup = source.lookup.slice(0);
                copy.minLength = source.minLength;
                copy.resolution = source.resolution;
            } else if (source.totalPoints) copy.totalPoints = source.totalPoints;
            return copy;
        }, _appendOrMerge = function _appendOrMerge(rawPath, segment) {
            var index = rawPath.length, prevSeg = rawPath[index - 1] || [], l = prevSeg.length;
            if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {
                segment = prevSeg.concat(segment.slice(2));
                index--;
            }
            rawPath[index] = segment;
        };
        function getRawPath(value) {
            value = paths_isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
            var rawPath, e = value.getAttribute ? value : 0;
            if (e && (value = value.getAttribute("d"))) {
                if (!e._gsPath) e._gsPath = {};
                rawPath = e._gsPath[value];
                return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
            }
            return !value ? console.warn("Expecting a <path> element or an SVG path data string") : paths_isString(value) ? stringToRawPath(value) : paths_isNumber(value[0]) ? [ value ] : value;
        }
        function copyRawPath(rawPath) {
            var a = [], i = 0;
            for (;i < rawPath.length; i++) a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));
            return _copyMetaData(rawPath, a);
        }
        function reverseSegment(segment) {
            var y, i = 0;
            segment.reverse();
            for (;i < segment.length; i += 2) {
                y = segment[i];
                segment[i] = segment[i + 1];
                segment[i + 1] = y;
            }
            segment.reversed = !segment.reversed;
        }
        var _createPath = function _createPath(e, ignore) {
            var name, path = document.createElementNS("http://www.w3.org/2000/svg", "path"), attr = [].slice.call(e.attributes), i = attr.length;
            ignore = "," + ignore + ",";
            while (--i > -1) {
                name = attr[i].nodeName.toLowerCase();
                if (ignore.indexOf("," + name + ",") < 0) path.setAttributeNS(null, name, attr[i].nodeValue);
            }
            return path;
        }, _typeAttrs = {
            rect: "rx,ry,x,y,width,height",
            circle: "r,cx,cy",
            ellipse: "rx,ry,cx,cy",
            line: "x1,x2,y1,y2"
        }, _attrToObj = function _attrToObj(e, attrs) {
            var props = attrs ? attrs.split(",") : [], obj = {}, i = props.length;
            while (--i > -1) obj[props[i]] = +e.getAttribute(props[i]) || 0;
            return obj;
        };
        function paths_convertToPath(element, swap) {
            var data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr, type = element.tagName.toLowerCase(), circ = .552284749831;
            if (type === "path" || !element.getBBox) return element;
            path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
            attr = _attrToObj(element, _typeAttrs[type]);
            if (type === "rect") {
                r = attr.rx;
                ry = attr.ry || r;
                x = attr.x;
                y = attr.y;
                w = attr.width - r * 2;
                h = attr.height - ry * 2;
                if (r || ry) {
                    x2 = x + r * (1 - circ);
                    x3 = x + r;
                    x4 = x3 + w;
                    x5 = x4 + r * circ;
                    x6 = x4 + r;
                    y2 = y + ry * (1 - circ);
                    y3 = y + ry;
                    y4 = y3 + h;
                    y5 = y4 + ry * circ;
                    y6 = y4 + ry;
                    data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [ x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3 ].join(",") + "z";
                } else data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
            } else if (type === "circle" || type === "ellipse") {
                if (type === "circle") {
                    r = ry = attr.r;
                    rycirc = r * circ;
                } else {
                    r = attr.rx;
                    ry = attr.ry;
                    rycirc = ry * circ;
                }
                x = attr.cx;
                y = attr.cy;
                rcirc = r * circ;
                data = "M" + (x + r) + "," + y + " C" + [ x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y ].join(",") + "z";
            } else if (type === "line") data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; else if (type === "polyline" || type === "polygon") {
                points = (element.getAttribute("points") + "").match(_numbersExp) || [];
                x = points.shift();
                y = points.shift();
                data = "M" + x + "," + y + " L" + points.join(",");
                if (type === "polygon") data += "," + x + "," + y + "z";
            }
            path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));
            if (swap && element.parentNode) {
                element.parentNode.insertBefore(path, element);
                element.parentNode.removeChild(element);
            }
            return path;
        }
        function getRotationAtBezierT(segment, i, t) {
            var x, a = segment[i], b = segment[i + 2], c = segment[i + 4];
            a += (b - a) * t;
            b += (c - b) * t;
            a += (b - a) * t;
            x = b + (c + (segment[i + 6] - c) * t - b) * t - a;
            a = segment[i + 1];
            b = segment[i + 3];
            c = segment[i + 5];
            a += (b - a) * t;
            b += (c - b) * t;
            a += (b - a) * t;
            return paths_round(paths_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * paths_RAD2DEG);
        }
        function sliceRawPath(rawPath, start, end) {
            end = paths_isUndefined(end) ? 1 : paths_roundPrecise(end) || 0;
            start = paths_roundPrecise(start) || 0;
            var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)), path = copyRawPath(rawPath);
            if (start > end) {
                start = 1 - start;
                end = 1 - end;
                _reverseRawPath(path);
                path.totalLength = 0;
            }
            if (start < 0 || end < 0) {
                var offset = Math.abs(~~Math.min(start, end)) + 1;
                start += offset;
                end += offset;
            }
            path.totalLength || cacheRawPathMeasurements(path);
            var wrapsBehind, sShift, eShift, i, copy, totalSegments, l, j, wrap = end > 1, s = getProgressData(path, start, _temp, true), e = getProgressData(path, end, _temp2), eSeg = e.segment, sSeg = s.segment, eSegIndex = e.segIndex, sSegIndex = s.segIndex, ei = e.i, si = s.i, sameSegment = sSegIndex === eSegIndex, sameBezier = ei === si && sameSegment;
            if (wrap || loops) {
                wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;
                if (_splitSegment(path, sSegIndex, si, s.t)) {
                    sSegIndex++;
                    if (!wrapsBehind) {
                        eSegIndex++;
                        if (sameBezier) {
                            e.t = (e.t - s.t) / (1 - s.t);
                            ei = 0;
                        } else if (sameSegment) ei -= si;
                    }
                }
                if (Math.abs(1 - (end - start)) < 1e-5) eSegIndex = sSegIndex - 1; else if (!e.t && eSegIndex) eSegIndex--; else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) sSegIndex++;
                if (s.t === 1) sSegIndex = (sSegIndex + 1) % path.length;
                copy = [];
                totalSegments = path.length;
                l = 1 + totalSegments * loops;
                j = sSegIndex;
                l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;
                for (i = 0; i < l; i++) _appendOrMerge(copy, path[j++ % totalSegments]);
                path = copy;
            } else {
                eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);
                if (start !== end) {
                    sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
                    sameSegment && (eShift += sShift);
                    eSeg.splice(ei + eShift + 2);
                    (sShift || si) && sSeg.splice(0, si + sShift);
                    i = path.length;
                    while (i--) (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);
                } else {
                    eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0);
                    ei += eShift;
                    s = eSeg[ei];
                    e = eSeg[ei + 1];
                    eSeg.length = eSeg.totalLength = 0;
                    eSeg.totalPoints = path.totalPoints = 8;
                    eSeg.push(s, e, s, e, s, e, s, e);
                }
            }
            path.totalLength = 0;
            return path;
        }
        function measureSegment(segment, startIndex, bezierQty) {
            startIndex = startIndex || 0;
            if (!segment.samples) {
                segment.samples = [];
                segment.lookup = [];
            }
            var i, j, x4, x3, x2, xd, xd1, y4, y3, y2, yd, yd1, inv, t, lengthIndex, l, segLength, resolution = ~~segment.resolution || 12, inc = 1 / resolution, endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length, x1 = segment[startIndex], y1 = segment[startIndex + 1], samplesIndex = startIndex ? startIndex / 6 * resolution : 0, samples = segment.samples, lookup = segment.lookup, min = (startIndex ? segment.minLength : _largeNum) || _largeNum, prevLength = samples[samplesIndex + bezierQty * resolution - 1], length = startIndex ? samples[samplesIndex - 1] : 0;
            samples.length = lookup.length = 0;
            for (j = startIndex + 2; j < endIndex; j += 6) {
                x4 = segment[j + 4] - x1;
                x3 = segment[j + 2] - x1;
                x2 = segment[j] - x1;
                y4 = segment[j + 5] - y1;
                y3 = segment[j + 3] - y1;
                y2 = segment[j + 1] - y1;
                xd = xd1 = yd = yd1 = 0;
                if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {
                    if (segment.length > 8) {
                        segment.splice(j, 6);
                        j -= 6;
                        endIndex -= 6;
                    }
                } else for (i = 1; i <= resolution; i++) {
                    t = inc * i;
                    inv = 1 - t;
                    xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
                    yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
                    l = paths_sqrt(yd * yd + xd * xd);
                    if (l < min) min = l;
                    length += l;
                    samples[samplesIndex++] = length;
                }
                x1 += x4;
                y1 += y4;
            }
            if (prevLength) {
                prevLength -= length;
                for (;samplesIndex < samples.length; samplesIndex++) samples[samplesIndex] += prevLength;
            }
            if (samples.length && min) {
                segment.totalLength = segLength = samples[samples.length - 1] || 0;
                segment.minLength = min;
                if (segLength / min < 9999) {
                    l = lengthIndex = 0;
                    for (i = 0; i < segLength; i += min) lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;
                }
            } else segment.totalLength = samples[0] = 0;
            return startIndex ? length - samples[startIndex / 2 - 1] : length;
        }
        function cacheRawPathMeasurements(rawPath, resolution) {
            var pathLength, points, i;
            for (i = pathLength = points = 0; i < rawPath.length; i++) {
                rawPath[i].resolution = ~~resolution || 12;
                points += rawPath[i].length;
                pathLength += measureSegment(rawPath[i]);
            }
            rawPath.totalPoints = points;
            rawPath.totalLength = pathLength;
            return rawPath;
        }
        function subdivideSegment(segment, i, t) {
            if (t <= 0 || t >= 1) return 0;
            var ax = segment[i], ay = segment[i + 1], cp1x = segment[i + 2], cp1y = segment[i + 3], cp2x = segment[i + 4], cp2y = segment[i + 5], bx = segment[i + 6], by = segment[i + 7], x1a = ax + (cp1x - ax) * t, x2 = cp1x + (cp2x - cp1x) * t, y1a = ay + (cp1y - ay) * t, y2 = cp1y + (cp2y - cp1y) * t, x1 = x1a + (x2 - x1a) * t, y1 = y1a + (y2 - y1a) * t, x2a = cp2x + (bx - cp2x) * t, y2a = cp2y + (by - cp2y) * t;
            x2 += (x2a - x2) * t;
            y2 += (y2a - y2) * t;
            segment.splice(i + 2, 4, paths_round(x1a), paths_round(y1a), paths_round(x1), paths_round(y1), paths_round(x1 + (x2 - x1) * t), paths_round(y1 + (y2 - y1) * t), paths_round(x2), paths_round(y2), paths_round(x2a), paths_round(y2a));
            segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);
            return 6;
        }
        function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
            decoratee = decoratee || {};
            rawPath.totalLength || cacheRawPathMeasurements(rawPath);
            if (progress < 0 || progress > 1) progress = _wrapProgress(progress);
            var samples, resolution, length, min, max, i, t, segIndex = 0, segment = rawPath[0];
            if (!progress) {
                t = i = segIndex = 0;
                segment = rawPath[0];
            } else if (progress === 1) {
                t = 1;
                segIndex = rawPath.length - 1;
                segment = rawPath[segIndex];
                i = segment.length - 8;
            } else {
                if (rawPath.length > 1) {
                    length = rawPath.totalLength * progress;
                    max = i = 0;
                    while ((max += rawPath[i++].totalLength) < length) segIndex = i;
                    segment = rawPath[segIndex];
                    min = max - segment.totalLength;
                    progress = (length - min) / (max - min) || 0;
                }
                samples = segment.samples;
                resolution = segment.resolution;
                length = segment.totalLength * progress;
                i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);
                min = i ? samples[i - 1] : 0;
                max = samples[i];
                if (max < length) {
                    min = max;
                    max = samples[++i];
                }
                t = 1 / resolution * ((length - min) / (max - min) + i % resolution);
                i = ~~(i / resolution) * 6;
                if (pushToNextIfAtEnd && t === 1) if (i + 6 < segment.length) {
                    i += 6;
                    t = 0;
                } else if (segIndex + 1 < rawPath.length) {
                    i = t = 0;
                    segment = rawPath[++segIndex];
                }
            }
            decoratee.t = t;
            decoratee.i = i;
            decoratee.path = rawPath;
            decoratee.segment = segment;
            decoratee.segIndex = segIndex;
            return decoratee;
        }
        function getPositionOnPath(rawPath, progress, includeAngle, point) {
            var samples, resolution, length, min, max, i, t, a, inv, segment = rawPath[0], result = point || {};
            if (progress < 0 || progress > 1) progress = _wrapProgress(progress);
            segment.lookup || cacheRawPathMeasurements(rawPath);
            if (rawPath.length > 1) {
                length = rawPath.totalLength * progress;
                max = i = 0;
                while ((max += rawPath[i++].totalLength) < length) segment = rawPath[i];
                min = max - segment.totalLength;
                progress = (length - min) / (max - min) || 0;
            }
            samples = segment.samples;
            resolution = segment.resolution;
            length = segment.totalLength * progress;
            i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);
            min = i ? samples[i - 1] : 0;
            max = samples[i];
            if (max < length) {
                min = max;
                max = samples[++i];
            }
            t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;
            inv = 1 - t;
            i = ~~(i / resolution) * 6;
            a = segment[i];
            result.x = paths_round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);
            result.y = paths_round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);
            if (includeAngle) result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
            return result;
        }
        function transformRawPath(rawPath, a, b, c, d, tx, ty) {
            var segment, l, i, x, y, j = rawPath.length;
            while (--j > -1) {
                segment = rawPath[j];
                l = segment.length;
                for (i = 0; i < l; i += 2) {
                    x = segment[i];
                    y = segment[i + 1];
                    segment[i] = x * a + y * c + tx;
                    segment[i + 1] = x * b + y * d + ty;
                }
            }
            rawPath._dirty = 1;
            return rawPath;
        }
        function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
            if (lastX === x && lastY === y) return;
            rx = _abs(rx);
            ry = _abs(ry);
            var angleRad = angle % 360 * paths_DEG2RAD, cosAngle = paths_cos(angleRad), sinAngle = paths_sin(angleRad), PI = Math.PI, TWOPI = PI * 2, dx2 = (lastX - x) / 2, dy2 = (lastY - y) / 2, x1 = cosAngle * dx2 + sinAngle * dy2, y1 = -sinAngle * dx2 + cosAngle * dy2, x1_sq = x1 * x1, y1_sq = y1 * y1, radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
            if (radiiCheck > 1) {
                rx = paths_sqrt(radiiCheck) * rx;
                ry = paths_sqrt(radiiCheck) * ry;
            }
            var rx_sq = rx * rx, ry_sq = ry * ry, sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
            if (sq < 0) sq = 0;
            var coef = (largeArcFlag === sweepFlag ? -1 : 1) * paths_sqrt(sq), cx1 = coef * (rx * y1 / ry), cy1 = coef * (-ry * x1 / rx), sx2 = (lastX + x) / 2, sy2 = (lastY + y) / 2, cx = sx2 + (cosAngle * cx1 - sinAngle * cy1), cy = sy2 + (sinAngle * cx1 + cosAngle * cy1), ux = (x1 - cx1) / rx, uy = (y1 - cy1) / ry, vx = (-x1 - cx1) / rx, vy = (-y1 - cy1) / ry, temp = ux * ux + uy * uy, angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / paths_sqrt(temp)), angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / paths_sqrt(temp * (vx * vx + vy * vy)));
            isNaN(angleExtent) && (angleExtent = PI);
            if (!sweepFlag && angleExtent > 0) angleExtent -= TWOPI; else if (sweepFlag && angleExtent < 0) angleExtent += TWOPI;
            angleStart %= TWOPI;
            angleExtent %= TWOPI;
            var i, segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)), rawPath = [], angleIncrement = angleExtent / segments, controlLength = 4 / 3 * paths_sin(angleIncrement / 2) / (1 + paths_cos(angleIncrement / 2)), ma = cosAngle * rx, mb = sinAngle * rx, mc = sinAngle * -ry, md = cosAngle * ry;
            for (i = 0; i < segments; i++) {
                angle = angleStart + i * angleIncrement;
                x1 = paths_cos(angle);
                y1 = paths_sin(angle);
                ux = paths_cos(angle += angleIncrement);
                uy = paths_sin(angle);
                rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
            }
            for (i = 0; i < rawPath.length; i += 2) {
                x1 = rawPath[i];
                y1 = rawPath[i + 1];
                rawPath[i] = x1 * ma + y1 * mc + cx;
                rawPath[i + 1] = x1 * mb + y1 * md + cy;
            }
            rawPath[i - 2] = x;
            rawPath[i - 1] = y;
            return rawPath;
        }
        function stringToRawPath(d) {
            var i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2, a = (d + "").replace(_scientific, (function(m) {
                var n = +m;
                return n < 1e-4 && n > -1e-4 ? 0 : n;
            })).match(_svgPathExp) || [], path = [], relativeX = 0, relativeY = 0, twoThirds = 2 / 3, elements = a.length, points = 0, errorMessage = "ERROR: malformed path: " + d, line = function line(sx, sy, ex, ey) {
                difX = (ex - sx) / 3;
                difY = (ey - sy) / 3;
                segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
            };
            if (!d || !isNaN(a[0]) || isNaN(a[1])) {
                console.log(errorMessage);
                return path;
            }
            for (i = 0; i < elements; i++) {
                prevCommand = command;
                if (isNaN(a[i])) {
                    command = a[i].toUpperCase();
                    isRelative = command !== a[i];
                } else i--;
                x = +a[i + 1];
                y = +a[i + 2];
                if (isRelative) {
                    x += relativeX;
                    y += relativeY;
                }
                if (!i) {
                    startX = x;
                    startY = y;
                }
                if (command === "M") {
                    if (segment) if (segment.length < 8) path.length -= 1; else points += segment.length;
                    relativeX = startX = x;
                    relativeY = startY = y;
                    segment = [ x, y ];
                    path.push(segment);
                    i += 2;
                    command = "L";
                } else if (command === "C") {
                    if (!segment) segment = [ 0, 0 ];
                    if (!isRelative) relativeX = relativeY = 0;
                    segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
                    i += 6;
                } else if (command === "S") {
                    difX = relativeX;
                    difY = relativeY;
                    if (prevCommand === "C" || prevCommand === "S") {
                        difX += relativeX - segment[segment.length - 4];
                        difY += relativeY - segment[segment.length - 3];
                    }
                    if (!isRelative) relativeX = relativeY = 0;
                    segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
                    i += 4;
                } else if (command === "Q") {
                    difX = relativeX + (x - relativeX) * twoThirds;
                    difY = relativeY + (y - relativeY) * twoThirds;
                    if (!isRelative) relativeX = relativeY = 0;
                    relativeX += a[i + 3] * 1;
                    relativeY += a[i + 4] * 1;
                    segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
                    i += 4;
                } else if (command === "T") {
                    difX = relativeX - segment[segment.length - 4];
                    difY = relativeY - segment[segment.length - 3];
                    segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
                    i += 2;
                } else if (command === "H") {
                    line(relativeX, relativeY, relativeX = x, relativeY);
                    i += 1;
                } else if (command === "V") {
                    line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
                    i += 1;
                } else if (command === "L" || command === "Z") {
                    if (command === "Z") {
                        x = startX;
                        y = startY;
                        segment.closed = true;
                    }
                    if (command === "L" || _abs(relativeX - x) > .5 || _abs(relativeY - y) > .5) {
                        line(relativeX, relativeY, x, y);
                        if (command === "L") i += 2;
                    }
                    relativeX = x;
                    relativeY = y;
                } else if (command === "A") {
                    flag1 = a[i + 4];
                    flag2 = a[i + 5];
                    difX = a[i + 6];
                    difY = a[i + 7];
                    j = 7;
                    if (flag1.length > 1) {
                        if (flag1.length < 3) {
                            difY = difX;
                            difX = flag2;
                            j--;
                        } else {
                            difY = flag2;
                            difX = flag1.substr(2);
                            j -= 2;
                        }
                        flag2 = flag1.charAt(1);
                        flag1 = flag1.charAt(0);
                    }
                    beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
                    i += j;
                    if (beziers) for (j = 0; j < beziers.length; j++) segment.push(beziers[j]);
                    relativeX = segment[segment.length - 2];
                    relativeY = segment[segment.length - 1];
                } else console.log(errorMessage);
            }
            i = segment.length;
            if (i < 6) {
                path.pop();
                i = 0;
            } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) segment.closed = true;
            path.totalPoints = points + i;
            return path;
        }
        function flatPointsToSegment(points, curviness) {
            if (curviness === void 0) curviness = 1;
            var x = points[0], y = 0, segment = [ x, y ], i = 2;
            for (;i < points.length; i += 2) segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);
            return segment;
        }
        function pointsToSegment(points, curviness) {
            _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2));
            var prevX, prevY, i, dx1, dy1, r1, r2, r3, tl, mx1, mx2, mxm, my1, my2, mym, l = points.length - 2, x = +points[0], y = +points[1], nextX = +points[2], nextY = +points[3], segment = [ x, y, x, y ], dx2 = nextX - x, dy2 = nextY - y, closed = Math.abs(points[l] - x) < .001 && Math.abs(points[l + 1] - y) < .001;
            if (closed) {
                points.push(nextX, nextY);
                nextX = x;
                nextY = y;
                x = points[l - 2];
                y = points[l - 1];
                points.unshift(x, y);
                l += 4;
            }
            curviness = curviness || curviness === 0 ? +curviness : 1;
            for (i = 2; i < l; i += 2) {
                prevX = x;
                prevY = y;
                x = nextX;
                y = nextY;
                nextX = +points[i + 2];
                nextY = +points[i + 3];
                if (x === nextX && y === nextY) continue;
                dx1 = dx2;
                dy1 = dy2;
                dx2 = nextX - x;
                dy2 = nextY - y;
                r1 = paths_sqrt(dx1 * dx1 + dy1 * dy1);
                r2 = paths_sqrt(dx2 * dx2 + dy2 * dy2);
                r3 = paths_sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));
                tl = (r1 + r2) * curviness * .25 / r3;
                mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);
                mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);
                mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + .5) / 4 || 0));
                my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);
                my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);
                mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + .5) / 4 || 0));
                if (x !== prevX || y !== prevY) segment.push(paths_round(mx1 + mxm), paths_round(my1 + mym), paths_round(x), paths_round(y), paths_round(mx2 + mxm), paths_round(my2 + mym));
            }
            x !== nextX || y !== nextY || segment.length < 4 ? segment.push(paths_round(nextX), paths_round(nextY), paths_round(nextX), paths_round(nextY)) : segment.length -= 2;
            if (segment.length === 2) segment.push(x, y, x, y, x, y); else if (closed) {
                segment.splice(0, 6);
                segment.length = segment.length - 6;
            }
            return segment;
        }
        function rawPathToString(rawPath) {
            if (paths_isNumber(rawPath[0])) rawPath = [ rawPath ];
            var sl, s, i, segment, result = "", l = rawPath.length;
            for (s = 0; s < l; s++) {
                segment = rawPath[s];
                result += "M" + paths_round(segment[0]) + "," + paths_round(segment[1]) + " C";
                sl = segment.length;
                for (i = 2; i < sl; i++) result += paths_round(segment[i++]) + "," + paths_round(segment[i++]) + " " + paths_round(segment[i++]) + "," + paths_round(segment[i++]) + " " + paths_round(segment[i++]) + "," + paths_round(segment[i]) + " ";
                if (segment.closed) result += "z";
            }
            return result;
        }
        /*!
 * CustomEase 3.12.0
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var CustomEase_gsap, CustomEase_coreInitted, _getGSAP = function _getGSAP() {
            return CustomEase_gsap || typeof window !== "undefined" && (CustomEase_gsap = window.gsap) && CustomEase_gsap.registerPlugin && CustomEase_gsap;
        }, CustomEase_initCore = function _initCore() {
            CustomEase_gsap = _getGSAP();
            if (CustomEase_gsap) {
                CustomEase_gsap.registerEase("_CE", CustomEase.create);
                CustomEase_coreInitted = 1;
            } else console.warn("Please gsap.registerPlugin(CustomEase)");
        }, CustomEase_bigNum = 1e20, CustomEase_round = function _round(value) {
            return ~~(value * 1e3 + (value < 0 ? -.5 : .5)) / 1e3;
        }, _bonusValidated = 1, CustomEase_numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g, _findMinimum = function _findMinimum(values) {
            var i, l = values.length, min = CustomEase_bigNum;
            for (i = 1; i < l; i += 6) +values[i] < min && (min = +values[i]);
            return min;
        }, _normalize = function _normalize(values, height, originY) {
            if (!originY && originY !== 0) originY = Math.max(+values[values.length - 1], +values[1]);
            var i, tx = +values[0] * -1, ty = -originY, l = values.length, sx = 1 / (+values[l - 2] + tx), sy = -height || (Math.abs(+values[l - 1] - +values[1]) < .01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty);
            if (sy) sy = 1 / sy; else sy = -sx;
            for (i = 0; i < l; i += 2) {
                values[i] = (+values[i] + tx) * sx;
                values[i + 1] = (+values[i + 1] + ty) * sy;
            }
        }, _bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
            var length, x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
            if (!points) {
                points = [ {
                    x: x1,
                    y: y1
                }, {
                    x: x4,
                    y: y4
                } ];
                index = 1;
            }
            points.splice(index || points.length - 1, 0, {
                x: x1234,
                y: y1234
            });
            if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
                length = points.length;
                _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
                _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
            }
            return points;
        };
        var CustomEase = function() {
            function CustomEase(id, data, config) {
                CustomEase_coreInitted || CustomEase_initCore();
                this.id = id;
                _bonusValidated && this.setData(data, config);
            }
            var _proto = CustomEase.prototype;
            _proto.setData = function setData(data, config) {
                config = config || {};
                data = data || "0,0,1,1";
                var l, a1, a2, i, inc, j, point, prevPoint, p, values = data.match(CustomEase_numExp), closest = 1, points = [], lookup = [], precision = config.precision || 1, fast = precision <= 1;
                this.data = data;
                if (_needsParsingExp.test(data) || ~data.indexOf("M") && data.indexOf("C") < 0) values = stringToRawPath(data)[0];
                l = values.length;
                if (l === 4) {
                    values.unshift(0, 0);
                    values.push(1, 1);
                    l = 8;
                } else if ((l - 2) % 6) throw "Invalid CustomEase";
                if (+values[0] !== 0 || +values[l - 2] !== 1) _normalize(values, config.height, config.originY);
                this.segment = values;
                for (i = 2; i < l; i += 6) {
                    a1 = {
                        x: +values[i - 2],
                        y: +values[i - 1]
                    };
                    a2 = {
                        x: +values[i + 4],
                        y: +values[i + 5]
                    };
                    points.push(a1, a2);
                    _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 2e5), points, points.length - 1);
                }
                l = points.length;
                for (i = 0; i < l; i++) {
                    point = points[i];
                    prevPoint = points[i - 1] || point;
                    if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {
                        prevPoint.cx = point.x - prevPoint.x;
                        prevPoint.cy = point.y - prevPoint.y;
                        prevPoint.n = point;
                        prevPoint.nx = point.x;
                        if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) fast = 0;
                        if (prevPoint.cx < closest) if (!prevPoint.cx) {
                            prevPoint.cx = .001;
                            if (i === l - 1) {
                                prevPoint.x -= .001;
                                closest = Math.min(closest, .001);
                                fast = 0;
                            }
                        } else closest = prevPoint.cx;
                    } else {
                        points.splice(i--, 1);
                        l--;
                    }
                }
                l = 1 / closest + 1 | 0;
                inc = 1 / l;
                j = 0;
                point = points[0];
                if (fast) {
                    for (i = 0; i < l; i++) {
                        p = i * inc;
                        if (point.nx < p) point = points[++j];
                        a1 = point.y + (p - point.x) / point.cx * point.cy;
                        lookup[i] = {
                            x: p,
                            cx: inc,
                            y: a1,
                            cy: 0,
                            nx: 9
                        };
                        if (i) lookup[i - 1].cy = a1 - lookup[i - 1].y;
                    }
                    lookup[l - 1].cy = points[points.length - 1].y - a1;
                } else {
                    for (i = 0; i < l; i++) {
                        if (point.nx < i * inc) point = points[++j];
                        lookup[i] = point;
                    }
                    if (j < points.length - 1) lookup[i - 1] = points[points.length - 2];
                }
                this.ease = function(p) {
                    var point = lookup[p * l | 0] || lookup[l - 1];
                    if (point.nx < p) point = point.n;
                    return point.y + (p - point.x) / point.cx * point.cy;
                };
                this.ease.custom = this;
                this.id && CustomEase_gsap && CustomEase_gsap.registerEase(this.id, this.ease);
                return this;
            };
            _proto.getSVGData = function getSVGData(config) {
                return CustomEase.getSVGData(this, config);
            };
            CustomEase.create = function create(id, data, config) {
                return new CustomEase(id, data, config).ease;
            };
            CustomEase.register = function register(core) {
                CustomEase_gsap = core;
                CustomEase_initCore();
            };
            CustomEase.get = function get(id) {
                return CustomEase_gsap.parseEase(id);
            };
            CustomEase.getSVGData = function getSVGData(ease, config) {
                config = config || {};
                var a, slope, i, inc, tx, ty, precision, threshold, prevX, prevY, width = config.width || 100, height = config.height || 100, x = config.x || 0, y = (config.y || 0) + height, e = CustomEase_gsap.utils.toArray(config.path)[0];
                if (config.invert) {
                    height = -height;
                    y = 0;
                }
                if (typeof ease === "string") ease = CustomEase_gsap.parseEase(ease);
                if (ease.custom) ease = ease.custom;
                if (ease instanceof CustomEase) a = rawPathToString(transformRawPath([ ease.segment ], width, 0, 0, -height, x, y)); else {
                    a = [ x, y ];
                    precision = Math.max(5, (config.precision || 1) * 200);
                    inc = 1 / precision;
                    precision += 2;
                    threshold = 5 / precision;
                    prevX = CustomEase_round(x + inc * width);
                    prevY = CustomEase_round(y + ease(inc) * -height);
                    slope = (prevY - y) / (prevX - x);
                    for (i = 2; i < precision; i++) {
                        tx = CustomEase_round(x + i * inc * width);
                        ty = CustomEase_round(y + ease(i * inc) * -height);
                        if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {
                            a.push(prevX, prevY);
                            slope = (ty - prevY) / (tx - prevX);
                        }
                        prevX = tx;
                        prevY = ty;
                    }
                    a = "M" + a.join(",");
                }
                e && e.setAttribute("d", a);
                return a;
            };
            return CustomEase;
        }();
        _getGSAP() && CustomEase_gsap.registerPlugin(CustomEase);
        CustomEase.version = "3.12.0";
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
        }
        /*!
 * Observer 3.12.0
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/        var Observer_gsap, Observer_coreInitted, Observer_win, Observer_doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, Observer_context, Observer_getGSAP = function _getGSAP() {
            return Observer_gsap || typeof window !== "undefined" && (Observer_gsap = window.gsap) && Observer_gsap.registerPlugin && Observer_gsap;
        }, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge(name, value) {
            return value;
        }, _integrate = function _integrate() {
            var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
            scrollers.push.apply(scrollers, _scrollers);
            proxies.push.apply(proxies, _proxies);
            _scrollers = scrollers;
            _proxies = proxies;
            _bridge = function _bridge(name, value) {
                return data[name](value);
            };
        }, _getProxyProp = function _getProxyProp(element, property) {
            return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
        }, _isViewport = function _isViewport(el) {
            return !!~_root.indexOf(el);
        }, _addListener = function _addListener(element, type, func, nonPassive, capture) {
            return element.addEventListener(type, func, {
                passive: !nonPassive,
                capture: !!capture
            });
        }, _removeListener = function _removeListener(element, type, func, capture) {
            return element.removeEventListener(type, func, !!capture);
        }, _scrollLeft = "scrollLeft", _scrollTop = "scrollTop", _onScroll = function _onScroll() {
            return _normalizer && _normalizer.isPressed || _scrollers.cache++;
        }, _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
            var cachingFunc = function cachingFunc(value) {
                if (value || value === 0) {
                    _startup && (Observer_win.history.scrollRestoration = "manual");
                    var isNormalizing = _normalizer && _normalizer.isPressed;
                    value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
                    f(value);
                    cachingFunc.cacheID = _scrollers.cache;
                    isNormalizing && _bridge("ss", value);
                } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
                    cachingFunc.cacheID = _scrollers.cache;
                    cachingFunc.v = f();
                }
                return cachingFunc.v + cachingFunc.offset;
            };
            cachingFunc.offset = 0;
            return f && cachingFunc;
        }, _horizontal = {
            s: _scrollLeft,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: _scrollCacheFunc((function(value) {
                return arguments.length ? Observer_win.scrollTo(value, _vertical.sc()) : Observer_win.pageXOffset || Observer_doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
            }))
        }, _vertical = {
            s: _scrollTop,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: _horizontal,
            sc: _scrollCacheFunc((function(value) {
                return arguments.length ? Observer_win.scrollTo(_horizontal.sc(), value) : Observer_win.pageYOffset || Observer_doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
            }))
        }, _getTarget = function _getTarget(t, self) {
            return (self && self._ctx && self._ctx.selector || Observer_gsap.utils.toArray)(t)[0] || (typeof t === "string" && Observer_gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
        }, _getScrollFunc = function _getScrollFunc(element, _ref) {
            var s = _ref.s, sc = _ref.sc;
            _isViewport(element) && (element = Observer_doc.scrollingElement || _docEl);
            var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
            !~i && (i = _scrollers.push(element) - 1);
            _scrollers[i + offset] || element.addEventListener("scroll", _onScroll);
            var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc((function(value) {
                return arguments.length ? element[s] = value : element[s];
            }))));
            func.target = element;
            prev || (func.smooth = Observer_gsap.getProperty(element, "scrollBehavior") === "smooth");
            return func;
        }, _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
            var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update(value, force) {
                var t = _getTime();
                if (force || t - t1 > min) {
                    v2 = v1;
                    v1 = value;
                    t2 = t1;
                    t1 = t;
                } else if (useDelta) v1 += value; else v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
            }, reset = function reset() {
                v2 = v1 = useDelta ? 0 : v1;
                t2 = t1 = 0;
            }, getVelocity = function getVelocity(latestValue) {
                var tOld = t2, vOld = v2, t = _getTime();
                (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
                return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
            };
            return {
                update,
                reset,
                getVelocity
            };
        }, _getEvent = function _getEvent(e, preventDefault) {
            preventDefault && !e._gsapAllow && e.preventDefault();
            return e.changedTouches ? e.changedTouches[0] : e;
        }, _getAbsoluteMax = function _getAbsoluteMax(a) {
            var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
            return Math.abs(max) >= Math.abs(min) ? max : min;
        }, _setScrollTrigger = function _setScrollTrigger() {
            ScrollTrigger = Observer_gsap.core.globals().ScrollTrigger;
            ScrollTrigger && ScrollTrigger.core && _integrate();
        }, Observer_initCore = function _initCore(core) {
            Observer_gsap = core || Observer_getGSAP();
            if (Observer_gsap && typeof document !== "undefined" && document.body) {
                Observer_win = window;
                Observer_doc = document;
                _docEl = Observer_doc.documentElement;
                _body = Observer_doc.body;
                _root = [ Observer_win, Observer_doc, _docEl, _body ];
                Observer_gsap.utils.clamp;
                Observer_context = Observer_gsap.core.context || function() {};
                _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
                _isTouch = Observer_Observer.isTouch = Observer_win.matchMedia && Observer_win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Observer_win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
                _eventTypes = Observer_Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
                setTimeout((function() {
                    return _startup = 0;
                }), 500);
                _setScrollTrigger();
                Observer_coreInitted = 1;
            }
            return Observer_coreInitted;
        };
        _horizontal.op = _vertical;
        _scrollers.cache = 0;
        var Observer_Observer = function() {
            function Observer(vars) {
                this.init(vars);
            }
            var _proto = Observer.prototype;
            _proto.init = function init(vars) {
                Observer_coreInitted || Observer_initCore(Observer_gsap) || console.warn("Please gsap.registerPlugin(Observer)");
                ScrollTrigger || _setScrollTrigger();
                var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
                this.target = target = _getTarget(target) || _docEl;
                this.vars = vars;
                ignore && (ignore = Observer_gsap.utils.toArray(ignore));
                tolerance = tolerance || 1e-9;
                dragMinimum = dragMinimum || 0;
                wheelSpeed = wheelSpeed || 1;
                scrollSpeed = scrollSpeed || 1;
                type = type || "wheel,touch,pointer";
                debounce = debounce !== false;
                lineHeight || (lineHeight = parseFloat(Observer_win.getComputedStyle(_body).lineHeight) || 22);
                var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || Observer_doc, deltaX = [ 0, 0, 0 ], deltaY = [ 0, 0, 0 ], onClickTime = 0, clickCapture = function clickCapture() {
                    return onClickTime = _getTime();
                }, _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
                    return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
                }, onStopFunc = function onStopFunc() {
                    self._vx.reset();
                    self._vy.reset();
                    onStopDelayedCall.pause();
                    onStop && onStop(self);
                }, update = function update() {
                    var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
                    onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
                    if (changedX) {
                        onRight && self.deltaX > 0 && onRight(self);
                        onLeft && self.deltaX < 0 && onLeft(self);
                        onChangeX && onChangeX(self);
                        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
                        prevDeltaX = self.deltaX;
                        deltaX[0] = deltaX[1] = deltaX[2] = 0;
                    }
                    if (changedY) {
                        onDown && self.deltaY > 0 && onDown(self);
                        onUp && self.deltaY < 0 && onUp(self);
                        onChangeY && onChangeY(self);
                        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
                        prevDeltaY = self.deltaY;
                        deltaY[0] = deltaY[1] = deltaY[2] = 0;
                    }
                    if (moved || dragged) {
                        onMove && onMove(self);
                        if (dragged) {
                            onDrag(self);
                            dragged = false;
                        }
                        moved = false;
                    }
                    locked && !(locked = false) && onLockAxis && onLockAxis(self);
                    if (wheeled) {
                        onWheel(self);
                        wheeled = false;
                    }
                    id = 0;
                }, onDelta = function onDelta(x, y, index) {
                    deltaX[index] += x;
                    deltaY[index] += y;
                    self._vx.update(x);
                    self._vy.update(y);
                    debounce ? id || (id = requestAnimationFrame(update)) : update();
                }, onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
                    if (lockAxis && !axis) {
                        self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
                        locked = true;
                    }
                    if (axis !== "y") {
                        deltaX[2] += x;
                        self._vx.update(x, true);
                    }
                    if (axis !== "x") {
                        deltaY[2] += y;
                        self._vy.update(y, true);
                    }
                    debounce ? id || (id = requestAnimationFrame(update)) : update();
                }, _onDrag = function _onDrag(e) {
                    if (_ignoreCheck(e, 1)) return;
                    e = _getEvent(e, preventDefault);
                    var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;
                    self.x = x;
                    self.y = y;
                    if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
                        onDrag && (dragged = true);
                        isDragging || (self.isDragging = true);
                        onTouchOrPointerDelta(dx, dy);
                        isDragging || onDragStart && onDragStart(self);
                    }
                }, _onPress = self.onPress = function(e) {
                    if (_ignoreCheck(e, 1) || e && e.button) return;
                    self.axis = axis = null;
                    onStopDelayedCall.pause();
                    self.isPressed = true;
                    e = _getEvent(e);
                    prevDeltaX = prevDeltaY = 0;
                    self.startX = self.x = e.clientX;
                    self.startY = self.y = e.clientY;
                    self._vx.reset();
                    self._vy.reset();
                    _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);
                    self.deltaX = self.deltaY = 0;
                    onPress && onPress(self);
                }, _onRelease = self.onRelease = function(e) {
                    if (_ignoreCheck(e, 1)) return;
                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
                    var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), eventData = _getEvent(e);
                    if (!wasDragging && isTrackingDrag) {
                        self._vx.reset();
                        self._vy.reset();
                        if (preventDefault && allowClicks) Observer_gsap.delayedCall(.08, (function() {
                            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) if (e.target.click) e.target.click(); else if (ownerDoc.createEvent) {
                                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                                syntheticEvent.initMouseEvent("click", true, true, Observer_win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                                e.target.dispatchEvent(syntheticEvent);
                            }
                        }));
                    }
                    self.isDragging = self.isGesturing = self.isPressed = false;
                    onStop && !isNormalizer && onStopDelayedCall.restart(true);
                    onDragEnd && wasDragging && onDragEnd(self);
                    onRelease && onRelease(self, wasDragging);
                }, _onGestureStart = function _onGestureStart(e) {
                    return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
                }, _onGestureEnd = function _onGestureEnd() {
                    return (self.isGesturing = false) || onGestureEnd(self);
                }, onScroll = function onScroll(e) {
                    if (_ignoreCheck(e)) return;
                    var x = scrollFuncX(), y = scrollFuncY();
                    onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
                    scrollX = x;
                    scrollY = y;
                    onStop && onStopDelayedCall.restart(true);
                }, _onWheel = function _onWheel(e) {
                    if (_ignoreCheck(e)) return;
                    e = _getEvent(e, preventDefault);
                    onWheel && (wheeled = true);
                    var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? Observer_win.innerHeight : 1) * wheelSpeed;
                    onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
                    onStop && !isNormalizer && onStopDelayedCall.restart(true);
                }, _onMove = function _onMove(e) {
                    if (_ignoreCheck(e)) return;
                    var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;
                    self.x = x;
                    self.y = y;
                    moved = true;
                    (dx || dy) && onTouchOrPointerDelta(dx, dy);
                }, _onHover = function _onHover(e) {
                    self.event = e;
                    onHover(self);
                }, _onHoverEnd = function _onHoverEnd(e) {
                    self.event = e;
                    onHoverEnd(self);
                }, _onClick = function _onClick(e) {
                    return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
                };
                onStopDelayedCall = self._dc = Observer_gsap.delayedCall(onStopDelay || .25, onStopFunc).pause();
                self.deltaX = self.deltaY = 0;
                self._vx = _getVelocityProp(0, 50, true);
                self._vy = _getVelocityProp(0, 50, true);
                self.scrollX = scrollFuncX;
                self.scrollY = scrollFuncY;
                self.isDragging = self.isGesturing = self.isPressed = false;
                Observer_context(this);
                self.enable = function(e) {
                    if (!self.isEnabled) {
                        _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
                        type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
                        type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);
                        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
                            _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);
                            _addListener(ownerDoc, _eventTypes[2], _onRelease);
                            _addListener(ownerDoc, _eventTypes[3], _onRelease);
                            allowClicks && _addListener(target, "click", clickCapture, false, true);
                            onClick && _addListener(target, "click", _onClick);
                            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
                            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
                            onHover && _addListener(target, _pointerType + "enter", _onHover);
                            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
                            onMove && _addListener(target, _pointerType + "move", _onMove);
                        }
                        self.isEnabled = true;
                        e && e.type && _onPress(e);
                        onEnable && onEnable(self);
                    }
                    return self;
                };
                self.disable = function() {
                    if (self.isEnabled) {
                        _observers.filter((function(o) {
                            return o !== self && _isViewport(o.target);
                        })).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
                        if (self.isPressed) {
                            self._vx.reset();
                            self._vy.reset();
                            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
                        }
                        _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
                        _removeListener(target, "wheel", _onWheel, capture);
                        _removeListener(target, _eventTypes[0], _onPress, capture);
                        _removeListener(ownerDoc, _eventTypes[2], _onRelease);
                        _removeListener(ownerDoc, _eventTypes[3], _onRelease);
                        _removeListener(target, "click", clickCapture, true);
                        _removeListener(target, "click", _onClick);
                        _removeListener(ownerDoc, "gesturestart", _onGestureStart);
                        _removeListener(ownerDoc, "gestureend", _onGestureEnd);
                        _removeListener(target, _pointerType + "enter", _onHover);
                        _removeListener(target, _pointerType + "leave", _onHoverEnd);
                        _removeListener(target, _pointerType + "move", _onMove);
                        self.isEnabled = self.isPressed = self.isDragging = false;
                        onDisable && onDisable(self);
                    }
                };
                self.kill = self.revert = function() {
                    self.disable();
                    var i = _observers.indexOf(self);
                    i >= 0 && _observers.splice(i, 1);
                    _normalizer === self && (_normalizer = 0);
                };
                _observers.push(self);
                isNormalizer && _isViewport(target) && (_normalizer = self);
                self.enable(event);
            };
            _createClass(Observer, [ {
                key: "velocityX",
                get: function get() {
                    return this._vx.getVelocity();
                }
            }, {
                key: "velocityY",
                get: function get() {
                    return this._vy.getVelocity();
                }
            } ]);
            return Observer;
        }();
        Observer_Observer.version = "3.12.0";
        Observer_Observer.create = function(vars) {
            return new Observer_Observer(vars);
        };
        Observer_Observer.register = Observer_initCore;
        Observer_Observer.getAll = function() {
            return _observers.slice();
        };
        Observer_Observer.getById = function(id) {
            return _observers.filter((function(o) {
                return o.vars.id === id;
            }))[0];
        };
        Observer_getGSAP() && Observer_gsap.registerPlugin(Observer_Observer);
        /*!
 * ScrollTrigger 3.12.0
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var ScrollTrigger_gsap, ScrollTrigger_coreInitted, ScrollTrigger_win, ScrollTrigger_doc, ScrollTrigger_docEl, ScrollTrigger_body, ScrollTrigger_root, _resizeDelay, _toArray, ScrollTrigger_clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, ScrollTrigger_transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, ScrollTrigger_suppressOverwrites, _ignoreResize, ScrollTrigger_normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, ScrollTrigger_context, _scrollRestoration, _limitCallbacks, _rafID, _refreshingAll, _queueRefreshID, _primary, ScrollTrigger_startup = 1, ScrollTrigger_getTime = Date.now, _time1 = ScrollTrigger_getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function _parseClamp(value, type, self) {
            var clamp = ScrollTrigger_isString(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
            self["_" + type + "Clamp"] = clamp;
            return clamp ? value.substr(6, value.length - 7) : value;
        }, _keepClamp = function _keepClamp(value, clamp) {
            return clamp && (!ScrollTrigger_isString(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
        }, _rafBugFix = function _rafBugFix() {
            return _enabled && requestAnimationFrame(_rafBugFix);
        }, _pointerDownHandler = function _pointerDownHandler() {
            return _pointerIsDown = 1;
        }, _pointerUpHandler = function _pointerUpHandler() {
            return _pointerIsDown = 0;
        }, ScrollTrigger_passThrough = function _passThrough(v) {
            return v;
        }, ScrollTrigger_round = function _round(value) {
            return Math.round(value * 1e5) / 1e5 || 0;
        }, ScrollTrigger_windowExists = function _windowExists() {
            return typeof window !== "undefined";
        }, ScrollTrigger_getGSAP = function _getGSAP() {
            return ScrollTrigger_gsap || ScrollTrigger_windowExists() && (ScrollTrigger_gsap = window.gsap) && ScrollTrigger_gsap.registerPlugin && ScrollTrigger_gsap;
        }, ScrollTrigger_isViewport = function _isViewport(e) {
            return !!~ScrollTrigger_root.indexOf(e);
        }, _getBoundsFunc = function _getBoundsFunc(element) {
            return _getProxyProp(element, "getBoundingClientRect") || (ScrollTrigger_isViewport(element) ? function() {
                _winOffsets.width = ScrollTrigger_win.innerWidth;
                _winOffsets.height = ScrollTrigger_win.innerHeight;
                return _winOffsets;
            } : function() {
                return _getBounds(element);
            });
        }, _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
            var d = _ref.d, d2 = _ref.d2, a = _ref.a;
            return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
                return a()[d];
            } : function() {
                return (isViewport ? ScrollTrigger_win["inner" + d2] : scroller["client" + d2]) || 0;
            };
        }, _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
            return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
                return _winOffsets;
            };
        }, _maxScroll = function _maxScroll(element, _ref2) {
            var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;
            return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : ScrollTrigger_isViewport(element) ? (ScrollTrigger_docEl[s] || ScrollTrigger_body[s]) - (ScrollTrigger_win["inner" + d2] || ScrollTrigger_docEl["client" + d2] || ScrollTrigger_body["client" + d2]) : element[s] - element["offset" + d2]);
        }, _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
            for (var i = 0; i < _autoRefresh.length; i += 3) (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
        }, ScrollTrigger_isString = function _isString(value) {
            return typeof value === "string";
        }, ScrollTrigger_isFunction = function _isFunction(value) {
            return typeof value === "function";
        }, ScrollTrigger_isNumber = function _isNumber(value) {
            return typeof value === "number";
        }, ScrollTrigger_isObject = function _isObject(value) {
            return typeof value === "object";
        }, _endAnimation = function _endAnimation(animation, reversed, pause) {
            return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
        }, ScrollTrigger_callback = function _callback(self, func) {
            if (self.enabled) {
                var result = func(self);
                result && result.totalTime && (self.callbackAnimation = result);
            }
        }, ScrollTrigger_abs = Math.abs, _left = "left", _top = "top", _right = "right", _bottom = "bottom", _width = "width", _height = "height", _Right = "Right", _Left = "Left", _Top = "Top", _Bottom = "Bottom", _padding = "padding", _margin = "margin", _Width = "Width", _Height = "Height", _px = "px", _getComputedStyle = function _getComputedStyle(element) {
            return ScrollTrigger_win.getComputedStyle(element);
        }, _makePositionable = function _makePositionable(element) {
            var position = _getComputedStyle(element).position;
            element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
        }, ScrollTrigger_setDefaults = function _setDefaults(obj, defaults) {
            for (var p in defaults) p in obj || (obj[p] = defaults[p]);
            return obj;
        }, _getBounds = function _getBounds(element, withoutTransforms) {
            var tween = withoutTransforms && _getComputedStyle(element)[ScrollTrigger_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && ScrollTrigger_gsap.to(element, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1), bounds = element.getBoundingClientRect();
            tween && tween.progress(0).kill();
            return bounds;
        }, _getSize = function _getSize(element, _ref3) {
            var d2 = _ref3.d2;
            return element["offset" + d2] || element["client" + d2] || 0;
        }, _getLabelRatioArray = function _getLabelRatioArray(timeline) {
            var p, a = [], labels = timeline.labels, duration = timeline.duration();
            for (p in labels) a.push(labels[p] / duration);
            return a;
        }, _getClosestLabel = function _getClosestLabel(animation) {
            return function(value) {
                return ScrollTrigger_gsap.utils.snap(_getLabelRatioArray(animation), value);
            };
        }, _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
            var snap = ScrollTrigger_gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort((function(a, b) {
                return a - b;
            }));
            return a ? function(value, direction, threshold) {
                if (threshold === void 0) threshold = .001;
                var i;
                if (!direction) return snap(value);
                if (direction > 0) {
                    value -= threshold;
                    for (i = 0; i < a.length; i++) if (a[i] >= value) return a[i];
                    return a[i - 1];
                } else {
                    i = a.length;
                    value += threshold;
                    while (i--) if (a[i] <= value) return a[i];
                }
                return a[0];
            } : function(value, direction, threshold) {
                if (threshold === void 0) threshold = .001;
                var snapped = snap(value);
                return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
            };
        }, _getLabelAtDirection = function _getLabelAtDirection(timeline) {
            return function(value, st) {
                return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
            };
        }, _multiListener = function _multiListener(func, element, types, callback) {
            return types.split(",").forEach((function(type) {
                return func(element, type, callback);
            }));
        }, ScrollTrigger_addListener = function _addListener(element, type, func, nonPassive, capture) {
            return element.addEventListener(type, func, {
                passive: !nonPassive,
                capture: !!capture
            });
        }, ScrollTrigger_removeListener = function _removeListener(element, type, func, capture) {
            return element.removeEventListener(type, func, !!capture);
        }, _wheelListener = function _wheelListener(func, el, scrollFunc) {
            scrollFunc = scrollFunc && scrollFunc.wheelHandler;
            if (scrollFunc) {
                func(el, "wheel", scrollFunc);
                func(el, "touchmove", scrollFunc);
            }
        }, _markerDefaults = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        }, ScrollTrigger_defaults = {
            toggleActions: "play",
            anticipatePin: 0
        }, _keywords = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        }, _offsetToPx = function _offsetToPx(value, size) {
            if (ScrollTrigger_isString(value)) {
                var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
                if (~eqIndex) {
                    value.indexOf("%") > eqIndex && (relative *= size / 100);
                    value = value.substr(0, eqIndex - 1);
                }
                value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
            }
            return value;
        }, _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
            var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
            var e = ScrollTrigger_doc.createElement("div"), useFixedPosition = ScrollTrigger_isViewport(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? ScrollTrigger_body : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
            (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
            matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
            e._isStart = isStart;
            e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
            e.style.cssText = css;
            e.innerText = name || name === 0 ? type + "-" + name : type;
            parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
            e._offset = e["offset" + direction.op.d2];
            _positionMarker(e, 0, direction, isStart);
            return e;
        }, _positionMarker = function _positionMarker(marker, start, direction, flipped) {
            var vars = {
                display: "block"
            }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
            marker._isFlipped = flipped;
            vars[direction.a + "Percent"] = flipped ? -100 : 0;
            vars[direction.a] = flipped ? "1px" : 0;
            vars["border" + side + _Width] = 1;
            vars["border" + oppositeSide + _Width] = 0;
            vars[direction.p] = start + "px";
            ScrollTrigger_gsap.set(marker, vars);
        }, _triggers = [], _ids = {}, _sync = function _sync() {
            return ScrollTrigger_getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
        }, ScrollTrigger_onScroll = function _onScroll() {
            if (!ScrollTrigger_normalizer || !ScrollTrigger_normalizer.isPressed || ScrollTrigger_normalizer.startX > ScrollTrigger_body.clientWidth) {
                _scrollers.cache++;
                if (ScrollTrigger_normalizer) _rafID || (_rafID = requestAnimationFrame(_updateAll)); else _updateAll();
                _lastScrollTime || ScrollTrigger_dispatch("scrollStart");
                _lastScrollTime = ScrollTrigger_getTime();
            }
        }, _setBaseDimensions = function _setBaseDimensions() {
            _baseScreenWidth = ScrollTrigger_win.innerWidth;
            _baseScreenHeight = ScrollTrigger_win.innerHeight;
        }, _onResize = function _onResize() {
            _scrollers.cache++;
            !_refreshing && !_ignoreResize && !ScrollTrigger_doc.fullscreenElement && !ScrollTrigger_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== ScrollTrigger_win.innerWidth || Math.abs(ScrollTrigger_win.innerHeight - _baseScreenHeight) > ScrollTrigger_win.innerHeight * .25) && _resizeDelay.restart(true);
        }, ScrollTrigger_listeners = {}, ScrollTrigger_emptyArray = [], _softRefresh = function _softRefresh() {
            return ScrollTrigger_removeListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
        }, ScrollTrigger_dispatch = function _dispatch(type) {
            return ScrollTrigger_listeners[type] && ScrollTrigger_listeners[type].map((function(f) {
                return f();
            })) || ScrollTrigger_emptyArray;
        }, _savedStyles = [], _revertRecorded = function _revertRecorded(media) {
            for (var i = 0; i < _savedStyles.length; i += 5) if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
                _savedStyles[i].style.cssText = _savedStyles[i + 1];
                _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
                _savedStyles[i + 3].uncache = 1;
            }
        }, _revertAll = function _revertAll(kill, media) {
            var trigger;
            for (_i = 0; _i < _triggers.length; _i++) {
                trigger = _triggers[_i];
                if (trigger && (!media || trigger._ctx === media)) if (kill) trigger.kill(1); else trigger.revert(true, true);
            }
            media && _revertRecorded(media);
            media || ScrollTrigger_dispatch("revert");
        }, _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
            _scrollers.cache++;
            (force || !_refreshingAll) && _scrollers.forEach((function(obj) {
                return ScrollTrigger_isFunction(obj) && obj.cacheID++ && (obj.rec = 0);
            }));
            ScrollTrigger_isString(scrollRestoration) && (ScrollTrigger_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);
        }, _refreshID = 0, _queueRefreshAll = function _queueRefreshAll() {
            if (_queueRefreshID !== _refreshID) {
                var id = _queueRefreshID = _refreshID;
                requestAnimationFrame((function() {
                    return id === _refreshID && _refreshAll(true);
                }));
            }
        }, _refreshAll = function _refreshAll(force, skipRevert) {
            if (_lastScrollTime && !force) {
                ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh);
                return;
            }
            _refreshingAll = ScrollTrigger_ScrollTrigger.isRefreshing = true;
            _scrollers.forEach((function(obj) {
                return ScrollTrigger_isFunction(obj) && ++obj.cacheID && (obj.rec = obj());
            }));
            var refreshInits = ScrollTrigger_dispatch("refreshInit");
            _sort && ScrollTrigger_ScrollTrigger.sort();
            skipRevert || _revertAll();
            _scrollers.forEach((function(obj) {
                if (ScrollTrigger_isFunction(obj)) {
                    obj.smooth && (obj.target.style.scrollBehavior = "auto");
                    obj(0);
                }
            }));
            _triggers.slice(0).forEach((function(t) {
                return t.refresh();
            }));
            _triggers.forEach((function(t, i) {
                if (t._subPinOffset && t.pin) {
                    var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight", original = t.pin[prop];
                    t.revert(true, 1);
                    t.adjustPinSpacing(t.pin[prop] - original);
                    t.refresh();
                }
            }));
            _triggers.forEach((function(t) {
                var max = _maxScroll(t.scroller, t._dir);
                (t.vars.end === "max" || t._endClamp && t.end > max) && t.setPositions(t.start, Math.max(t.start + 1, max), true);
            }));
            refreshInits.forEach((function(result) {
                return result && result.render && result.render(-1);
            }));
            _scrollers.forEach((function(obj) {
                if (ScrollTrigger_isFunction(obj)) {
                    obj.smooth && requestAnimationFrame((function() {
                        return obj.target.style.scrollBehavior = "smooth";
                    }));
                    obj.rec && obj(obj.rec);
                }
            }));
            _clearScrollMemory(_scrollRestoration, 1);
            _resizeDelay.pause();
            _refreshID++;
            _refreshingAll = 2;
            _updateAll(2);
            _triggers.forEach((function(t) {
                return ScrollTrigger_isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);
            }));
            _refreshingAll = ScrollTrigger_ScrollTrigger.isRefreshing = false;
            ScrollTrigger_dispatch("refresh");
        }, _lastScroll = 0, _direction = 1, _updateAll = function _updateAll(force) {
            if (!_refreshingAll || force === 2) {
                ScrollTrigger_ScrollTrigger.isUpdating = true;
                _primary && _primary.update(0);
                var l = _triggers.length, time = ScrollTrigger_getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();
                _direction = _lastScroll > scroll ? -1 : 1;
                _refreshingAll || (_lastScroll = scroll);
                if (recordVelocity) {
                    if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
                        _lastScrollTime = 0;
                        ScrollTrigger_dispatch("scrollEnd");
                    }
                    _time2 = _time1;
                    _time1 = time;
                }
                if (_direction < 0) {
                    _i = l;
                    while (_i-- > 0) _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                    _direction = 1;
                } else for (_i = 0; _i < l; _i++) _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                ScrollTrigger_ScrollTrigger.isUpdating = false;
            }
            _rafID = 0;
        }, _propNamesToCopy = [ _left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order" ], _stateProps = _propNamesToCopy.concat([ _width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left ]), _swapPinOut = function _swapPinOut(pin, spacer, state) {
            _setState(state);
            var cache = pin._gsap;
            if (cache.spacerIsNative) _setState(cache.spacerState); else if (pin._gsap.swappedIn) {
                var parent = spacer.parentNode;
                if (parent) {
                    parent.insertBefore(pin, spacer);
                    parent.removeChild(spacer);
                }
            }
            pin._gsap.swappedIn = false;
        }, _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
            if (!pin._gsap.swappedIn) {
                var p, i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style;
                while (i--) {
                    p = _propNamesToCopy[i];
                    spacerStyle[p] = cs[p];
                }
                spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
                cs.display === "inline" && (spacerStyle.display = "inline-block");
                pinStyle[_bottom] = pinStyle[_right] = "auto";
                spacerStyle.flexBasis = cs.flexBasis || "auto";
                spacerStyle.overflow = "visible";
                spacerStyle.boxSizing = "border-box";
                spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
                spacerStyle[_height] = _getSize(pin, _vertical) + _px;
                spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
                _setState(spacerState);
                pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
                pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
                pinStyle[_padding] = cs[_padding];
                if (pin.parentNode !== spacer) {
                    pin.parentNode.insertBefore(spacer, pin);
                    spacer.appendChild(pin);
                }
                pin._gsap.swappedIn = true;
            }
        }, ScrollTrigger_capsExp = /([A-Z])/g, _setState = function _setState(state) {
            if (state) {
                var p, value, style = state.t.style, l = state.length, i = 0;
                (state.t._gsap || ScrollTrigger_gsap.core.getCache(state.t)).uncache = 1;
                for (;i < l; i += 2) {
                    value = state[i + 1];
                    p = state[i];
                    if (value) style[p] = value; else if (style[p]) style.removeProperty(p.replace(ScrollTrigger_capsExp, "-$1").toLowerCase());
                }
            }
        }, _getState = function _getState(element) {
            var l = _stateProps.length, style = element.style, state = [], i = 0;
            for (;i < l; i++) state.push(_stateProps[i], style[_stateProps[i]]);
            state.t = element;
            return state;
        }, _copyState = function _copyState(state, override, omitOffsets) {
            var p, result = [], l = state.length, i = omitOffsets ? 8 : 0;
            for (;i < l; i += 2) {
                p = state[i];
                result.push(p, p in override ? override[p] : state[i + 1]);
            }
            result.t = state.t;
            return result;
        }, _winOffsets = {
            left: 0,
            top: 0
        }, ScrollTrigger_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
            ScrollTrigger_isFunction(value) && (value = value(self));
            if (ScrollTrigger_isString(value) && value.substr(0, 3) === "max") value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
            var p1, p2, element, time = containerAnimation ? containerAnimation.time() : 0;
            containerAnimation && containerAnimation.seek(0);
            isNaN(value) || (value = +value);
            if (!ScrollTrigger_isNumber(value)) {
                ScrollTrigger_isFunction(trigger) && (trigger = trigger(self));
                var bounds, localOffset, globalOffset, display, offsets = (value || "0").split(" ");
                element = _getTarget(trigger, self) || ScrollTrigger_body;
                bounds = _getBounds(element) || {};
                if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
                    display = element.style.display;
                    element.style.display = "block";
                    bounds = _getBounds(element);
                    display ? element.style.display = display : element.style.removeProperty("display");
                }
                localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
                globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
                value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
                markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
                scrollerSize -= scrollerSize - globalOffset;
            } else {
                containerAnimation && (value = ScrollTrigger_gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
                markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
            }
            if (clampZeroProp) {
                self[clampZeroProp] = value || -.001;
                value < 0 && (value = 0);
            }
            if (marker) {
                var position = value + scrollerSize, isStart = marker._isStart;
                p1 = "scroll" + direction.d2;
                _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(ScrollTrigger_body[p1], ScrollTrigger_docEl[p1]) : marker.parentNode[p1]) <= position + 1);
                if (useFixedPosition) {
                    scrollerBounds = _getBounds(markerScroller);
                    useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
                }
            }
            if (containerAnimation && element) {
                p1 = _getBounds(element);
                containerAnimation.seek(scrollerMax);
                p2 = _getBounds(element);
                containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
                value = value / containerAnimation._caScrollDist * scrollerMax;
            }
            containerAnimation && containerAnimation.seek(time);
            return containerAnimation ? value : Math.round(value);
        }, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent(element, parent, top, left) {
            if (element.parentNode !== parent) {
                var p, cs, style = element.style;
                if (parent === ScrollTrigger_body) {
                    element._stOrig = style.cssText;
                    cs = _getComputedStyle(element);
                    for (p in cs) if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") style[p] = cs[p];
                    style.top = top;
                    style.left = left;
                } else style.cssText = element._stOrig;
                ScrollTrigger_gsap.core.getCache(element).uncache = 1;
                parent.appendChild(element);
            }
        }, _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
            var last1 = initialValue, last2 = last1;
            return function(value) {
                var current = Math.round(getValueFunc());
                if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
                    value = current;
                    onInterrupt && onInterrupt();
                }
                last2 = last1;
                last1 = value;
                return value;
            };
        }, _shiftMarker = function _shiftMarker(marker, direction, value) {
            var vars = {};
            vars[direction.p] = "+=" + value;
            ScrollTrigger_gsap.set(marker, vars);
        }, _getTweenCreator = function _getTweenCreator(scroller, direction) {
            var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
                var tween = getTween.tween, onComplete = vars.onComplete, modifiers = {};
                initialValue = initialValue || getScroll();
                var checkForInterruption = _interruptionTracker(getScroll, initialValue, (function() {
                    tween.kill();
                    getTween.tween = 0;
                }));
                change2 = change1 && change2 || 0;
                change1 = change1 || scrollTo - initialValue;
                tween && tween.kill();
                vars[prop] = scrollTo;
                vars.modifiers = modifiers;
                modifiers[prop] = function() {
                    return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
                };
                vars.onUpdate = function() {
                    _scrollers.cache++;
                    _updateAll();
                };
                vars.onComplete = function() {
                    getTween.tween = 0;
                    onComplete && onComplete.call(tween);
                };
                tween = getTween.tween = ScrollTrigger_gsap.to(scroller, vars);
                return tween;
            };
            scroller[prop] = getScroll;
            getScroll.wheelHandler = function() {
                return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
            };
            ScrollTrigger_addListener(scroller, "wheel", getScroll.wheelHandler);
            ScrollTrigger_ScrollTrigger.isTouch && ScrollTrigger_addListener(scroller, "touchmove", getScroll.wheelHandler);
            return getTween;
        };
        var ScrollTrigger_ScrollTrigger = function() {
            function ScrollTrigger(vars, animation) {
                ScrollTrigger_coreInitted || ScrollTrigger.register(ScrollTrigger_gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
                ScrollTrigger_context(this);
                this.init(vars, animation);
            }
            var _proto = ScrollTrigger.prototype;
            _proto.init = function init(vars, animation) {
                this.progress = this.start = 0;
                this.vars && this.kill(true, true);
                if (!_enabled) {
                    this.update = this.refresh = this.kill = ScrollTrigger_passThrough;
                    return;
                }
                vars = ScrollTrigger_setDefaults(ScrollTrigger_isString(vars) || ScrollTrigger_isNumber(vars) || vars.nodeType ? {
                    trigger: vars
                } : vars, ScrollTrigger_defaults);
                var tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn, _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || ScrollTrigger_win), scrollerCache = ScrollTrigger_gsap.core.getCache(scroller), isViewport = ScrollTrigger_isViewport(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [ vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack ], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : ScrollTrigger_defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {
                    return vars.onRefreshInit(self);
                }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction);
                self._startClamp = self._endClamp = false;
                self._dir = direction;
                anticipatePin *= 45;
                self.scroller = scroller;
                self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
                scroll1 = scrollFunc();
                self.vars = vars;
                animation = animation || vars.animation;
                if ("refreshPriority" in vars) {
                    _sort = 1;
                    vars.refreshPriority === -9999 && (_primary = self);
                }
                scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
                    top: _getTweenCreator(scroller, _vertical),
                    left: _getTweenCreator(scroller, _horizontal)
                };
                self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
                self.scrubDuration = function(value) {
                    scrubSmooth = ScrollTrigger_isNumber(value) && value;
                    if (!scrubSmooth) {
                        scrubTween && scrubTween.progress(1).kill();
                        scrubTween = 0;
                    } else scrubTween ? scrubTween.duration(value) : scrubTween = ScrollTrigger_gsap.to(animation, {
                        ease: "expo",
                        totalProgress: "+=0",
                        duration: scrubSmooth,
                        paused: true,
                        onComplete: function onComplete() {
                            return onScrubComplete && onScrubComplete(self);
                        }
                    });
                };
                if (animation) {
                    animation.vars.lazy = false;
                    animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
                    self.animation = animation.pause();
                    animation.scrollTrigger = self;
                    self.scrubDuration(scrub);
                    snap1 = 0;
                    id || (id = animation.vars.id);
                }
                if (snap) {
                    if (!ScrollTrigger_isObject(snap) || snap.push) snap = {
                        snapTo: snap
                    };
                    "scrollBehavior" in ScrollTrigger_body.style && ScrollTrigger_gsap.set(isViewport ? [ ScrollTrigger_body, ScrollTrigger_docEl ] : scroller, {
                        scrollBehavior: "auto"
                    });
                    _scrollers.forEach((function(o) {
                        return ScrollTrigger_isFunction(o) && o.target === (isViewport ? ScrollTrigger_doc.scrollingElement || ScrollTrigger_docEl : scroller) && (o.smooth = false);
                    }));
                    snapFunc = ScrollTrigger_isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {
                        return _snapDirectional(snap.snapTo)(value, ScrollTrigger_getTime() - lastRefresh < 500 ? 0 : st.direction);
                    } : ScrollTrigger_gsap.utils.snap(snap.snapTo);
                    snapDurClamp = snap.duration || {
                        min: .1,
                        max: 2
                    };
                    snapDurClamp = ScrollTrigger_isObject(snapDurClamp) ? ScrollTrigger_clamp(snapDurClamp.min, snapDurClamp.max) : ScrollTrigger_clamp(snapDurClamp, snapDurClamp);
                    snapDelayedCall = ScrollTrigger_gsap.delayedCall(snap.delay || scrubSmooth / 2 || .1, (function() {
                        var scroll = scrollFunc(), refreshedRecently = ScrollTrigger_getTime() - lastRefresh < 500, tween = tweenTo.tween;
                        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
                            var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (ScrollTrigger_getTime() - _time2) * 1e3 || 0, change1 = ScrollTrigger_gsap.utils.clamp(-progress, 1 - progress, ScrollTrigger_abs(velocity / 2) * velocity / .185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue = ScrollTrigger_clamp(0, 1, snapFunc(naturalEnd, self)), endScroll = Math.round(start + endValue * change), _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
                            if (scroll <= end && scroll >= start && endScroll !== scroll) {
                                if (tween && !tween._initted && tween.data <= ScrollTrigger_abs(endScroll - scroll)) return;
                                if (snap.inertia === false) change1 = endValue - progress;
                                tweenTo(endScroll, {
                                    duration: snapDurClamp(ScrollTrigger_abs(Math.max(ScrollTrigger_abs(naturalEnd - totalProgress), ScrollTrigger_abs(endValue - totalProgress)) * .185 / velocity / .05 || 0)),
                                    ease: snap.ease || "power3",
                                    data: ScrollTrigger_abs(endScroll - scroll),
                                    onInterrupt: function onInterrupt() {
                                        return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                                    },
                                    onComplete: function onComplete() {
                                        self.update();
                                        lastSnap = scrollFunc();
                                        snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                                        onSnapComplete && onSnapComplete(self);
                                        _onComplete && _onComplete(self);
                                    }
                                }, scroll, change1 * change, endScroll - scroll - change1 * change);
                                onStart && onStart(self, tweenTo.tween);
                            }
                        } else if (self.isActive && lastSnap !== scroll) snapDelayedCall.restart(true);
                    })).pause();
                }
                id && (_ids[id] = self);
                trigger = self.trigger = _getTarget(trigger || pin !== true && pin);
                customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
                customRevertReturn && (customRevertReturn = customRevertReturn(self));
                pin = pin === true ? trigger : _getTarget(pin);
                ScrollTrigger_isString(toggleClass) && (toggleClass = {
                    targets: trigger,
                    className: toggleClass
                });
                if (pin) {
                    pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
                    self.pin = pin;
                    pinCache = ScrollTrigger_gsap.core.getCache(pin);
                    if (!pinCache.spacer) {
                        if (pinSpacer) {
                            pinSpacer = _getTarget(pinSpacer);
                            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
                            pinCache.spacerIsNative = !!pinSpacer;
                            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
                        }
                        pinCache.spacer = spacer = pinSpacer || ScrollTrigger_doc.createElement("div");
                        spacer.classList.add("pin-spacer");
                        id && spacer.classList.add("pin-spacer-" + id);
                        pinCache.pinState = pinOriginalState = _getState(pin);
                    } else pinOriginalState = pinCache.pinState;
                    vars.force3D !== false && ScrollTrigger_gsap.set(pin, {
                        force3D: true
                    });
                    self.spacer = spacer = pinCache.spacer;
                    cs = _getComputedStyle(pin);
                    spacingStart = cs[pinSpacing + direction.os2];
                    pinGetter = ScrollTrigger_gsap.getProperty(pin);
                    pinSetter = ScrollTrigger_gsap.quickSetter(pin, direction.a, _px);
                    _swapPinIn(pin, spacer, cs);
                    pinState = _getState(pin);
                }
                if (markers) {
                    markerVars = ScrollTrigger_isObject(markers) ? ScrollTrigger_setDefaults(markers, _markerDefaults) : _markerDefaults;
                    markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
                    markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
                    offset = markerStartTrigger["offset" + direction.op.d2];
                    var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
                    markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
                    markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
                    containerAnimation && (caMarkerSetter = ScrollTrigger_gsap.quickSetter([ markerStart, markerEnd ], direction.a, _px));
                    if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
                        _makePositionable(isViewport ? ScrollTrigger_body : scroller);
                        ScrollTrigger_gsap.set([ markerStartTrigger, markerEndTrigger ], {
                            force3D: true
                        });
                        markerStartSetter = ScrollTrigger_gsap.quickSetter(markerStartTrigger, direction.a, _px);
                        markerEndSetter = ScrollTrigger_gsap.quickSetter(markerEndTrigger, direction.a, _px);
                    }
                }
                if (containerAnimation) {
                    var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
                    containerAnimation.eventCallback("onUpdate", (function() {
                        self.update(0, 0, 1);
                        oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
                    }));
                }
                self.previous = function() {
                    return _triggers[_triggers.indexOf(self) - 1];
                };
                self.next = function() {
                    return _triggers[_triggers.indexOf(self) + 1];
                };
                self.revert = function(revert, temp) {
                    if (!temp) return self.kill(true);
                    var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;
                    if (r !== self.isReverted) {
                        if (r) {
                            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
                            prevProgress = self.progress;
                            prevAnimProgress = animation && animation.progress();
                        }
                        markerStart && [ markerStart, markerEnd, markerStartTrigger, markerEndTrigger ].forEach((function(m) {
                            return m.style.display = r ? "none" : "block";
                        }));
                        if (r) {
                            _refreshing = self;
                            self.update(r);
                        }
                        if (pin && (!pinReparent || !self.isActive)) if (r) _swapPinOut(pin, spacer, pinOriginalState); else _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
                        r || self.update(r);
                        _refreshing = prevRefreshing;
                        self.isReverted = r;
                    }
                };
                self.refresh = function(soft, force, position, pinOffset) {
                    if ((_refreshing || !self.enabled) && !force) return;
                    if (pin && soft && _lastScrollTime) {
                        ScrollTrigger_addListener(ScrollTrigger, "scrollEnd", _softRefresh);
                        return;
                    }
                    !_refreshingAll && onRefreshInit && onRefreshInit(self);
                    _refreshing = self;
                    if (tweenTo.tween) {
                        tweenTo.tween.kill();
                        tweenTo.tween = 0;
                    }
                    scrubTween && scrubTween.pause();
                    invalidateOnRefresh && animation && animation.revert({
                        kill: false
                    }).invalidate();
                    self.isReverted || self.revert(true, true);
                    self._subPinOffset = false;
                    var cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset, size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= .01, offset = 0, otherPinOffset = pinOffset || 0, parsedEnd = ScrollTrigger_isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = ScrollTrigger_isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex;
                    if (markers && ScrollTrigger_isObject(position)) {
                        markerStartOffset = ScrollTrigger_gsap.getProperty(markerStartTrigger, direction.p);
                        markerEndOffset = ScrollTrigger_gsap.getProperty(markerEndTrigger, direction.p);
                    }
                    while (i--) {
                        curTrigger = _triggers[i];
                        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);
                        curPin = curTrigger.pin;
                        if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
                            revertedPins || (revertedPins = []);
                            revertedPins.unshift(curTrigger);
                            curTrigger.revert(true, true);
                        }
                        if (curTrigger !== _triggers[i]) {
                            triggerIndex--;
                            i--;
                        }
                    }
                    ScrollTrigger_isFunction(parsedStart) && (parsedStart = parsedStart(self));
                    parsedStart = _parseClamp(parsedStart, "start", self);
                    start = ScrollTrigger_parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -.001 : 0);
                    ScrollTrigger_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
                    if (ScrollTrigger_isString(parsedEnd) && !parsedEnd.indexOf("+=")) if (~parsedEnd.indexOf(" ")) parsedEnd = (ScrollTrigger_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd; else {
                        offset = _offsetToPx(parsedEnd.substr(2), size);
                        parsedEnd = ScrollTrigger_isString(parsedStart) ? parsedStart : (containerAnimation ? ScrollTrigger_gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset;
                        parsedEndTrigger = trigger;
                    }
                    parsedEnd = _parseClamp(parsedEnd, "end", self);
                    end = Math.max(start, ScrollTrigger_parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -.001;
                    offset = 0;
                    i = triggerIndex;
                    while (i--) {
                        curTrigger = _triggers[i];
                        curPin = curTrigger.pin;
                        if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
                            cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
                            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) offset += cs * (1 - curTrigger.progress);
                            curPin === pin && (otherPinOffset += cs);
                        }
                    }
                    start += offset;
                    end += offset;
                    self._startClamp && (self._startClamp += offset);
                    if (self._endClamp && !_refreshingAll) {
                        self._endClamp = end || -.001;
                        end = Math.min(end, _maxScroll(scroller, direction));
                    }
                    change = end - start || (start -= .01) && .001;
                    if (isFirstRefresh) prevProgress = ScrollTrigger_gsap.utils.clamp(0, 1, ScrollTrigger_gsap.utils.normalize(start, end, prevScroll));
                    self._pinPush = otherPinOffset;
                    if (markerStart && offset) {
                        cs = {};
                        cs[direction.a] = "+=" + offset;
                        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
                        ScrollTrigger_gsap.set([ markerStart, markerEnd ], cs);
                    }
                    if (pin) {
                        cs = _getComputedStyle(pin);
                        isVertical = direction === _vertical;
                        scroll = scrollFunc();
                        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
                        if (!max && end > 1) {
                            forcedOverflow = (isViewport ? ScrollTrigger_doc.scrollingElement || ScrollTrigger_docEl : scroller).style;
                            forcedOverflow = {
                                style: forcedOverflow,
                                value: forcedOverflow["overflow" + direction.a.toUpperCase()]
                            };
                            if (isViewport && _getComputedStyle(ScrollTrigger_body)["overflow" + direction.a.toUpperCase()] !== "scroll") forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
                        }
                        _swapPinIn(pin, spacer, cs);
                        pinState = _getState(pin);
                        bounds = _getBounds(pin, true);
                        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
                        if (pinSpacing) {
                            spacerState = [ pinSpacing + direction.os2, change + otherPinOffset + _px ];
                            spacerState.t = spacer;
                            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
                            i && spacerState.push(direction.d, i + _px);
                            _setState(spacerState);
                            if (pinnedContainer) _triggers.forEach((function(t) {
                                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) t._subPinOffset = true;
                            }));
                            useFixedPosition && scrollFunc(prevScroll);
                        }
                        if (useFixedPosition) {
                            override = {
                                top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                                left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                                boxSizing: "border-box",
                                position: "fixed"
                            };
                            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
                            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
                            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
                            override[_padding] = cs[_padding];
                            override[_padding + _Top] = cs[_padding + _Top];
                            override[_padding + _Right] = cs[_padding + _Right];
                            override[_padding + _Bottom] = cs[_padding + _Bottom];
                            override[_padding + _Left] = cs[_padding + _Left];
                            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
                            _refreshingAll && scrollFunc(0);
                        }
                        if (animation) {
                            initted = animation._initted;
                            ScrollTrigger_suppressOverwrites(1);
                            animation.render(animation.duration(), true, true);
                            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
                            pinMoves = Math.abs(change - pinChange) > 1;
                            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
                            animation.render(0, true, true);
                            initted || animation.invalidate(true);
                            animation.parent || animation.totalTime(animation.totalTime());
                            ScrollTrigger_suppressOverwrites(0);
                        } else pinChange = change;
                        forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
                    } else if (trigger && scrollFunc() && !containerAnimation) {
                        bounds = trigger.parentNode;
                        while (bounds && bounds !== ScrollTrigger_body) {
                            if (bounds._pinOffset) {
                                start -= bounds._pinOffset;
                                end -= bounds._pinOffset;
                            }
                            bounds = bounds.parentNode;
                        }
                    }
                    revertedPins && revertedPins.forEach((function(t) {
                        return t.revert(false, true);
                    }));
                    self.start = start;
                    self.end = end;
                    scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
                    if (!containerAnimation && !_refreshingAll) {
                        scroll1 < prevScroll && scrollFunc(prevScroll);
                        self.scroll.rec = 0;
                    }
                    self.revert(false, true);
                    lastRefresh = ScrollTrigger_getTime();
                    if (snapDelayedCall) {
                        lastSnap = -1;
                        self.isActive && scrollFunc(start + change * prevProgress);
                        snapDelayedCall.restart(true);
                    }
                    _refreshing = 0;
                    animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);
                    if (isFirstRefresh || prevProgress !== self.progress || containerAnimation) {
                        animation && !isToggle && animation.totalProgress(containerAnimation && start < -.001 && !prevProgress ? ScrollTrigger_gsap.utils.normalize(start, end, 0) : prevProgress, true);
                        self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
                    }
                    pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
                    scrubTween && scrubTween.invalidate();
                    if (!isNaN(markerStartOffset)) {
                        markerStartOffset -= ScrollTrigger_gsap.getProperty(markerStartTrigger, direction.p);
                        markerEndOffset -= ScrollTrigger_gsap.getProperty(markerEndTrigger, direction.p);
                        _shiftMarker(markerStartTrigger, direction, markerStartOffset);
                        _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
                        _shiftMarker(markerEndTrigger, direction, markerEndOffset);
                        _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
                    }
                    isFirstRefresh && !_refreshingAll && self.update();
                    if (onRefresh && !_refreshingAll && !executingOnRefresh) {
                        executingOnRefresh = true;
                        onRefresh(self);
                        executingOnRefresh = false;
                    }
                };
                self.getVelocity = function() {
                    return (scrollFunc() - scroll2) / (ScrollTrigger_getTime() - _time2) * 1e3 || 0;
                };
                self.endAnimation = function() {
                    _endAnimation(self.callbackAnimation);
                    if (animation) scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
                };
                self.labelToScroll = function(label) {
                    return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
                };
                self.getTrailing = function(name) {
                    var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
                    return (ScrollTrigger_isString(name) ? a.filter((function(t) {
                        return t.vars.preventOverlaps === name;
                    })) : a).filter((function(t) {
                        return self.direction > 0 ? t.end <= start : t.start >= end;
                    }));
                };
                self.update = function(reset, recordVelocity, forceFake) {
                    if (containerAnimation && !forceFake && !reset) return;
                    var isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction, scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress = self.progress;
                    if (recordVelocity) {
                        scroll2 = scroll1;
                        scroll1 = containerAnimation ? scrollFunc() : scroll;
                        if (snap) {
                            snap2 = snap1;
                            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
                        }
                    }
                    anticipatePin && !clipped && pin && !_refreshing && !ScrollTrigger_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (ScrollTrigger_getTime() - _time2) * anticipatePin && (clipped = 1e-4);
                    if (clipped !== prevProgress && self.enabled) {
                        isActive = self.isActive = !!clipped && clipped < 1;
                        wasActive = !!prevProgress && prevProgress < 1;
                        toggled = isActive !== wasActive;
                        stateChanged = toggled || !!clipped !== !!prevProgress;
                        self.direction = clipped > prevProgress ? 1 : -1;
                        self.progress = clipped;
                        if (stateChanged && !_refreshing) {
                            toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3;
                            if (isToggle) {
                                action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
                                isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
                            }
                        }
                        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (ScrollTrigger_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach((function(t) {
                            return t.endAnimation();
                        })));
                        if (!isToggle) if (scrubTween && !_refreshing && !ScrollTrigger_startup) {
                            scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
                            if (scrubTween.resetTo) scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur); else {
                                scrubTween.vars.totalProgress = clipped;
                                scrubTween.invalidate().restart();
                            }
                        } else if (animation) animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
                        if (pin) {
                            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
                            if (!useFixedPosition) pinSetter(ScrollTrigger_round(pinStart + pinChange * clipped)); else if (stateChanged) {
                                isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
                                if (pinReparent) if (!reset && (isActive || isAtMax)) {
                                    var bounds = _getBounds(pin, true), _offset = scroll - start;
                                    _reparent(pin, ScrollTrigger_body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                                } else _reparent(pin, spacer);
                                _setState(isActive || isAtMax ? pinActiveState : pinState);
                                pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
                            }
                        }
                        snap && !tweenTo.tween && !_refreshing && !ScrollTrigger_startup && snapDelayedCall.restart(true);
                        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach((function(el) {
                            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
                        }));
                        onUpdate && !isToggle && !reset && onUpdate(self);
                        if (stateChanged && !_refreshing) {
                            if (isToggle) {
                                if (isTakingAction) if (action === "complete") animation.pause().totalProgress(1); else if (action === "reset") animation.restart(true).pause(); else if (action === "restart") animation.restart(true); else animation[action]();
                                onUpdate && onUpdate(self);
                            }
                            if (toggled || !_limitCallbacks) {
                                onToggle && toggled && ScrollTrigger_callback(self, onToggle);
                                callbacks[toggleState] && ScrollTrigger_callback(self, callbacks[toggleState]);
                                once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);
                                if (!toggled) {
                                    toggleState = clipped === 1 ? 1 : 3;
                                    callbacks[toggleState] && ScrollTrigger_callback(self, callbacks[toggleState]);
                                }
                            }
                            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (ScrollTrigger_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                                _endAnimation(self.callbackAnimation);
                                scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
                            }
                        } else if (isToggle && onUpdate && !_refreshing) onUpdate(self);
                    }
                    if (markerEndSetter) {
                        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
                        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
                        markerEndSetter(n);
                    }
                    caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
                };
                self.enable = function(reset, refresh) {
                    if (!self.enabled) {
                        self.enabled = true;
                        ScrollTrigger_addListener(scroller, "resize", _onResize);
                        ScrollTrigger_addListener(isViewport ? ScrollTrigger_doc : scroller, "scroll", ScrollTrigger_onScroll);
                        onRefreshInit && ScrollTrigger_addListener(ScrollTrigger, "refreshInit", onRefreshInit);
                        if (reset !== false) {
                            self.progress = prevProgress = 0;
                            scroll1 = scroll2 = lastSnap = scrollFunc();
                        }
                        refresh !== false && self.refresh();
                    }
                };
                self.getTween = function(snap) {
                    return snap && tweenTo ? tweenTo.tween : scrubTween;
                };
                self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
                    self.refresh(false, false, {
                        start: _keepClamp(newStart, keepClamp && !!self._startClamp),
                        end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
                    }, pinOffset);
                    self.update();
                };
                self.adjustPinSpacing = function(amount) {
                    if (spacerState && amount) {
                        var i = spacerState.indexOf(direction.d) + 1;
                        spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
                        spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
                        _setState(spacerState);
                    }
                };
                self.disable = function(reset, allowAnimation) {
                    if (self.enabled) {
                        reset !== false && self.revert(true, true);
                        self.enabled = self.isActive = false;
                        allowAnimation || scrubTween && scrubTween.pause();
                        prevScroll = 0;
                        pinCache && (pinCache.uncache = 1);
                        onRefreshInit && ScrollTrigger_removeListener(ScrollTrigger, "refreshInit", onRefreshInit);
                        if (snapDelayedCall) {
                            snapDelayedCall.pause();
                            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
                        }
                        if (!isViewport) {
                            var i = _triggers.length;
                            while (i--) if (_triggers[i].scroller === scroller && _triggers[i] !== self) return;
                            ScrollTrigger_removeListener(scroller, "resize", _onResize);
                            ScrollTrigger_removeListener(scroller, "scroll", ScrollTrigger_onScroll);
                        }
                    }
                };
                self.kill = function(revert, allowAnimation) {
                    self.disable(revert, allowAnimation);
                    scrubTween && !allowAnimation && scrubTween.kill();
                    id && delete _ids[id];
                    var i = _triggers.indexOf(self);
                    i >= 0 && _triggers.splice(i, 1);
                    i === _i && _direction > 0 && _i--;
                    i = 0;
                    _triggers.forEach((function(t) {
                        return t.scroller === self.scroller && (i = 1);
                    }));
                    i || _refreshingAll || (self.scroll.rec = 0);
                    if (animation) {
                        animation.scrollTrigger = null;
                        revert && animation.revert({
                            kill: false
                        });
                        allowAnimation || animation.kill();
                    }
                    markerStart && [ markerStart, markerEnd, markerStartTrigger, markerEndTrigger ].forEach((function(m) {
                        return m.parentNode && m.parentNode.removeChild(m);
                    }));
                    _primary === self && (_primary = 0);
                    if (pin) {
                        pinCache && (pinCache.uncache = 1);
                        i = 0;
                        _triggers.forEach((function(t) {
                            return t.pin === pin && i++;
                        }));
                        i || (pinCache.spacer = 0);
                    }
                    vars.onKill && vars.onKill(self);
                };
                _triggers.push(self);
                self.enable(false, false);
                customRevertReturn && customRevertReturn(self);
                if (animation && animation.add && !change) {
                    var updateFunc = self.update;
                    self.update = function() {
                        self.update = updateFunc;
                        start || end || self.refresh();
                    };
                    ScrollTrigger_gsap.delayedCall(.01, self.update);
                    change = .01;
                    start = end = 0;
                } else self.refresh();
                pin && _queueRefreshAll();
            };
            ScrollTrigger.register = function register(core) {
                if (!ScrollTrigger_coreInitted) {
                    ScrollTrigger_gsap = core || ScrollTrigger_getGSAP();
                    ScrollTrigger_windowExists() && window.document && ScrollTrigger.enable();
                    ScrollTrigger_coreInitted = _enabled;
                }
                return ScrollTrigger_coreInitted;
            };
            ScrollTrigger.defaults = function defaults(config) {
                if (config) for (var p in config) ScrollTrigger_defaults[p] = config[p];
                return ScrollTrigger_defaults;
            };
            ScrollTrigger.disable = function disable(reset, kill) {
                _enabled = 0;
                _triggers.forEach((function(trigger) {
                    return trigger[kill ? "kill" : "disable"](reset);
                }));
                ScrollTrigger_removeListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll);
                ScrollTrigger_removeListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll);
                clearInterval(_syncInterval);
                ScrollTrigger_removeListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough);
                ScrollTrigger_removeListener(ScrollTrigger_body, "touchstart", ScrollTrigger_passThrough);
                _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
                _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);
                _resizeDelay.kill();
                _iterateAutoRefresh(ScrollTrigger_removeListener);
                for (var i = 0; i < _scrollers.length; i += 3) {
                    _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);
                    _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
                }
            };
            ScrollTrigger.enable = function enable() {
                ScrollTrigger_win = window;
                ScrollTrigger_doc = document;
                ScrollTrigger_docEl = ScrollTrigger_doc.documentElement;
                ScrollTrigger_body = ScrollTrigger_doc.body;
                if (ScrollTrigger_gsap) {
                    _toArray = ScrollTrigger_gsap.utils.toArray;
                    ScrollTrigger_clamp = ScrollTrigger_gsap.utils.clamp;
                    ScrollTrigger_context = ScrollTrigger_gsap.core.context || ScrollTrigger_passThrough;
                    ScrollTrigger_suppressOverwrites = ScrollTrigger_gsap.core.suppressOverwrites || ScrollTrigger_passThrough;
                    _scrollRestoration = ScrollTrigger_win.history.scrollRestoration || "auto";
                    _lastScroll = ScrollTrigger_win.pageYOffset;
                    ScrollTrigger_gsap.core.globals("ScrollTrigger", ScrollTrigger);
                    if (ScrollTrigger_body) {
                        _enabled = 1;
                        _rafBugFix();
                        Observer_Observer.register(ScrollTrigger_gsap);
                        ScrollTrigger.isTouch = Observer_Observer.isTouch;
                        _fixIOSBug = Observer_Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
                        ScrollTrigger_addListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll);
                        ScrollTrigger_root = [ ScrollTrigger_win, ScrollTrigger_doc, ScrollTrigger_docEl, ScrollTrigger_body ];
                        if (ScrollTrigger_gsap.matchMedia) {
                            ScrollTrigger.matchMedia = function(vars) {
                                var p, mm = ScrollTrigger_gsap.matchMedia();
                                for (p in vars) mm.add(p, vars[p]);
                                return mm;
                            };
                            ScrollTrigger_gsap.addEventListener("matchMediaInit", (function() {
                                return _revertAll();
                            }));
                            ScrollTrigger_gsap.addEventListener("matchMediaRevert", (function() {
                                return _revertRecorded();
                            }));
                            ScrollTrigger_gsap.addEventListener("matchMedia", (function() {
                                _refreshAll(0, 1);
                                ScrollTrigger_dispatch("matchMedia");
                            }));
                            ScrollTrigger_gsap.matchMedia("(orientation: portrait)", (function() {
                                _setBaseDimensions();
                                return _setBaseDimensions;
                            }));
                        } else console.warn("Requires GSAP 3.11.0 or later");
                        _setBaseDimensions();
                        ScrollTrigger_addListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll);
                        var bounds, i, bodyStyle = ScrollTrigger_body.style, border = bodyStyle.borderTopStyle, AnimationProto = ScrollTrigger_gsap.core.Animation.prototype;
                        AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
                            value: function value() {
                                return this.time(-.01, true);
                            }
                        });
                        bodyStyle.borderTopStyle = "solid";
                        bounds = _getBounds(ScrollTrigger_body);
                        _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
                        _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
                        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
                        _syncInterval = setInterval(_sync, 250);
                        ScrollTrigger_gsap.delayedCall(.5, (function() {
                            return ScrollTrigger_startup = 0;
                        }));
                        ScrollTrigger_addListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough);
                        ScrollTrigger_addListener(ScrollTrigger_body, "touchstart", ScrollTrigger_passThrough);
                        _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
                        _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);
                        ScrollTrigger_transformProp = ScrollTrigger_gsap.utils.checkPrefix("transform");
                        _stateProps.push(ScrollTrigger_transformProp);
                        ScrollTrigger_coreInitted = ScrollTrigger_getTime();
                        _resizeDelay = ScrollTrigger_gsap.delayedCall(.2, _refreshAll).pause();
                        _autoRefresh = [ ScrollTrigger_doc, "visibilitychange", function() {
                            var w = ScrollTrigger_win.innerWidth, h = ScrollTrigger_win.innerHeight;
                            if (ScrollTrigger_doc.hidden) {
                                _prevWidth = w;
                                _prevHeight = h;
                            } else if (_prevWidth !== w || _prevHeight !== h) _onResize();
                        }, ScrollTrigger_doc, "DOMContentLoaded", _refreshAll, ScrollTrigger_win, "load", _refreshAll, ScrollTrigger_win, "resize", _onResize ];
                        _iterateAutoRefresh(ScrollTrigger_addListener);
                        _triggers.forEach((function(trigger) {
                            return trigger.enable(0, 1);
                        }));
                        for (i = 0; i < _scrollers.length; i += 3) {
                            _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);
                            _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
                        }
                    }
                }
            };
            ScrollTrigger.config = function config(vars) {
                "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
                var ms = vars.syncInterval;
                ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
                "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);
                if ("autoRefreshEvents" in vars) {
                    _iterateAutoRefresh(ScrollTrigger_removeListener) || _iterateAutoRefresh(ScrollTrigger_addListener, vars.autoRefreshEvents || "none");
                    _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
                }
            };
            ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
                var t = _getTarget(target), i = _scrollers.indexOf(t), isViewport = ScrollTrigger_isViewport(t);
                if (~i) _scrollers.splice(i, isViewport ? 6 : 2);
                if (vars) isViewport ? _proxies.unshift(ScrollTrigger_win, vars, ScrollTrigger_body, vars, ScrollTrigger_docEl, vars) : _proxies.unshift(t, vars);
            };
            ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
                _triggers.forEach((function(t) {
                    return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
                }));
            };
            ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
                var bounds = (ScrollTrigger_isString(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
                return horizontal ? bounds.right - offset > 0 && bounds.left + offset < ScrollTrigger_win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < ScrollTrigger_win.innerHeight;
            };
            ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
                ScrollTrigger_isString(element) && (element = _getTarget(element));
                var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
                return horizontal ? (bounds.left + offset) / ScrollTrigger_win.innerWidth : (bounds.top + offset) / ScrollTrigger_win.innerHeight;
            };
            ScrollTrigger.killAll = function killAll(allowListeners) {
                _triggers.slice(0).forEach((function(t) {
                    return t.vars.id !== "ScrollSmoother" && t.kill();
                }));
                if (allowListeners !== true) {
                    var listeners = ScrollTrigger_listeners.killAll || [];
                    ScrollTrigger_listeners = {};
                    listeners.forEach((function(f) {
                        return f();
                    }));
                }
            };
            return ScrollTrigger;
        }();
        ScrollTrigger_ScrollTrigger.version = "3.12.0";
        ScrollTrigger_ScrollTrigger.saveStyles = function(targets) {
            return targets ? _toArray(targets).forEach((function(target) {
                if (target && target.style) {
                    var i = _savedStyles.indexOf(target);
                    i >= 0 && _savedStyles.splice(i, 5);
                    _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), ScrollTrigger_gsap.core.getCache(target), ScrollTrigger_context());
                }
            })) : _savedStyles;
        };
        ScrollTrigger_ScrollTrigger.revert = function(soft, media) {
            return _revertAll(!soft, media);
        };
        ScrollTrigger_ScrollTrigger.create = function(vars, animation) {
            return new ScrollTrigger_ScrollTrigger(vars, animation);
        };
        ScrollTrigger_ScrollTrigger.refresh = function(safe) {
            return safe ? _onResize() : (ScrollTrigger_coreInitted || ScrollTrigger_ScrollTrigger.register()) && _refreshAll(true);
        };
        ScrollTrigger_ScrollTrigger.update = function(force) {
            return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
        };
        ScrollTrigger_ScrollTrigger.clearScrollMemory = _clearScrollMemory;
        ScrollTrigger_ScrollTrigger.maxScroll = function(element, horizontal) {
            return _maxScroll(element, horizontal ? _horizontal : _vertical);
        };
        ScrollTrigger_ScrollTrigger.getScrollFunc = function(element, horizontal) {
            return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
        };
        ScrollTrigger_ScrollTrigger.getById = function(id) {
            return _ids[id];
        };
        ScrollTrigger_ScrollTrigger.getAll = function() {
            return _triggers.filter((function(t) {
                return t.vars.id !== "ScrollSmoother";
            }));
        };
        ScrollTrigger_ScrollTrigger.isScrolling = function() {
            return !!_lastScrollTime;
        };
        ScrollTrigger_ScrollTrigger.snapDirectional = _snapDirectional;
        ScrollTrigger_ScrollTrigger.addEventListener = function(type, callback) {
            var a = ScrollTrigger_listeners[type] || (ScrollTrigger_listeners[type] = []);
            ~a.indexOf(callback) || a.push(callback);
        };
        ScrollTrigger_ScrollTrigger.removeEventListener = function(type, callback) {
            var a = ScrollTrigger_listeners[type], i = a && a.indexOf(callback);
            i >= 0 && a.splice(i, 1);
        };
        ScrollTrigger_ScrollTrigger.batch = function(targets, vars) {
            var p, result = [], varsCopy = {}, interval = vars.interval || .016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback(type, callback) {
                var elements = [], triggers = [], delay = ScrollTrigger_gsap.delayedCall(interval, (function() {
                    callback(elements, triggers);
                    elements = [];
                    triggers = [];
                })).pause();
                return function(self) {
                    elements.length || delay.restart(true);
                    elements.push(self.trigger);
                    triggers.push(self);
                    batchMax <= elements.length && delay.progress(1);
                };
            };
            for (p in vars) varsCopy[p] = p.substr(0, 2) === "on" && ScrollTrigger_isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
            if (ScrollTrigger_isFunction(batchMax)) {
                batchMax = batchMax();
                ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "refresh", (function() {
                    return batchMax = vars.batchMax();
                }));
            }
            _toArray(targets).forEach((function(target) {
                var config = {};
                for (p in varsCopy) config[p] = varsCopy[p];
                config.trigger = target;
                result.push(ScrollTrigger_ScrollTrigger.create(config));
            }));
            return result;
        };
        var _inputIsFocused, _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
            current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
            return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
        }, _allowNativePanning = function _allowNativePanning(target, direction) {
            if (direction === true) target.style.removeProperty("touch-action"); else target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer_Observer.isTouch ? " pinch-zoom" : "") : "none";
            target === ScrollTrigger_docEl && _allowNativePanning(ScrollTrigger_body, direction);
        }, _overflow = {
            auto: 1,
            scroll: 1
        }, _nestedScroll = function _nestedScroll(_ref5) {
            var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;
            var cs, node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || ScrollTrigger_gsap.core.getCache(node), time = ScrollTrigger_getTime();
            if (!cache._isScrollT || time - cache._isScrollT > 2e3) {
                while (node && node !== ScrollTrigger_body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) node = node.parentNode;
                cache._isScroll = node && node !== target && !ScrollTrigger_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
                cache._isScrollT = time;
            }
            if (cache._isScroll || axis === "x") {
                event.stopPropagation();
                event._gsapAllow = true;
            }
        }, _inputObserver = function _inputObserver(target, type, inputs, nested) {
            return Observer_Observer.create({
                target,
                capture: true,
                debounce: false,
                lockAxis: true,
                type,
                onWheel: nested = nested && _nestedScroll,
                onPress: nested,
                onDrag: nested,
                onScroll: nested,
                onEnable: function onEnable() {
                    return inputs && ScrollTrigger_addListener(ScrollTrigger_doc, Observer_Observer.eventTypes[0], _captureInputs, false, true);
                },
                onDisable: function onDisable() {
                    return ScrollTrigger_removeListener(ScrollTrigger_doc, Observer_Observer.eventTypes[0], _captureInputs, true);
                }
            });
        }, _inputExp = /(input|label|select|textarea)/i, _captureInputs = function _captureInputs(e) {
            var isInput = _inputExp.test(e.target.tagName);
            if (isInput || _inputIsFocused) {
                e._gsapAllow = true;
                _inputIsFocused = isInput;
            }
        }, _getScrollNormalizer = function _getScrollNormalizer(vars) {
            ScrollTrigger_isObject(vars) || (vars = {});
            vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
            vars.type || (vars.type = "wheel,touch");
            vars.debounce = !!vars.debounce;
            vars.id = vars.id || "normalizer";
            var self, maxY, lastRefreshID, skipTouchMove, tween, startScrollX, startScrollY, onStopDelayedCall, _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, target = _getTarget(vars.target) || ScrollTrigger_docEl, smoother = ScrollTrigger_gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer_Observer.isTouch && ScrollTrigger_win.visualViewport ? ScrollTrigger_win.visualViewport.scale * ScrollTrigger_win.visualViewport.width : ScrollTrigger_win.outerWidth) / ScrollTrigger_win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = ScrollTrigger_isFunction(momentum) ? function() {
                return momentum(self);
            } : function() {
                return momentum || 2.8;
            }, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove() {
                return skipTouchMove = false;
            }, scrollClampX = ScrollTrigger_passThrough, scrollClampY = ScrollTrigger_passThrough, updateClamps = function updateClamps() {
                maxY = _maxScroll(target, _vertical);
                scrollClampY = ScrollTrigger_clamp(_fixIOSBug ? 1 : 0, maxY);
                normalizeScrollX && (scrollClampX = ScrollTrigger_clamp(0, _maxScroll(target, _horizontal)));
                lastRefreshID = _refreshID;
            }, removeContentOffset = function removeContentOffset() {
                content._gsap.y = ScrollTrigger_round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
                content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
                scrollFuncY.offset = scrollFuncY.cacheID = 0;
            }, ignoreDrag = function ignoreDrag() {
                if (skipTouchMove) {
                    requestAnimationFrame(resumeTouchMove);
                    var offset = ScrollTrigger_round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);
                    if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
                        scrollFuncY.offset = scroll - scrollFuncY.v;
                        var y = ScrollTrigger_round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
                        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
                        content._gsap.y = y + "px";
                        scrollFuncY.cacheID = _scrollers.cache;
                        _updateAll();
                    }
                    return true;
                }
                scrollFuncY.offset && removeContentOffset();
                skipTouchMove = true;
            }, onResize = function onResize() {
                updateClamps();
                if (tween.isActive() && tween.vars.scrollY > maxY) scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
            };
            content && ScrollTrigger_gsap.set(content, {
                y: "+=0"
            });
            vars.ignoreCheck = function(e) {
                return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
            };
            vars.onPress = function() {
                skipTouchMove = false;
                var prevScale = scale;
                scale = ScrollTrigger_round((ScrollTrigger_win.visualViewport && ScrollTrigger_win.visualViewport.scale || 1) / initialScale);
                tween.pause();
                prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
                startScrollX = scrollFuncX();
                startScrollY = scrollFuncY();
                updateClamps();
                lastRefreshID = _refreshID;
            };
            vars.onRelease = vars.onGestureStart = function(self, wasDragging) {
                scrollFuncY.offset && removeContentOffset();
                if (!wasDragging) onStopDelayedCall.restart(true); else {
                    _scrollers.cache++;
                    var currentScroll, endScroll, dur = resolveMomentumDuration();
                    if (normalizeScrollX) {
                        currentScroll = scrollFuncX();
                        endScroll = currentScroll + dur * .05 * -self.velocityX / .227;
                        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
                        tween.vars.scrollX = scrollClampX(endScroll);
                    }
                    currentScroll = scrollFuncY();
                    endScroll = currentScroll + dur * .05 * -self.velocityY / .227;
                    dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
                    tween.vars.scrollY = scrollClampY(endScroll);
                    tween.invalidate().duration(dur).play(.01);
                    if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) ScrollTrigger_gsap.to({}, {
                        onUpdate: onResize,
                        duration: dur
                    });
                }
                onRelease && onRelease(self);
            };
            vars.onWheel = function() {
                tween._ts && tween.pause();
                if (ScrollTrigger_getTime() - wheelRefresh > 1e3) {
                    lastRefreshID = 0;
                    wheelRefresh = ScrollTrigger_getTime();
                }
            };
            vars.onChange = function(self, dx, dy, xArray, yArray) {
                _refreshID !== lastRefreshID && updateClamps();
                dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1]));
                if (dy) {
                    scrollFuncY.offset && removeContentOffset();
                    var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);
                    isTouch && y !== yClamped && (startScrollY += yClamped - y);
                    scrollFuncY(yClamped);
                }
                (dy || dx) && _updateAll();
            };
            vars.onEnable = function() {
                _allowNativePanning(target, normalizeScrollX ? false : "x");
                ScrollTrigger_ScrollTrigger.addEventListener("refresh", onResize);
                ScrollTrigger_addListener(ScrollTrigger_win, "resize", onResize);
                if (scrollFuncY.smooth) {
                    scrollFuncY.target.style.scrollBehavior = "auto";
                    scrollFuncY.smooth = scrollFuncX.smooth = false;
                }
                inputObserver.enable();
            };
            vars.onDisable = function() {
                _allowNativePanning(target, true);
                ScrollTrigger_removeListener(ScrollTrigger_win, "resize", onResize);
                ScrollTrigger_ScrollTrigger.removeEventListener("refresh", onResize);
                inputObserver.kill();
            };
            vars.lockAxis = vars.lockAxis !== false;
            self = new Observer_Observer(vars);
            self.iOS = _fixIOSBug;
            _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
            _fixIOSBug && ScrollTrigger_gsap.ticker.add(ScrollTrigger_passThrough);
            onStopDelayedCall = self._dc;
            tween = ScrollTrigger_gsap.to(self, {
                ease: "power4",
                paused: true,
                scrollX: normalizeScrollX ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                modifiers: {
                    scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), (function() {
                        return tween.pause();
                    }))
                },
                onUpdate: _updateAll,
                onComplete: onStopDelayedCall.vars.onComplete
            });
            return self;
        };
        ScrollTrigger_ScrollTrigger.sort = function(func) {
            return _triggers.sort(func || function(a, b) {
                return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
            });
        };
        ScrollTrigger_ScrollTrigger.observe = function(vars) {
            return new Observer_Observer(vars);
        };
        ScrollTrigger_ScrollTrigger.normalizeScroll = function(vars) {
            if (typeof vars === "undefined") return ScrollTrigger_normalizer;
            if (vars === true && ScrollTrigger_normalizer) return ScrollTrigger_normalizer.enable();
            if (vars === false) return ScrollTrigger_normalizer && ScrollTrigger_normalizer.kill();
            var normalizer = vars instanceof Observer_Observer ? vars : _getScrollNormalizer(vars);
            ScrollTrigger_normalizer && ScrollTrigger_normalizer.target === normalizer.target && ScrollTrigger_normalizer.kill();
            ScrollTrigger_isViewport(normalizer.target) && (ScrollTrigger_normalizer = normalizer);
            return normalizer;
        };
        ScrollTrigger_ScrollTrigger.core = {
            _getVelocityProp,
            _inputObserver,
            _scrollers,
            _proxies,
            bridge: {
                ss: function ss() {
                    _lastScrollTime || ScrollTrigger_dispatch("scrollStart");
                    _lastScrollTime = ScrollTrigger_getTime();
                },
                ref: function ref() {
                    return _refreshing;
                }
            }
        };
        ScrollTrigger_getGSAP() && ScrollTrigger_gsap.registerPlugin(ScrollTrigger_ScrollTrigger);
        /*!
 * matrix 3.12.0
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var matrix_doc, matrix_win, matrix_docElement, matrix_body, _divContainer, _svgContainer, _identityMatrix, _gEl, _hasOffsetBug, matrix_transformProp = "transform", matrix_transformOriginProp = matrix_transformProp + "Origin", _setDoc = function _setDoc(element) {
            var doc = element.ownerDocument || element;
            if (!(matrix_transformProp in element.style) && "msTransform" in element.style) {
                matrix_transformProp = "msTransform";
                matrix_transformOriginProp = matrix_transformProp + "Origin";
            }
            while (doc.parentNode && (doc = doc.parentNode)) ;
            matrix_win = window;
            _identityMatrix = new Matrix2D;
            if (doc) {
                matrix_doc = doc;
                matrix_docElement = doc.documentElement;
                matrix_body = doc.body;
                _gEl = matrix_doc.createElementNS("http://www.w3.org/2000/svg", "g");
                _gEl.style.transform = "none";
                var d1 = doc.createElement("div"), d2 = doc.createElement("div");
                matrix_body.appendChild(d1);
                d1.appendChild(d2);
                d1.style.position = "static";
                d1.style[matrix_transformProp] = "translate3d(0,0,1px)";
                _hasOffsetBug = d2.offsetParent !== d1;
                matrix_body.removeChild(d1);
            }
            return doc;
        }, _forceNonZeroScale = function _forceNonZeroScale(e) {
            var a, cache;
            while (e && e !== matrix_body) {
                cache = e._gsap;
                cache && cache.uncache && cache.get(e, "x");
                if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
                    cache.scaleX = cache.scaleY = 1e-4;
                    cache.renderTransform(1, cache);
                    a ? a.push(cache) : a = [ cache ];
                }
                e = e.parentNode;
            }
            return a;
        }, _svgTemps = [], _divTemps = [], _getDocScrollTop = function _getDocScrollTop() {
            return matrix_win.pageYOffset || matrix_doc.scrollTop || matrix_docElement.scrollTop || matrix_body.scrollTop || 0;
        }, _getDocScrollLeft = function _getDocScrollLeft() {
            return matrix_win.pageXOffset || matrix_doc.scrollLeft || matrix_docElement.scrollLeft || matrix_body.scrollLeft || 0;
        }, _svgOwner = function _svgOwner(element) {
            return element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null);
        }, _isFixed = function _isFixed(element) {
            if (matrix_win.getComputedStyle(element).position === "fixed") return true;
            element = element.parentNode;
            if (element && element.nodeType === 1) return _isFixed(element);
        }, _createSibling = function _createSibling(element, i) {
            if (element.parentNode && (matrix_doc || _setDoc(element))) {
                var svg = _svgOwner(element), ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", type = svg ? i ? "rect" : "g" : "div", x = i !== 2 ? 0 : 100, y = i === 3 ? 100 : 0, css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", e = matrix_doc.createElementNS ? matrix_doc.createElementNS(ns.replace(/^https/, "http"), type) : matrix_doc.createElement(type);
                if (i) if (!svg) {
                    if (!_divContainer) {
                        _divContainer = _createSibling(element);
                        _divContainer.style.cssText = css;
                    }
                    e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";
                    _divContainer.appendChild(e);
                } else {
                    _svgContainer || (_svgContainer = _createSibling(element));
                    e.setAttribute("width", .01);
                    e.setAttribute("height", .01);
                    e.setAttribute("transform", "translate(" + x + "," + y + ")");
                    _svgContainer.appendChild(e);
                }
                return e;
            }
            throw "Need document and parent.";
        }, _consolidate = function _consolidate(m) {
            var c = new Matrix2D, i = 0;
            for (;i < m.numberOfItems; i++) c.multiply(m.getItem(i).matrix);
            return c;
        }, _getCTM = function _getCTM(svg) {
            var transform, m = svg.getCTM();
            if (!m) {
                transform = svg.style[matrix_transformProp];
                svg.style[matrix_transformProp] = "none";
                svg.appendChild(_gEl);
                m = _gEl.getCTM();
                svg.removeChild(_gEl);
                transform ? svg.style[matrix_transformProp] = transform : svg.style.removeProperty(matrix_transformProp.replace(/([A-Z])/g, "-$1").toLowerCase());
            }
            return m || _identityMatrix.clone();
        }, _placeSiblings = function _placeSiblings(element, adjustGOffset) {
            var container, m, b, x, y, cs, svg = _svgOwner(element), isRootSVG = element === svg, siblings = svg ? _svgTemps : _divTemps, parent = element.parentNode;
            if (element === matrix_win) return element;
            siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
            container = svg ? _svgContainer : _divContainer;
            if (svg) {
                if (isRootSVG) {
                    b = _getCTM(element);
                    x = -b.e / b.a;
                    y = -b.f / b.d;
                    m = _identityMatrix;
                } else if (element.getBBox) {
                    b = element.getBBox();
                    m = element.transform ? element.transform.baseVal : {};
                    m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix;
                    x = m.a * b.x + m.c * b.y;
                    y = m.b * b.x + m.d * b.y;
                } else {
                    m = new Matrix2D;
                    x = y = 0;
                }
                if (adjustGOffset && element.tagName.toLowerCase() === "g") x = y = 0;
                (isRootSVG ? svg : parent).appendChild(container);
                container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
            } else {
                x = y = 0;
                if (_hasOffsetBug) {
                    m = element.offsetParent;
                    b = element;
                    while (b && (b = b.parentNode) && b !== m && b.parentNode) if ((matrix_win.getComputedStyle(b)[matrix_transformProp] + "").length > 4) {
                        x = b.offsetLeft;
                        y = b.offsetTop;
                        b = 0;
                    }
                }
                cs = matrix_win.getComputedStyle(element);
                if (cs.position !== "absolute" && cs.position !== "fixed") {
                    m = element.offsetParent;
                    while (parent && parent !== m) {
                        x += parent.scrollLeft || 0;
                        y += parent.scrollTop || 0;
                        parent = parent.parentNode;
                    }
                }
                b = container.style;
                b.top = element.offsetTop - y + "px";
                b.left = element.offsetLeft - x + "px";
                b[matrix_transformProp] = cs[matrix_transformProp];
                b[matrix_transformOriginProp] = cs[matrix_transformOriginProp];
                b.position = cs.position === "fixed" ? "fixed" : "absolute";
                element.parentNode.appendChild(container);
            }
            return container;
        }, _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {
            m.a = a;
            m.b = b;
            m.c = c;
            m.d = d;
            m.e = e;
            m.f = f;
            return m;
        };
        var Matrix2D = function() {
            function Matrix2D(a, b, c, d, e, f) {
                if (a === void 0) a = 1;
                if (b === void 0) b = 0;
                if (c === void 0) c = 0;
                if (d === void 0) d = 1;
                if (e === void 0) e = 0;
                if (f === void 0) f = 0;
                _setMatrix(this, a, b, c, d, e, f);
            }
            var _proto = Matrix2D.prototype;
            _proto.inverse = function inverse() {
                var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, determinant = a * d - b * c || 1e-10;
                return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);
            };
            _proto.multiply = function multiply(matrix) {
                var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, a2 = matrix.a, b2 = matrix.c, c2 = matrix.b, d2 = matrix.d, e2 = matrix.e, f2 = matrix.f;
                return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);
            };
            _proto.clone = function clone() {
                return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
            };
            _proto.equals = function equals(matrix) {
                var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;
                return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;
            };
            _proto.apply = function apply(point, decoratee) {
                if (decoratee === void 0) decoratee = {};
                var x = point.x, y = point.y, a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;
                decoratee.x = x * a + y * c + e || 0;
                decoratee.y = x * b + y * d + f || 0;
                return decoratee;
            };
            return Matrix2D;
        }();
        function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {
            if (!element || !element.parentNode || (matrix_doc || _setDoc(element)).documentElement === element) return new Matrix2D;
            var zeroScales = _forceNonZeroScale(element), svg = _svgOwner(element), temps = svg ? _svgTemps : _divTemps, container = _placeSiblings(element, adjustGOffset), b1 = temps[0].getBoundingClientRect(), b2 = temps[1].getBoundingClientRect(), b3 = temps[2].getBoundingClientRect(), parent = container.parentNode, isFixed = !includeScrollInFixed && _isFixed(element), m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));
            parent.removeChild(container);
            if (zeroScales) {
                b1 = zeroScales.length;
                while (b1--) {
                    b2 = zeroScales[b1];
                    b2.scaleX = b2.scaleY = 0;
                    b2.renderTransform(1, b2);
                }
            }
            return inverse ? m.inverse() : m;
        }
        /*!
 * MotionPathPlugin 3.12.0
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var MotionPathPlugin_gsap, MotionPathPlugin_PropTween, _getUnit, MotionPathPlugin_toArray, MotionPathPlugin_getStyleSaver, MotionPathPlugin_reverting, _xProps = "x,translateX,left,marginLeft,xPercent".split(","), _yProps = "y,translateY,top,marginTop,yPercent".split(","), MotionPathPlugin_DEG2RAD = Math.PI / 180, MotionPathPlugin_getGSAP = function _getGSAP() {
            return MotionPathPlugin_gsap || typeof window !== "undefined" && (MotionPathPlugin_gsap = window.gsap) && MotionPathPlugin_gsap.registerPlugin && MotionPathPlugin_gsap;
        }, _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {
            var l = values.length, si = mode === 2 ? 0 : mode, i = 0;
            for (;i < l; i++) {
                segment[si] = parseFloat(values[i][property]);
                mode === 2 && (segment[si + 1] = 0);
                si += 2;
            }
            return segment;
        }, _getPropNum = function _getPropNum(target, prop, unit) {
            return parseFloat(target._gsap.get(target, prop, unit || "px")) || 0;
        }, _relativize = function _relativize(segment) {
            var i, x = segment[0], y = segment[1];
            for (i = 2; i < segment.length; i += 2) {
                x = segment[i] += x;
                y = segment[i + 1] += y;
            }
        }, _segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {
            if (vars.type === "cubic") segment = [ segment ]; else {
                vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);
                vars.relative && _relativize(segment);
                var pointFunc = y ? pointsToSegment : flatPointsToSegment;
                segment = [ pointFunc(segment, vars.curviness) ];
            }
            segment = slicer(_align(segment, target, vars));
            _addDimensionalPropTween(plugin, target, x, segment, "x", unitX);
            y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);
            return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12));
        }, MotionPathPlugin_emptyFunc = function _emptyFunc(v) {
            return v;
        }, MotionPathPlugin_numExp = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g, _originToPoint = function _originToPoint(element, origin, parentMatrix) {
            var svg, m = getGlobalMatrix(element), x = 0, y = 0;
            if ((element.tagName + "").toLowerCase() === "svg") {
                svg = element.viewBox.baseVal;
                svg.width || (svg = {
                    width: +element.getAttribute("width"),
                    height: +element.getAttribute("height")
                });
            } else svg = origin && element.getBBox && element.getBBox();
            if (origin && origin !== "auto") {
                x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;
                y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;
            }
            return parentMatrix.apply(x || y ? m.apply({
                x,
                y
            }) : {
                x: m.e,
                y: m.f
            });
        }, _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {
            var p, parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true), m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)), fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix), _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix), x = _originToPoint2.x, y = _originToPoint2.y;
            m.e = m.f = 0;
            if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {
                p = toElement.getAttribute("d").match(MotionPathPlugin_numExp) || [];
                p = m.apply({
                    x: +p[0],
                    y: +p[1]
                });
                x += p.x;
                y += p.y;
            }
            if (p) {
                p = m.apply(toElement.getBBox());
                x -= p.x;
                y -= p.y;
            }
            m.e = x - fromPoint.x;
            m.f = y - fromPoint.y;
            return m;
        }, _align = function _align(rawPath, target, _ref) {
            var align = _ref.align, matrix = _ref.matrix, offsetX = _ref.offsetX, offsetY = _ref.offsetY, alignOrigin = _ref.alignOrigin;
            var alignTarget, m, p, x = rawPath[0][0], y = rawPath[0][1], curX = _getPropNum(target, "x"), curY = _getPropNum(target, "y");
            if (!rawPath || !rawPath.length) return getRawPath("M0,0L0,0");
            if (align) if (align === "self" || (alignTarget = MotionPathPlugin_toArray(align)[0] || target) === target) transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y); else {
                if (alignOrigin && alignOrigin[2] !== false) MotionPathPlugin_gsap.set(target, {
                    transformOrigin: alignOrigin[0] * 100 + "% " + alignOrigin[1] * 100 + "%"
                }); else alignOrigin = [ _getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100 ];
                m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");
                p = m.apply({
                    x,
                    y
                });
                transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));
            }
            if (matrix) transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f); else if (offsetX || offsetY) transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);
            return rawPath;
        }, _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {
            var cache = target._gsap, harness = cache.harness, alias = harness && harness.aliases && harness.aliases[property], prop = alias && alias.indexOf(",") < 0 ? alias : property, pt = plugin._pt = new MotionPathPlugin_PropTween(plugin._pt, target, prop, 0, 0, MotionPathPlugin_emptyFunc, 0, cache.set(target, prop, plugin));
            pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;
            pt.path = rawPath;
            pt.pp = pathProperty;
            plugin._props.push(prop);
        }, _sliceModifier = function _sliceModifier(start, end) {
            return function(rawPath) {
                return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;
            };
        };
        var MotionPathPlugin = {
            version: "3.12.0",
            name: "motionPath",
            register: function register(core, Plugin, propTween) {
                MotionPathPlugin_gsap = core;
                _getUnit = MotionPathPlugin_gsap.utils.getUnit;
                MotionPathPlugin_toArray = MotionPathPlugin_gsap.utils.toArray;
                MotionPathPlugin_getStyleSaver = MotionPathPlugin_gsap.core.getStyleSaver;
                MotionPathPlugin_reverting = MotionPathPlugin_gsap.core.reverting || function() {};
                MotionPathPlugin_PropTween = propTween;
            },
            init: function init(target, vars, tween) {
                if (!MotionPathPlugin_gsap) {
                    console.warn("Please gsap.registerPlugin(MotionPathPlugin)");
                    return false;
                }
                if (!(typeof vars === "object" && !vars.style) || !vars.path) vars = {
                    path: vars
                };
                var rawPath, p, rawPaths = [], _vars = vars, path = _vars.path, autoRotate = _vars.autoRotate, unitX = _vars.unitX, unitY = _vars.unitY, x = _vars.x, y = _vars.y, firstObj = path[0], slicer = _sliceModifier(vars.start, "end" in vars ? vars.end : 1);
                this.rawPaths = rawPaths;
                this.target = target;
                this.tween = tween;
                this.styles = MotionPathPlugin_getStyleSaver && MotionPathPlugin_getStyleSaver(target, "transform");
                if (this.rotate = autoRotate || autoRotate === 0) {
                    this.rOffset = parseFloat(autoRotate) || 0;
                    this.radians = !!vars.useRadians;
                    this.rProp = vars.rotation || "rotation";
                    this.rSet = target._gsap.set(target, this.rProp, this);
                    this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;
                }
                if (Array.isArray(path) && !("closed" in path) && typeof firstObj !== "number") {
                    for (p in firstObj) if (!x && ~_xProps.indexOf(p)) x = p; else if (!y && ~_yProps.indexOf(p)) y = p;
                    if (x && y) rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y]))); else x = y = 0;
                    for (p in firstObj) p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));
                } else {
                    rawPath = slicer(_align(getRawPath(vars.path), target, vars));
                    cacheRawPathMeasurements(rawPath, vars.resolution);
                    rawPaths.push(rawPath);
                    _addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");
                    _addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");
                }
            },
            render: function render(ratio, data) {
                var rawPaths = data.rawPaths, i = rawPaths.length, pt = data._pt;
                if (data.tween._time || !MotionPathPlugin_reverting()) {
                    if (ratio > 1) ratio = 1; else if (ratio < 0) ratio = 0;
                    while (i--) getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);
                    while (pt) {
                        pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);
                        pt = pt._next;
                    }
                    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? MotionPathPlugin_DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);
                } else data.styles.revert();
            },
            getLength: function getLength(path) {
                return cacheRawPathMeasurements(getRawPath(path)).totalLength;
            },
            sliceRawPath,
            getRawPath,
            pointsToSegment,
            stringToRawPath,
            rawPathToString,
            transformRawPath,
            getGlobalMatrix,
            getPositionOnPath,
            cacheRawPathMeasurements,
            convertToPath: function convertToPath(targets, swap) {
                return MotionPathPlugin_toArray(targets).map((function(target) {
                    return paths_convertToPath(target, swap !== false);
                }));
            },
            convertCoordinates: function convertCoordinates(fromElement, toElement, point) {
                var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));
                return point ? m.apply(point) : m;
            },
            getAlignMatrix: _getAlignMatrix,
            getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {
                var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);
                return {
                    x: m.e,
                    y: m.f
                };
            },
            arrayToRawPath: function arrayToRawPath(value, vars) {
                vars = vars || {};
                var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);
                vars.relative && _relativize(segment);
                return [ vars.type === "cubic" ? segment : pointsToSegment(segment, vars.curviness) ];
            }
        };
        MotionPathPlugin_getGSAP() && MotionPathPlugin_gsap.registerPlugin(MotionPathPlugin);
        gsapWithCSS.registerPlugin(ScrollTrigger_ScrollTrigger, CustomEase, MotionPathPlugin);
        const mm = gsapWithCSS.matchMedia();
        mm.add("(max-width: 479.98px)", (() => {
            const sectionHeroMobTl = gsapWithCSS.timeline();
            const customEase = CustomEase.create("custom", "M0,0 C0.198,1 0.474,1 1,1 ");
            sectionHeroMobTl.fromTo(".section-1__bg", {
                maskSize: "100% 40vh"
            }, {
                maskSize: "400% 200vh"
            });
            sectionHeroMobTl.fromTo(".section-1__bg-main-mob", {
                y: "-35%"
            }, {
                y: 0,
                ease: "power4.out"
            }, "<");
            sectionHeroMobTl.fromTo(".section-1__bg-main", {
                y: "-25%"
            }, {
                y: 30,
                ease: customEase
            }, "<");
            sectionHeroMobTl.fromTo(".section-1__bg-water", {
                opacity: -2
            }, {
                opacity: 1
            }, "<");
            sectionHeroMobTl.to(".section-1__logo", {
                opacity: -2
            }, "<");
            sectionHeroMobTl.to(".section-1__content", {
                opacity: -2
            }, "<");
            sectionHeroMobTl.to(".section-2__head", {
                opacity: -2
            }, "<");
            sectionHeroMobTl.fromTo(".section-2__content", {
                top: "100%",
                opacity: 0
            }, {
                top: "90%",
                opacity: 1
            }, "<");
            sectionHeroMobTl.fromTo(".section-2__content", {
                y: 0
            }, {
                y: "-110%"
            });
            ScrollTrigger_ScrollTrigger.create({
                animation: sectionHeroMobTl,
                trigger: ".section-1",
                start: "bottom bottom",
                end: "bottom -200%",
                scrub: true,
                pin: true,
                onUpdate: self => {
                    let progress = self.progress.toFixed(2) * 100;
                    if (progress > 15) document.querySelectorAll(".section-1__bg-cloud").forEach((item => {
                        item.classList.add("_active");
                    })); else document.querySelectorAll(".section-1__bg-cloud").forEach((item => {
                        item.classList.remove("_active");
                    }));
                    if (progress > 30) document.querySelectorAll(".section-1__text-circle").forEach((item => {
                        item.classList.add("_active");
                    })); else if (progress < 30) document.querySelectorAll(".section-1__text-circle").forEach((item => {
                        item.classList.remove("_active");
                    }));
                }
            });
        }));
        mm.add("(min-width: 479.98px)", (() => {
            const sectionHeroTl = gsapWithCSS.timeline();
            sectionHeroTl.to(".section-2", {
                y: "-100%"
            });
            ScrollTrigger_ScrollTrigger.create({
                animation: sectionHeroTl,
                trigger: ".hero-wrapper",
                start: "bottom bottom",
                end: "bottom -100%",
                scrub: true,
                pin: true
            });
        }));
        const sectionAboutTl = gsapWithCSS.timeline();
        sectionAboutTl.to(".section-11-about", {
            yPercent: -100,
            top: "100%",
            ease: "none"
        });
        ScrollTrigger_ScrollTrigger.create({
            animation: sectionAboutTl,
            trigger: ".section-11",
            start: "bottom bottom",
            end: "bottom -100%",
            scrub: true,
            pin: true,
            onEnter: () => {
                document.querySelectorAll(".section-11__bg-cloud").forEach((item => {
                    item.classList.add("_active");
                }));
            }
        });
        const scheduleItems = document.querySelectorAll(".schedule-item");
        if (scheduleItems.length) scheduleItems.forEach((scheduleItem => {
            let scheduleItemTrigger = ScrollTrigger_ScrollTrigger.create({
                trigger: scheduleItem,
                start: "top center",
                end: "top center",
                onEnter: () => {
                    scheduleItemTrigger.trigger.classList.add("schedule-item--active");
                },
                onEnterBack: () => {
                    scheduleItemTrigger.trigger.classList.remove("schedule-item--active");
                }
            });
        }));
        const section4ScheduleItem = document.querySelector(".section-4__schedule-item");
        if (section4ScheduleItem) {
            const stickyTitle = ScrollTrigger_ScrollTrigger.create({
                trigger: ".section-4__left",
                start: () => `top center-=${section4ScheduleItem.offsetHeight / 2}`,
                end: () => `bottom center+=${section4ScheduleItem.offsetHeight / 2}`,
                pin: ".section-4__title",
                pinSpacing: false
            });
            let stickyTitleMedia = gsapWithCSS.matchMedia();
            stickyTitleMedia.add("(min-width: 991.98px)", (() => {
                stickyTitle.enable();
            }));
            stickyTitleMedia.add("(max-width: 991.98px)", (() => {
                stickyTitle.disable();
            }));
        }
        const section4Text = document.querySelector(".section-4__bottom");
        if (section4Text) {
            ScrollTrigger_ScrollTrigger.create({
                trigger: section4Text,
                start: "top bottom",
                end: "bottom bottom",
                onLeave: () => {
                    section4Text.classList.add("_active");
                },
                onLeaveBack: () => {
                    section4Text.classList.remove("_active");
                }
            });
        }
        const section6 = document.querySelector(".section-6");
        if (section6) {
            let section6Trigger = ScrollTrigger_ScrollTrigger.create({
                trigger: section6,
                start: "top bottom",
                end: "center center",
                onLeave: () => {
                    section6.querySelectorAll(".section-6__img").forEach((item => {
                        if (item) item.classList.add("_active");
                    }));
                    console.log("onLeave");
                },
                onLeaveBack: () => {
                    section6.querySelectorAll(".section-6__img").forEach((item => {
                        if (item) item.classList.remove("_active");
                    }));
                    console.log("onLeaveBack");
                }
            });
            const tl = gsapWithCSS.timeline();
            tl.fromTo(".progress-bar__connect", {
                y: "-100%"
            }, {
                y: 0
            });
            const progressBarOrigin = document.querySelector(".progress-bar__origin");
            const progressBarTrigger = ScrollTrigger_ScrollTrigger.create({
                animation: tl,
                trigger: section6,
                start: "top top",
                end: "bottom+=400%",
                scrub: true,
                pin: true,
                onUpdate: self => {
                    let progress = self.progress.toFixed(2) * 100;
                    if (self.direction === 1) {
                        if (progress > 15 && progress < 40) {
                            const item1 = section6.querySelector(".section-6__item--1");
                            const item2 = section6.querySelector(".section-6__item--2");
                            item2.classList.add("_active");
                            item1.classList.remove("_active");
                            item1.classList.add("_done");
                            progressBarOrigin.style.transform = "translateY(-66.667%)";
                        }
                        if (progress > 40 && progress < 80) {
                            const item2 = section6.querySelector(".section-6__item--2");
                            const item3 = section6.querySelector(".section-6__item--3");
                            item3.classList.add("_active");
                            item2.classList.remove("_active");
                            item2.classList.add("_done");
                            progressBarOrigin.style.transform = "translateY(-33.334%)";
                        }
                        if (progress > 80) {
                            const item3 = section6.querySelector(".section-6__item--3");
                            const item4 = section6.querySelector(".section-6__item--4");
                            item4.classList.add("_active");
                            item3.classList.remove("_active");
                            item3.classList.add("_done");
                            progressBarOrigin.style.transform = "translateY(0)";
                        }
                    }
                    if (self.direction === -1) {
                        if (progress < 20) {
                            const item1 = section6.querySelector(".section-6__item--1");
                            const item2 = section6.querySelector(".section-6__item--2");
                            item2.classList.remove("_active");
                            item1.classList.remove("_done");
                            item1.classList.add("_active");
                            progressBarOrigin.style.transform = "translateY(-100%)";
                        }
                        if (progress > 20 && progress < 45) {
                            const item2 = section6.querySelector(".section-6__item--2");
                            const item3 = section6.querySelector(".section-6__item--3");
                            item3.classList.remove("_active");
                            item2.classList.remove("_done");
                            item2.classList.add("_active");
                            progressBarOrigin.style.transform = "translateY(-66.667%)";
                        }
                        if (progress > 45 && progress < 80) {
                            const item3 = section6.querySelector(".section-6__item--3");
                            const item4 = section6.querySelector(".section-6__item--4");
                            item4.classList.remove("_active");
                            item3.classList.remove("_done");
                            item3.classList.add("_active");
                            progressBarOrigin.style.transform = "translateY(-33.334%)";
                        }
                    }
                }
            });
            let section6Media = gsapWithCSS.matchMedia();
            section6Media.add("(min-width: 991.98px)", (() => {
                section6Trigger.enable();
                progressBarTrigger.disable();
            }));
            section6Media.add("(max-width: 991.98px)", (() => {
                section6Trigger.disable();
                progressBarTrigger.enable();
            }));
        }
        const section7 = document.querySelector(".section-7");
        const tlPuzzle = gsapWithCSS.timeline();
        if (section7) {
            tlPuzzle.fromTo(".section-7__puzzle-item--1", {
                scale: 4,
                opacity: 0
            }, {
                scale: 1,
                opacity: 1,
                duration: 1.2,
                delay: 1
            }).fromTo(".section-7__puzzle-item--2", {
                scale: 4,
                opacity: 0
            }, {
                scale: 1,
                opacity: 1,
                duration: 1.2
            }).fromTo(".section-7__puzzle-item--3", {
                scale: 4,
                opacity: 0
            }, {
                scale: 1,
                opacity: 1,
                duration: 1.2
            }).fromTo(".section-7__puzzle-item--4", {
                scale: 4,
                opacity: 0
            }, {
                scale: 1,
                opacity: 1,
                duration: 1.2
            }).fromTo(".section-7__puzzle-item--5", {
                scale: 4,
                opacity: 0
            }, {
                scale: 1,
                opacity: 1,
                duration: 1.2
            }).fromTo(".section-7__puzzle-item--6", {
                scale: 4,
                opacity: 0
            }, {
                scale: 1,
                opacity: 1,
                duration: 1.2
            });
            tlPuzzle.pause();
            ScrollTrigger_ScrollTrigger.create({
                trigger: section7,
                start: "top bottom",
                end: "90% bottom",
                onLeave: () => {
                    tlPuzzle.play();
                },
                onLeaveBack: () => {}
            });
        }
        const section10 = document.querySelector(".section-10");
        if (section10) {
            section10.clientHeight;
            const section10TextTl = gsapWithCSS.timeline();
            section10TextTl.fromTo(".section-10__text", {
                top: "80%",
                x: 0,
                y: 0
            }, {
                top: "25%",
                x: 0,
                y: "-100%"
            });
            const section10TextTrigger = ScrollTrigger_ScrollTrigger.create({
                animation: section10TextTl,
                trigger: ".section-10",
                start: "top top",
                end: "bottom",
                scrub: true,
                pin: true,
                markers: true
            });
            const sectionWrapperTl = gsapWithCSS.timeline();
            sectionWrapperTl.to(".section-10", {
                y: "-100%"
            });
            const sectionWrapperTrigger = ScrollTrigger_ScrollTrigger.create({
                animation: sectionWrapperTl,
                trigger: ".section-wrapper",
                start: "bottom bottom",
                end: "bottom top",
                scrub: true,
                pin: true
            });
            const sectionWrapperMedia = gsapWithCSS.matchMedia();
            sectionWrapperMedia.add("(min-width: 1199.98px)", (() => {
                sectionWrapperTrigger.enable();
            }));
            sectionWrapperMedia.add("(max-width: 1199.98px)", (() => {
                sectionWrapperTrigger.disable();
            }));
            sectionWrapperMedia.add("(min-width: 767.98px)", (() => {
                section10TextTrigger.disable();
                section10TextTl.fromTo(".section-10__text", {
                    top: 0,
                    x: 0
                }, {
                    top: 0,
                    x: 0
                });
            }));
            sectionWrapperMedia.add("(max-width: 767.98px)", (() => {
                section10TextTrigger.enable();
            }));
        }
        var lottie_min = __webpack_require__(88);
        lottie_min.Z.loadAnimation({
            container: document.querySelector(".section-3__energy"),
            renderer: "svg",
            loop: true,
            autoplay: true,
            path: "./files/3.json"
        });
        document.querySelector(".section-9");
        document.querySelector(".section-9__img");
        function wideBlock() {
            const container = document.querySelector(".section-2__container");
            const containerStyle = getComputedStyle(container, null);
            const containerWidth = parseInt(containerStyle.getPropertyValue("width"));
            let widthL = window.innerWidth - containerWidth;
            document.documentElement.style.setProperty("--widthL", `${widthL}px`);
        }
        wideBlock();
        window.addEventListener("resize", (e => {
            wideBlock();
        }));
        window["FLS"] = true;
        isWebp();
        menuInit();
        formFieldsInit({
            viewPass: false,
            autoHeight: false
        });
        formSubmit();
    })();
})();